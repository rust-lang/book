## Сравнение производительности циклов и итераторов

Для определения какую реализацию лучше всего использовать, нам необходимо знать
скорость работы каждой и этих реализаций функции `search` (использование цикла `for`
или итераторов).

Запустить тест производительности, введя текст книги "Приключения Шерлока Хомса"
А. Конан Дойля (“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)
в качетвое входных данных содержания и поищем количество определенного артикля
(“the”) в данном тексте. Получим следующий результ:

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

Версия с использованием итераторов была немного быстрее. Мы не будем приводить код
проверочного теста производительности. Целью данной демонстрации показ работы
концепции нулевой цены за использование абстракций. Использование абстракций не
несёт каких-либо дополнительных расходов, это т.к.требуют каких-либо
дополнительных накладных расходов.

Зная об отсутствии дополнительных накладных расходов на итерации вы можете безбоязненно
использовать итераторы и замыкания. Это высокоуровневые конструкции языка делают
код более понятными без ущерба производительности.

## Итоги

Замыкания и итераторы - это элементы функционального программирования реализованные
в языке Rust. Они предоставляют инструмент для простого и понятного описания рутинных
операций, скрывая код, где программисты потенциально могут сделать ошибки. Важно, что
использование абстрактный конструкций не влияет на производительность конечного
решения.

<!-- Are we going to cover which other elements of rust are zero-cost
abstractions, somewhere? Might be good to cross ref or, if we've already
covered, give a brief list or a way to identify them -->
<!-- Zero-cost abstraction in Rust is more about a design philosophy and a goal
we keep in mind; ёall abstractions in Rust strive to be zero-cost abstractions,
and if they aren't, it's considered a bug. There will always be some bugs. I've
reworded a bit to not make it sound as much like something we could list.
/Carol -->

Теперь, когда мы улучшили представление кода в нашем проекте, рассмотрим некоторые
опции, которые нам предоставляет `cargo` для публикации нашего кода в репозитории.
