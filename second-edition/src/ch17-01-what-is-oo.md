## 객체-지향 언어들의 특성들

객체 지향 지향하는 언어가 반드시 갖춰야 할 기능에 대해 프로그래밍 커뮤니티들은 일치를 보지 못하고 있습니다. Rust는 많은 프로그래밍 패러다임에 영향을 받았으며, OOP도 포함합니다; 예를 들면, 우리가 13장에서 살펴본 기능인 함수형 프로그래밍에서 온 기능들이요. OOP 언어는 몇개의 공통적인 특성을 공유하는데, 객체, 캡슐화 및 상속이있습니다. 살펴볼 것은 이들 특성들 각각의 의미와 Rust가 지원하는가 입니다. 

### 객체들이 내재하는 데이터와 행위들 

Enoch Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
Professional, 1994)의 책 *Design Patterns: Elements of Reusable Object-Oriented Software* 속어로 *The Gang of Four*라고도 하는 책의 객체-지향 디자인 패턴의 편람입니다. 여기서 OOP는 다음과 같이 정의합니다.

> 객체-지향 프로그램은 객체로 구성된다. *객체*는 데이터와 그 데이터를 활용하는 프로시저를 패키지한다. 
> 이 프로시저들은 보통 *methods*나 *operation*으로 불린다.

이 정의에 따르면, Rust는 객체 지향적입니다: structs와 enums들은 데이터를 갖고, `impl` 블럭들은 그 structs와 enums들에 대한 methods들을 제공하죠. 설령 methods를 갖는 structs와 enums를 객체라고 *호칭*하지 않더라도, 그들은 동일한 기능을 수행하며, 이는 Gang of Four의 객체에 대한 정의를 따릅니다.

### 상세 구현을 은닉하는 캡슐화

OOP와 관련된 일반항목의 또 다른 면은 *캡슐화*로 의미는 객체의 상세 구현을 객체를 통해 접근할 수 없게 만든다 입니다. 따라서, 유일하게 객체와 상호작용하는 방법은 그의 공개 API를 통하는 것; 객체를 사용하는 코드는 객체의 내부에 접근하거나 데이터를 변경하거나 직접적인 행위를 해서는 안됩니다. 이는 프로그래머가 객체를 사용하는 코드의 변경없이 객체 내부를 리팩토링하거나 변경할 수 있도록 해줍니다. 

우리가 7장에서 토의했던 캡슐화를 제어하는 방안: 우리가 사용할 수 있는 `pub`키워드를 통해 모듈들, 타입들, 함수들, 그리고 메소드들이 공개될 것인가를 결정하며 기본적으로는 모든 것들이 비공개입니다. 예를 들어, 우리가 정의할 구조체 `AveragedCollection`이 가진 필드에는 `i32`값의 벡터가 있습니다. 마찬가지로, 이 구조체가 소유할 필드는 벡터안의 값들에 대한 평균 average으로, average가 의미하는 바는 누군가 그게 필요할 때 계산하지 않아도 된다는 겁니다. 즉, `AveragedCollection`은 계산된 평균 값을 우리를 위해 캐쉬합니다. 항목 17-1에 있는 정의는 `AveragedCollection` 구조체 입니다.

<span class="filename">Filename: src/lib.rs</span>

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```

<span class="caption">항목 17-1: `AveragedCollection` 구조체로 정수 항목들과 그의 평균을 관리합니다. </span>

구조체가 `pub`으로 표기되면 다른 코드가 그를 사용할 수 있게 되지만, 구조체 안에 존재하는 필드들은 여전히 비공개입니다. 이는 이번 사례에 매우 중요한데 왜냐면 우리가 확정되길 원하는 바는 하나의 값이 리스트에서 더해지거나 제거될 때, 평균 또한 갱신되는 것 입니다. 우리는 이를 `add`, `remove`, 그리고 `average` 메소드를 구조체에 구현하여 하려고 하며, 항목 17-2에서 볼 수 있습니다:

<span class="filename">Filename: src/lib.rs</span>

```rust
# pub struct AveragedCollection {
#     list: Vec<i32>,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            },
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

<span class="caption">항목 17-2: `AveragedCollection`의 공개 메소드 `add`, `remove`, 그리고 `average`</span>

공개 메소드들 `add`, `remove`, 그리고 `average`들은 오직 `AveragedCollection`의 인스턴스를 변경합니다. 아이템이 `list`에 `add` 메소드를 통해 추가되거나 `remove` 메소드를 통해 제거될 때, 각각의 호출은 비공개 `update_average` 메소드를 호출하여 `average` 필드를 변경하도는 역할 또한 수행합니다.

우리는 `list`와 `average` 필드를 비공개로 둠으로 외부의 코드에서 `list` 필드에 직접적으로 접근하여 아이템들을 추가하거나 제거할 수 없습니다; 이를 다르게 표현하면, `average` 필드는 `list`가 변경될 때 동기화되게 된다는 겁니다. `average` 메소드는 `average` 필드의 값을 반환하여, 외부 코드가 `average`를 읽을 수 있도록 하지만, 변경은 안됩니다. 

우리가 `AveragedCollection`의 내부 구현을 캡슐화했기 때문에, 차후에 데이터 구조 등을 쉽게 변경할 수 있습니다. 예를 들면, 우리는 `list`필드로 `Vec<i32>`가 아닌 `HashSet<i32>`를 사용할 수 있습니다.  `add`, `remove` 그리고 `average` 공개 메소드들의 선언이 그대로 유지되는 한, `AveragedCollection`를 사용하는 코드들을 변경할 필요가 없습니다. 만약 우리가 `list`를 공개했다면 `HashSet<i32>`와 `Vec<i32>`는 아이템들을 추가하거나 제거하기 위한 메소드들이 다르므로, 만약 `list`에 직접 적근하여 변경하는 방식의 외부 코드들이 있다면 모두 변경되어야겠죠.  

만약 캡슐화가 객체 지향을 염두하는 언어를 위한 필요요소라면 Rust는 이를 만족했습니다. 다른 파트의 코드들에 대해 `pub`을 사용하거나 하지 않은 옵션으로 구현 세부 사항의 캡슐화를 가능케 합니다. 

### 타입 시스템으로서의 상속과 코드 공유 

*상속*은 객체가 다른 객체의 정의를 상속받을 수 있게 해주는 메커니즘으로, 이를 통해 부모 객체의 데이터와 동작들을 다시 정의할 필요 없이 얻을 수 있습니다. 만약 객체-지향 언어가 반드시 상속을 제공해야 한다면, Rust는 그렇지 않은 쪽이다. 부모 struct의 필드와 메소드 구현을 상속시킬 방법이 없기 때문입니다. 하지만 당신이 상속을 사용하고자 한다면, 그를 사용하고자 하는 이유나 목적에 따라 Rust의 다른 솔루션을 사용할 수 있습니다. 


당신이 상속을 택한데는 주요하게 두 가지 이유가 있습니다. 하나는 코드를 재사용하는 것: 당신은 하나의 타입의 행위를 부분적으로 구현할 수 있고, 상속은 당신이 다른 타입을 위한 구현에서 재사용할 수 있도록 만들어줍니다. 당신은 Rust 코드를 기본 특성 메소를 구현하여 공유할 수 있는데, 이는 항목 10-14에서 봤던 우리가 `Summary`특성에 `summarize` 메소드의 기본 구현을 추가한 것 입니다. `Summary` 특성을 구혀하는 어떤 타입이든, `summarize` 메소드를 별도로 작성하지 않더라도 사용 가능합니다. 이는 구현된 메소드들을 갖는 부모 클래스와 그를 상속받는 자식 클래스 또한 구현된 메소드들을 갖는 것과 유사합니다. 우리는 또한 구현된 `summarize` 재정의를 `Summary` 특성을 구현할 때 할 수 있고, 이는 자식 클래스가 부모 클래스에서 상속받는 메소드를 재정의하는 것과 유사합니다. 

타입 시스템에 상속을 사용하려는 다른 이유는 자식 타입을 같은 위치에서 부모 타입과 동일하게 사용할 수 있게 하기 위함입니다. 이는 또한 *polymorphism (다형성)*이라고도 불리며, 이는 런타임에 당신이 다양한 객체들 서로를 그들이 공유하는 일정 특성으로 대체하여 사용할 수 있음을 의미합니다.

> ### 다형성 
>
> 많은 사람들이, 다형성을 상속과 동일시 합니다. 하지만 다수의 타입들의 데이터를 코드로 참조할 수 있는 것은 보다 
> 범용적인 컨셉입니다. 상속에서는 이런 타입들은 하위클래스들로 생성되죠. 
>
> Rust는 대신 제네릭을 사용하여 호환 가능한 타입들을 추상화하고 특성 내에서 이들 타입들이 반드시 제공해야 하는 
> 사항들에 대한 제약 사항을 부과합니다. 이는 때론 *bounded parametric polymorphism*이라 불립니다.
> (역주; 범위 내에 특정 요소를 매개변수처럼 지정하는 방식의 다형성 = 범주내 매개 다형성)

상속은 최근에는 많은 프로그래밍 언어에서 프로그래밍 디자인 솔루션으로서 인기가 없어지고 있는데 그 이유는 필요한 것보다 더 많은 코드를 공유할 수 있는 위험이 있기 때문입니다. 하위 클래스가 늘 그들의 부모 클래스의 모든 특성을 공유해서는 안되지만 상속한다면 그렇게 됩니다. 이는 프로그램의 유연성을 저하시킬 수 있습니다. 또한, 하위 클래스에서는 사용할 수 없거나 적용될 수 없어서 에러를 유발하는 메소드들이 호출될 수 있는 가능성을 만듭니다. 게다가, 어떤 언어들은 하나의 클래스에 대한 상속만을 허용하기 때문에 프로그램 디자인의 유연성을 더욱 제한하게 됩니다. 
 
이런 이유로, Rust는 다른 방식을 취하여, 상속 대신에 특성 객체를 사용합니다.
자, 이제 Rust에서 특성 객체를 활용하여 다형성을 활용하는 방법을 알아봅시다. 
