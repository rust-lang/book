## Приложение Б: Операторы

### Операторы имеющие один операнд (т.н. унарные выражения)

В языке программирования Rust имеются унарные выражения. Их местоположение - перед
переменной.

* `-`
  : Знак отрицательной величины. Знаковые переменный как целочисленные литералы,
    так с плавающей точкой могут быть отрицательными. Беззнаковые литералы, которые
    имеют префикс `-` вызывают ошибку компиляции: например, `-1u32`.
* `*`
  : Оператор разыменования. Если данные оператор применяется к переменной ссылочного
    типа (указателя), то этот оператор обозначает данные на место в памяти.
    Данные оператор может быть применён для указателей на переменное значение памяти.
    Для других типов переменных (не ссылочных), он вызывает метод `deref` типажа
    `std::ops::Deref` или метод `deref_mut` типажа `std::ops::DerefMut`.
* `!`
  : Логическое отрицание. Если переменная логического типа - значение инвертируется.
    Если тип данных целочисленное значение - инвертируются биты данного числа.
* `&` и `&mut`
  : Заимствование. Когда этот оператор применятся к значению, этот оператор возвращает
    ссылку на это значение. Также это значение переходит в состояние "заимствовано"
    на период существования ссылочной переменной. При использовании оператора (`&`)
    накладывается также ещё одно ограничение - она не может содержать иное значение.
    При использовании оператора  (`&mut`) значение переменной не может быть прочтено
    на период существования ссылочной переменной.


### Операторы имеющие два оператора (т.н. бинарные выражения)

Бинарные выражения в порядке приоритета (т.е. сначала выполняются арифметические
операции, потом бинарные, потом логические.

#### Арифметические операции

Бинарные арифметические выражения - это синтаксические выражения заменяющие в коде
вызовы функций соответствующих типажей, определённых в модуле `std::ops` библиотеки
`std`. Это значит, что арифметические операторы могут быть переопределены (перезагружены)
в пользовательских типах данных. Список значений операций:

* `+`
  : Сложение, а также объединение массивов и строк.
    Вызывается метод `add` типажа `std::ops::Add`.
* `-`
  : Вычитание.
    Вызывается метод `sub` типажа `std::ops::Sub`.
* `*`
  : Умножение.
    Вызывается метод `mul` типажа `std::ops::Mul`.
* `/`
  : Деление.
    Вызывается метод `div` типажа `std::ops::Div`.
* `%`
  : Остаток от деления.
    Вызывается метод `rem` типажа `std::ops::Rem`.

Обратите внимание, что Rust не имеет стандартного оператора возведения в степень
(power). Существует метод `pow` у численных типов данных.

#### Битовые операторы

Также как и арифметические операторы, битовые операторы - это синтаксические
выражения заменяющие в коде вызовы функций соответствующих типажей. Это значит,
что битовые операторы могут быть переопределены в пользовательских типах данных.
Смысл синтаксических конструкций стандартных типов следующий: если операторы `&`,
`|` и `^` применяются к логическим переменным они соответствуют их логическим
операторам-эквивалентам `&&`, `||` и `!=`. Правда, результат их использования будет
отличаться.

* `&`
  : Битовое И (&).
    Вызывает метод `bitand` типажа `std::ops::BitAnd`.
* `|`
  : Битовое включающее ИЛИ (|).
    Вызывает метод `bitor` типажа `std::ops::BitOr`.
* `^`
  : Битовое исключающее ИЛИ (^).
    Вызывает метод `bitxor` типажа `std::ops::BitXor`.
* `<<`
  : Здвиг в лево (<<).
    Вызывает метод `shl` типажа `std::ops::Shl`.
* `>>`
  : Здвиг в право (>>).
    Вызывает метод `shr` типажа `std::ops::Shr`.

#### Логические операторы

Операторы `||` и `&&` могут быть применены к операторам логического типа. Оператор
`||` обозначает логическое "или". Оператор `&&` обозначает логическое "и".
Разница между их бинарными аналогами следующая: если левый оператор - "истина",
то выполнения логического анализа прекращается даже если справа есть ещё логические
операторы.

#### Операции сравнения

Операторы сравнения, также как и предыдущие операторы (арифметические и битовые)
- это синтаксические выражения заменяющие в коде вызовы функций соответствующих
типажей. Это значит, что операторы сравнения могут быть переопределены в
пользовательских типах данных. Далее приведено стандартное поведение этих операторов.

* `==`
  : Равно.
    Вызывает метод `eq` типажа `std::cmp::PartialEq`.
* `!=`
  : Unequal to.
    Вызывает метод `ne` типажа `std::cmp::PartialEq`.
* `<`
  : Less than.
    Вызывает метод `lt` типажа `std::cmp::PartialOrd`.
* `>`
  : Greater than.
    Вызывает метод `gt` типажа `std::cmp::PartialOrd`.
* `<=`
  : Less than or equal.
    Вызывает метод `le` типажа `std::cmp::PartialOrd`.
* `>=`
  : Greater than or equal.
    Вызывает метод `ge` типажа `std::cmp::PartialOrd`.

#### Выражения приведения типа

Выражение приведение типа обозначается с помощью оператора `as`.

Выполняя выражение `as` приводит значение переменной слева к типу справа.

Пример использования оператора `as`:

```rust
# fn sum(values: &[f64]) -> f64 { 0.0 }
# fn len(values: &[f64]) -> i32 { 0 }

fn average(values: &[f64]) -> f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
```
Некоторые конвертации, которые могут быть произведены с использованием оператора
`as`, также могут быть выполнены косвенным образом. Так, например, значение, которое
присваивается в момент определения переменной с помощью оператора `let` явным
образом приводит присваиваемое значение к определённому типу данных.
Косвенные конвертация предпочтительнее, т.к. она сводит к минимуму риски потери
данных при приведении типа.

#### Выражения присваивания

*Выражения присваивания* состоит из шаблонного выражения, за которым следует знак
(`=`). Далее следует выражение.

Результатом присваивания является присвоение левой части или копии или значения
правого оператора.

```
# let mut x = 0;
# let y = 0;
x = y;
```

#### Многокомпонентные операции

Операторы `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, и `>>` могут быть объединены
 с помощью оператора `=`. Выражение `lval OP= val` эквивалентно следующему
`lval = lval OP val`. Например, `x = x + 1` может быть записано следующим образом
 `x += 1`.

Все эти выражения всегда имеют беззнаковые целочисленный тип данных `unit`.

#### Приоритет операторов

Приоритет бинарных операторов Rust (от большего к меньшему):

```text
as :
* / %
+ -
<< >>
&
^
|
== != < > <= >=
&&
||
.. ...
<-
=
```
Операторы находящиеся на одном уровне, имеют приоритет с лева на право (лево - наивысший приоритет уровня).
Унарные операторы имеют такой же приоритет, что их бинарные аналоги, т.е. сначала сложение, потом вычитание.
