<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Traits: Defining Shared Behavior - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> Common Programming Concepts</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums and Pattern Matching</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> Modules</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> Controlling Visibility with <code>pub</code></a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> Common Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> Error Handling</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> Recoverable Errors with <code>Result</code></a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html" class="active"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li></ul></li><li><a href="ch20-00-unnamed-project.html"><strong>20.</strong> Un-named project</a></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong>21.3.</strong> C - Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong>21.4.</strong> D - Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong>21.5.</strong> E - Macros</a></li><li><a href="appendix-06-translation.html"><strong>21.6.</strong> F - Translations</a></li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="ch10-02-traits.html#traits-defining-shared-behavior" id="traits-defining-shared-behavior"><h2>Traits: Defining Shared Behavior</h2></a>
<p>Traits allow us to use another kind of abstraction: they let us abstract over
behavior that types can have in common. A <em>trait</em> tells the Rust compiler about
functionality a particular type has and might share with other types. In
situations where we use generic type parameters, we can use <em>trait bounds</em> to
specify, at compile time, that the generic type may be any type that implements
a trait and therefore has the behavior we want to use in that situation.</p>
<blockquote>
<p>Note: <em>Traits</em> are similar to a feature often called 'interfaces' in other
languages, though with some differences.</p>
</blockquote>
<a class="header" href="ch10-02-traits.html#defining-a-trait" id="defining-a-trait"><h3>Defining a Trait</h3></a>
<p>The behavior of a type consists of the methods we can call on that type.
Different types share the same behavior if we can call the same methods on all
of those types. Trait definitions are a way to group method signatures together
in order to define a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, say we have multiple structs that hold various kinds and amounts
of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular
place in the world, and a <code>Tweet</code> that can have at most 140 characters in its
content along with metadata like whether it was a retweet or a reply to another
tweet.</p>
<p>We want to make a media aggregator library that can display summaries of data
that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. The behavior we
need each struct to have is that it's able to be summarized, and that we can
ask for that summary by calling a <code>summary</code> method on an instance. Listing
10-11 shows the definition of a <code>Summarizable</code> trait that expresses this
concept:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String;
}

#}</code></pre></pre>
<p><span class="caption">Listing 10-11: Definition of a <code>Summarizable</code> trait that
consists of the behavior provided by a <code>summary</code> method</span></p>
<p>We declare a trait with the <code>trait</code> keyword, then the trait's name, in this
case <code>Summarizable</code>. Inside curly braces we declare the method signatures that
describe the behaviors that types that implement this trait will need to have,
in this case <code>fn summary(&amp;self) -&gt; String</code>. After the method signature, instead
of providing an implementation within curly braces, we put a semicolon. Each
type that implements this trait must then provide its own custom behavior for
the body of the method, but the compiler will enforce that any type that has
the <code>Summarizable</code> trait will have the method <code>summary</code> defined for it with
this signature exactly.</p>
<p>A trait can have multiple methods in its body, with the method signatures
listed one per line and each line ending in a semicolon.</p>
<a class="header" href="ch10-02-traits.html#implementing-a-trait-on-a-type" id="implementing-a-trait-on-a-type"><h3>Implementing a Trait on a Type</h3></a>
<p>Now that we've defined the <code>Summarizable</code> trait, we can implement it on the
types in our media aggregator that we want to have this behavior. Listing 10-12
shows an implementation of the <code>Summarizable</code> trait on the <code>NewsArticle</code> struct
that uses the headline, the author, and the location to create the return value
of <code>summary</code>. For the <code>Tweet</code> struct, we've chosen to define <code>summary</code> as the
username followed by the whole text of the tweet, assuming that tweet content
is already limited to 140 characters.</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
# pub trait Summarizable {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summarizable for NewsArticle {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summarizable for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 10-12: Implementing the <code>Summarizable</code> trait on
the <code>NewsArticle</code> and <code>Tweet</code> types</span></p>
<p>Implementing a trait on a type is similar to implementing methods that aren't
related to a trait. The difference is after <code>impl</code>, we put the trait name that
we want to implement, then say <code>for</code> and the name of the type that we want to
implement the trait for. Within the <code>impl</code> block, we put the method signatures
that the trait definition has defined, but instead of putting a semicolon after
each signature, we put curly braces and fill in the method body with the
specific behavior that we want the methods of the trait to have for the
particular type.</p>
<p>Once we've implemented the trait, we can call the methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same manner that we call methods that aren't
part of a trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>This will print <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Note that because we've defined the <code>Summarizable</code> trait and the <code>NewsArticle</code>
and <code>Tweet</code> types all in the same <code>lib.rs</code> in Listing 10-12, they're all in the
same scope. If this <code>lib.rs</code> is for a crate we've called <code>aggregator</code>, and
someone else wants to use our crate's functionality plus implement the
<code>Summarizable</code> trait on their <code>WeatherForecast</code> struct, their code would need
to import the <code>Summarizable</code> trait into their scope first before they could
implement it, like in Listing 10-13:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Summarizable;

struct WeatherForecast {
    high_temp: f64,
    low_temp: f64,
    chance_of_precipitation: f64,
}

impl Summarizable for WeatherForecast {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;The high will be {}, and the low will be {}. The chance of
        precipitation is {}%.&quot;, self.high_temp, self.low_temp,
        self.chance_of_precipitation)
    }
}
</code></pre>
<p><span class="caption">Listing 10-13: Bringing the <code>Summarizable</code> trait from our
<code>aggregator</code> crate into scope in another crate</span></p>
<p>This code also assumes <code>Summarizable</code> is a public trait, which it is because we
put the <code>pub</code> keyword before <code>trait</code> in Listing 10-11.</p>
<p>One restriction to note with trait implementations: we may implement a trait on
a type as long as either the trait or the type are local to our crate. In other
words, we aren't allowed to implement external traits on external types. We
can't implement the <code>Display</code> trait on <code>Vec</code>, for example, since both <code>Display</code>
and <code>Vec</code> are defined in the standard library. We are allowed to implement
standard library traits like <code>Display</code> on a custom type like <code>Tweet</code> as part of
our <code>aggregator</code> crate functionality. We could also implement <code>Summarizable</code> on
<code>Vec</code> in our <code>aggregator</code> crate, since we've defined <code>Summarizable</code> there. This
restriction is part of what's called the <em>orphan rule</em>, which you can look up
if you're interested in type theory. Briefly, it's called the orphan rule
because the parent type is not present. Without this rule, two crates could
implement the same trait for the same type, and the two implementations would
conflict: Rust wouldn't know which implementation to use. Because Rust enforces
the orphan rule, other people's code can't break your code and vice versa.</p>
<a class="header" href="ch10-02-traits.html#default-implementations" id="default-implementations"><h3>Default Implementations</h3></a>
<p>Sometimes it's useful to have default behavior for some or all of the methods
in a trait, instead of making every implementation on every type define custom
behavior. When we implement the trait on a particular type, we can choose to
keep or override each method's default behavior.</p>
<p>Listing 10-14 shows how we could have chosen to specify a default string for
the <code>summary</code> method of the <code>Summarize</code> trait instead of only choosing to only
define the method signature like we did in Listing 10-11:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 10-14: Definition of a <code>Summarizable</code> trait with
a default implementation of the <code>summary</code> method</span></p>
<p>If we wanted to use this default implementation to summarize instances of
<code>NewsArticle</code> instead of defining a custom implementation like we did in
Listing 10-12, we would specify an empty <code>impl</code> block:</p>
<pre><code class="language-rust ignore">impl Summarizable for NewsArticle {}
</code></pre>
<p>Even though we're no longer choosing to define the <code>summary</code> method on
<code>NewsArticle</code> directly, since the <code>summary</code> method has a default implementation
and we specified that <code>NewsArticle</code> implements the <code>Summarizable</code> trait, we can
still call the <code>summary</code> method on an instance of <code>NewsArticle</code>:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summary());
</code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Changing the <code>Summarizable</code> trait to have a default implementation for
<code>summary</code> does not require us to change anything about the implementations of
<code>Summarizable</code> on <code>Tweet</code> in Listing 10-12 or <code>WeatherForecast</code> in Listing
10-13: the syntax for overriding a default implementation is exactly the same
as the syntax for implementing a trait method that doesn't have a default
implementation.</p>
<p>Default implementations are allowed to call the other methods in the same
trait, even if those other methods don't have a default implementation. In this
way, a trait can provide a lot of useful functionality and only require
implementers to specify a small part of it. We could choose to have the
<code>Summarizable</code> trait also have an <code>author_summary</code> method whose implementation
is required, then a <code>summary</code> method that has a default implementation that
calls the <code>author_summary</code> method:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
pub trait Summarizable {
    fn author_summary(&amp;self) -&gt; String;

    fn summary(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.author_summary())
    }
}

#}</code></pre></pre>
<p>In order to use this version of <code>Summarizable</code>, we're only required to define
<code>author_summary</code> when we implement the trait on a type:</p>
<pre><code class="language-rust ignore">impl Summarizable for Tweet {
    fn author_summary(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Once we define <code>author_summary</code>, we can call <code>summary</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summary</code> will call the
definition of <code>author_summary</code> that we've provided.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>This will print <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Note that it is not possible to call the default implementation from an
overriding implementation.</p>
<a class="header" href="ch10-02-traits.html#trait-bounds" id="trait-bounds"><h3>Trait Bounds</h3></a>
<p>Now that we've defined traits and implemented those traits on types, we can use
traits with generic type parameters. We can constrain generic types so that
rather than being any type, the compiler will ensure that the type will be
limited to those types that implement a particular trait and thus have the
behavior that we need the types to have. This is called specifying <em>trait
bounds</em> on a generic type.</p>
<p>For example, in Listing 10-12, we implemented the <code>Summarizable</code> trait on the
types <code>NewsArticle</code> and <code>Tweet</code>. We can define a function <code>notify</code> that calls
the <code>summary</code> method on its parameter <code>item</code>, which is of the generic type <code>T</code>.
To be able to call <code>summary</code> on <code>item</code> without getting an error, we can use
trait bounds on <code>T</code> to specify that <code>item</code> must be of a type that implements
the <code>Summarizable</code> trait:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summarizable&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summary());
}
</code></pre>
<p>Trait bounds go with the declaration of the generic type parameter, after a
colon and within the angle brackets. Because of the trait bound on <code>T</code>, we can
call <code>notify</code> and pass in any instance of <code>NewsArticle</code> or <code>Tweet</code>. The
external code from Listing 10-13 that's using our <code>aggregator</code> crate can call
our <code>notify</code> function and pass in an instance of <code>WeatherForecast</code>, since
<code>Summarizable</code> is implemented for <code>WeatherForecast</code> as well. Code that calls
<code>notify</code> with any other type, like a <code>String</code> or an <code>i32</code>, won't compile, since
those types do not implement <code>Summarizable</code>.</p>
<p>We can specify multiple trait bounds on a generic type by using <code>+</code>. If we
needed to be able to use display formatting on the type <code>T</code> in a function as
well as the <code>summary</code> method, we can use the trait bounds <code>T: Summarizable + Display</code>. This means <code>T</code> can be any type that implements both <code>Summarizable</code>
and <code>Display</code>.</p>
<p>For functions that have multiple generic type parameters, each generic has its
own trait bounds. Specifying lots of trait bound information in the angle
brackets between a function's name and its parameter list can get hard to read,
so there's an alternate syntax for specifying trait bounds that lets us move
them to a <code>where</code> clause after the function signature. So instead of:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>We can write this instead with a <code>where</code> clause:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>This is less cluttered and makes this function's signature look more similar to
a function without lots of trait bounds, in that the function name, parameter
list, and return type are close together.</p>
<a class="header" href="ch10-02-traits.html#fixing-the-largest-function-with-trait-bounds" id="fixing-the-largest-function-with-trait-bounds"><h3>Fixing the <code>largest</code> Function with Trait Bounds</h3></a>
<p>So any time you want to use behavior defined by a trait on a generic, you need
to specify that trait in the generic type parameter's type bounds. We can now
fix the definition of the <code>largest</code> function that uses a generic type parameter
from Listing 10-5! When we set that code aside, we were getting this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; largest {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>In the body of <code>largest</code> we wanted to be able to compare two values of type <code>T</code>
using the greater-than operator. That operator is defined as a default method
on the standard library trait <code>std::cmp::PartialOrd</code>. So in order to be able to
use the greater-than operator, we need to specify <code>PartialOrd</code> in the trait
bounds for <code>T</code> so that the <code>largest</code> function will work on slices of any type
that can be compared. We don't need to bring <code>PartialOrd</code> into scope because
it's in the prelude.</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>If we try to compile this, we'll get different errors:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut largest = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref largest` or `ref mut largest`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>The key to this error is <code>cannot move out of type [T], a non-copy array</code>.
With our non-generic versions of the <code>largest</code> function, we were only trying to
find the largest <code>i32</code> or <code>char</code>. As we discussed in Chapter 4, types like
<code>i32</code> and <code>char</code> that have a known size can be stored on the stack, so they
implement the <code>Copy</code> trait. When we changed the <code>largest</code> function to be
generic, it's now possible that the <code>list</code> parameter could have types in it
that don't implement the <code>Copy</code> trait, which means we wouldn't be able to move
the value out of <code>list[0]</code> and into the <code>largest</code> variable.</p>
<p>If we only want to be able to call this code with types that are <code>Copy</code>, we can
add <code>Copy</code> to the trait bounds of <code>T</code>! Listing 10-15 shows the complete code of
a generic <code>largest</code> function that will compile as long as the types of the
values in the slice that we pass into <code>largest</code> implement both the <code>PartialOrd</code>
and <code>Copy</code> traits, like <code>i32</code> and <code>char</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::cmp::PartialOrd;

fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;numbers);
    println!(&quot;The largest number is {}&quot;, result);

    let chars = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;chars);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listing 10-15: A working definition of the <code>largest</code>
function that works on any generic type that implements the <code>PartialOrd</code> and
<code>Copy</code> traits</span></p>
<p>If we don't want to restrict our <code>largest</code> function to only types that
implement the <code>Copy</code> trait, we could specify that <code>T</code> has the trait bound
<code>Clone</code> instead of <code>Copy</code> and clone each value in the slice when we want the
<code>largest</code> function to have ownership. Using the <code>clone</code> function means we're
potentially making more heap allocations, though, and heap allocations can be
slow if we're working with large amounts of data. Another way we could
implement <code>largest</code> is for the function to return a reference to a <code>T</code> value in
the slice. If we change the return type to be <code>&amp;T</code> instead of <code>T</code> and change
the body of the function to return a reference, we wouldn't need either the
<code>Clone</code> or <code>Copy</code> trait bounds and we wouldn't be doing any heap allocations.
Try implementing these alternate solutions on your own!</p>
<p>Traits and trait bounds let us write code that uses generic type parameters in
order to reduce duplication, but still specify to the compiler exactly what
behavior our code needs the generic type to have. Because we've given the trait
bound information to the compiler, it can check that all the concrete types
used with our code provide the right behavior. In dynamically typed languages,
if we tried to call a method on a type that the type didn't implement, we'd get
an error at runtime. Rust moves these errors to compile time so that we're
forced to fix the problems before our code is even able to run. Additionally,
we don't have to write code that checks for behavior at runtime since we've
already checked at compile time, which improves performance compared to other
languages without having to give up the flexibility of generics.</p>
<p>There's another kind of generics that we've been using without even realizing
it called <em>lifetimes</em>. Rather than helping us ensure that a type has the
behavior we need it to have, lifetimes help us ensure that references are valid
as long as we need them to be. Let's learn how lifetimes do that.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch10-01-syntax.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch10-01-syntax.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
