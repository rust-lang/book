<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advanced Types - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> Common Programming Concepts</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums and Pattern Matching</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> Modules</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> Controlling Visibility with <code>pub</code></a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> Common Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> Error Handling</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> Recoverable Errors with <code>Result</code></a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html" class="active"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final project: a web server</a></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch19-04-advanced-types.html#advanced-types" id="advanced-types"><h2>Advanced Types</h2></a>
<p>The Rust type system has some features that we've mentioned or used without
discussing. We started talking about the newtype pattern in regards to traits;
we'll start with a more general discussion about why newtypes are useful as
types. We'll then move to type aliases, a feature that is similar to newtypes
but has slightly different semantics. We'll also discuss the <code>!</code> type and
dynamically sized types.</p>
<a class="header" href="ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction" id="using-the-newtype-pattern-for-type-safety-and-abstraction"><h3>Using the Newtype Pattern for Type Safety and Abstraction</h3></a>
<p>The newtype pattern that we started discussing at the end of the &quot;Advanced
Traits&quot; section, where we create a new type as a tuple struct with one field
that wraps a type can also be useful for statically enforcing that values are
never confused, and is often used to indicate the units of a value. We actually
had an example of this in Listing 19-26: the <code>Millimeters</code> and <code>Meters</code> structs
both wrap <code>u32</code> values in a new type. If we write a function with a parameter
of type <code>Millimeters</code>, we won't be able to compile a program that accidentally
tries to call that function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>Another reason to use the newtype pattern is to abstract away some
implementation details of a type: the wrapper type can expose a different
public API than the private inner type would if we used it directly in order to
restrict the functionality that is available, for example. New types can also
hide internal generic types. For example, we could provide a <code>People</code> type that
wraps a <code>HashMap&lt;i32, String&gt;</code> that stores a person's ID associated with their
name. Code using <code>People</code> would only interact with the public API we provide,
such as a method to add a name string to the <code>People</code> collection, and that code
wouldn't need to know that we assign an <code>i32</code> ID to names internally. The
newtype pattern is a lightweight way to achieve encapsulation to hide
implementation details that we discussed in Chapter 17.</p>
<a class="header" href="ch19-04-advanced-types.html#type-aliases-create-type-synonyms" id="type-aliases-create-type-synonyms"><h3>Type Aliases Create Type Synonyms</h3></a>
<p>The newtype pattern involves creating a new struct to be a new, separate type.
Rust also provides the ability to declare a <em>type alias</em> with the <code>type</code>
keyword to give an existing type another name. For example, we can create the
alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

#}</code></pre></pre>
<p>This means <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code> and
<code>Meters</code> types we created in Listing 19-26, <code>Kilometers</code> is not a separate, new
type. Values that have the type <code>Kilometers</code> will be treated exactly the same
as values of type <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);

#}</code></pre></pre>
<p>Since <code>Kilometers</code> is an alias for <code>i32</code>, they're the same type. We can add
values of type <code>i32</code> and <code>Kilometers</code> together, and we can pass <code>Kilometers</code>
values to functions that take <code>i32</code> parameters. We don't get the type checking
benefits that we get from the newtype pattern that we discussed in the previous
section.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
may have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;FnOnce() + Send + 'static&gt;
</code></pre>
<p>Writing this out in function signatures and as type annotations all over the
place can be tiresome and error-prone. Imagine having a project full of code
like that in Listing 19-31:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let f: Box&lt;FnOnce() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;FnOnce() + Send + 'static&gt;) {
    // ...
}

fn returns_long_type() -&gt; Box&lt;FnOnce() + Send + 'static&gt; {
    // ...
#     Box::new(|| ())
}

#}</code></pre></pre>
<p><span class="caption">Listing 19-31: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the amount of
repetition this project has. Here, we've introduced an alias named <code>Thunk</code> for
the verbose type, and we can replace all uses of the type with the shorter
<code>Thunk</code> as shown in Listing 19-32:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;FnOnce() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // ...
}

fn returns_long_type() -&gt; Thunk {
    // ...
#     Box::new(|| ())
}

#}</code></pre></pre>
<p><span class="caption">Listing 19-32: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>Much easier to read and write! Choosing a good name for a type alias can help
communicate your intent as well (<em>thunk</em> is a word for code to be evaluated at
a later time, so it's an appropriate name for a closure that gets stored).</p>
<p>Another common use of type aliases is with the <code>Result&lt;T, E&gt;</code> type. Consider
the <code>std::io</code> module in the standard library. I/O operations often return a
<code>Result&lt;T, E&gt;</code>, since their operations may fail to work. There's a
<code>std::io::Error</code> struct that represents all of the possible I/O errors. Many of
the functions in <code>std::io</code> will be returning <code>Result&lt;T, E&gt;</code> where the <code>E</code> is
<code>std::io::Error</code>, such as these functions in the <code>Write</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::io::Error;
# use std::fmt::Arguments;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;(), Error&gt;;
}

#}</code></pre></pre>
<p>We're writing <code>Result&lt;..., Error&gt;</code> a lot. As such, <code>std::io</code> has this type
alias declaration:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Because this is in the <code>std::io</code> module, the fully qualified alias that we can
use is <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code> filled in
as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up looking like
this:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>The type alias helps in two ways: this is easier to write <em>and</em> it gives us a
consistent interface across all of <code>std::io</code>. Because it's an alias, it is just
another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, and special syntax like <code>?</code>.</p>
<a class="header" href="ch19-04-advanced-types.html#the-never-type--that-never-returns" id="the-never-type--that-never-returns"><h3>The Never Type, <code>!</code>, that Never Returns</h3></a>
<p>Rust has a special type named <code>!</code>. In type theory lingo, it's called the
<em>bottom type</em>, but we prefer the name <em>never</em>. The name describes what it does:
it stands in the place of the return type when a function will never return.
For example:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
</code></pre>
<p>This is read as &quot;the function <code>bar</code> returns never,&quot; and functions that return
never are called <em>diverging functions</em>. We can't create values of the type <code>!</code>,
so <code>bar</code> can never possibly return. What use is a type you can never create
values for? If you think all the way back to Chapter 2, we had some code that
looked like this, reproduced here in Listing 19-33:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }

#}</code></pre></pre>
<p><span class="caption">Listing 19-33: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6, we
learned that <code>match</code> arms must return the same type. This doesn't work:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse()  {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>What would the type of <code>guess</code> be here? It'd have to be both an integer and a
string, and Rust requires that <code>guess</code> can only have one type. So what
<code>continue</code> return? Why are we allowed to return a <code>u32</code> from one arm in Listing
19-33 and have another arm that ends with <code>continue</code>?</p>
<p>As you may have guessed, <code>continue</code> has a value of <code>!</code>. That is, when Rust goes
to compute the type of <code>guess</code>, it looks at both of the match arms. The former
has a value of <code>u32</code>, and the latter has a value of <code>!</code>. Since <code>!</code> can never
have a value, Rust is okay with this, and decides that the type of <code>guess</code> is
<code>u32</code>. The formal way of describing this behavior of <code>!</code> is that the never type
unifies with all other types. We're allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn't actually return a value; it instead moves
control back to the top of the loop, so in the <code>Err</code> case, we never actually
assign a value to <code>guess</code>.</p>
<p>Another use of the never type is <code>panic!</code>. Remember the <code>unwrap</code> function that
we call on <code>Option&lt;T&gt;</code> values to produce a value or panic? Here's its
definition:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>Here, the same thing happens as in the <code>match</code> in Listing 19-33: we know that
<code>val</code> has the type <code>T</code>, and <code>panic!</code> has the type <code>!</code>, so the result of the
overall <code>match</code> expression is <code>T</code>. This works because <code>panic!</code> doesn't produce
a value; it ends the program. In the <code>None</code> case, we won't be returning a value
from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Here, the loop never ends, so the value of the expression is <code>!</code>. This wouldn't
be true if we included a <code>break</code>, however, as the loop would terminate when it
gets to the <code>break</code>.</p>
<a class="header" href="ch19-04-advanced-types.html#dynamically-sized-types--sized" id="dynamically-sized-types--sized"><h3>Dynamically Sized Types &amp; <code>Sized</code></h3></a>
<p>Because Rust needs to know things like memory layout, there's a particular
corner of its type system that can be confusing, and that's the concept of
<em>dynamically sized types</em>. Sometimes referred to as 'DSTs' or 'unsized types',
these types let us talk about types whose size we can only know at runtime.</p>
<p>Let's dig into the details of a dynamically sized type that we've been using
this whole book: <code>str</code>. That's right, not <code>&amp;str</code>, but <code>str</code> on its own. <code>str</code>
is a DST; we can't know how long the string is until runtime. Since we can't
know that, we can't create a variable of type <code>str</code>, nor can we take an
argument of type <code>str</code>. Consider this code, which does not work:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>These two <code>str</code> values would need to have the exact same memory layout, but
they have different lengths: <code>s1</code> needs 12 bytes of storage, and <code>s2</code> needs 15.
This is why it's not possible to create a variable holding a dynamically sized
type.</p>
<p>So what to do? Well, you already know the answer in this case: the types of
<code>s1</code> and <code>s2</code> are <code>&amp;str</code> rather than <code>str</code>. If you think back to Chapter 4, we
said this about <code>&amp;str</code>:</p>
<blockquote>
<p>... itâ€™s a reference to an internal position in the String and the number of
elements that it refers to.</p>
</blockquote>
<p>So while a <code>&amp;T</code> is a single value that stores the memory address of where the
<code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and how long
it is. As such, a <code>&amp;str</code> has a size we can know at compile time: it's two times
the size of a <code>usize</code> in length. That is, we always know the size of a <code>&amp;str</code>,
no matter how long the string it refers to is. This is the general way in which
dynamically sized types are used in Rust; they have an extra bit of metadata
that stores the size of the dynamic information. This leads us to the golden
rule of dynamically sized types: we must always put values of dynamically sized
types behind a pointer of some kind.</p>
<!-- Note for Carol: `Rc<str>` is only in an accepted RFC right now, check on
its progress and pull this out if it's not going to be stable by Oct -->
<p>While we've talked a lot about <code>&amp;str</code>, we can combine <code>str</code> with all kinds of
pointers: <code>Box&lt;str&gt;</code>, for example, or <code>Rc&lt;str&gt;</code>. In fact, you've already seen
this before, but with a different dynamically sized type: traits. Every trait
is a dynamically sized type we can refer to by using the name of the trait. In
Chapter 17, we mentioned that in order to use traits as trait objects, we have
to put them behind a pointer like <code>&amp;Trait</code> or <code>Box&lt;Trait&gt;</code> (<code>Rc&lt;Trait&gt;</code> would
work too). Traits being dynamically sized is the reason we have to do that!</p>
<a class="header" href="ch19-04-advanced-types.html#the-sized-trait" id="the-sized-trait"><h4>The <code>Sized</code> Trait</h4></a>
<!-- If we end up keeping the section on object safety in ch 17, we should add
a back reference here. /Carol -->
<p>To work with DSTs, Rust has a trait that determines if a type's size is known
at compile time or not, which is <code>Sized</code>. This trait is automatically
implemented for everything the compiler knows the size of at compile time. In
addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function.
That is, a generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
</code></pre>
<p>is actually treated as if we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
</code></pre>
<p>By default, generic functions will only work on types that have a known size at
compile time. There is, however, special syntax you can use to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
</code></pre>
<p>A trait bound on <code>?Sized</code> is the opposite of a trait bound on <code>Sized</code>; that is,
we would read this as &quot;<code>T</code> may or may not be <code>Sized</code>&quot;. This syntax is only
available for <code>Sized</code>, no other traits.</p>
<p>Also note we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>: since the
type might not be <code>Sized</code>, we need to use it behind some kind of pointer. In
this case, we've chosen a reference.</p>
<p>Next let's talk about functions and closures!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch19-03-advanced-traits.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch19-03-advanced-traits.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
