<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advanced Lifetimes - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> Common Programming Concepts</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums and Pattern Matching</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> Modules</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> Controlling Visibility with <code>pub</code></a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> Common Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> Error Handling</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> Recoverable Errors with <code>Result</code></a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html" class="active"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final project: a web server</a></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <header><p style="background-color:#FF0000; padding: 5px;">You are reading a *draft* of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch19-02-advanced-lifetimes.html#advanced-lifetimes" id="advanced-lifetimes"><h2>Advanced Lifetimes</h2></a>
<p>Back in Chapter 10, we learned how to annotate references with lifetime
parameters to help Rust understand how the lifetimes of different references
relate. We saw how most of the time, Rust will let you elide lifetimes, but
every reference has a lifetime. There are three advanced features of lifetimes
that we haven't covered though: <em>lifetime subtyping</em>, <em>trait object lifetimes</em>,
and <em>higher ranked trait bounds</em>.</p>
<a class="header" href="ch19-02-advanced-lifetimes.html#lifetime-subtyping" id="lifetime-subtyping"><h3>Lifetime Subtyping</h3></a>
<p>Imagine that we want to write a parser. To do this, we'll have a structure that
holds a reference to the string that we're parsing, and we'll call that struct
<code>Context</code>. We'll write a parser that will parse this string and return success
or failure. The parser will need to borrow the context to do the parsing.
Implementing this would look like the code in Listing 19-12, which won't
compile because we've left off the lifetime annotations for now:</p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">Listing 19-12: Defining a <code>Context</code> struct that holds a
string slice, a <code>Parser</code> struct that holds a reference to a <code>Context</code> instance,
and a <code>parse</code> method that always returns an error referencing the string
slice</span></p>
<p>For simplicity's sake, our <code>parse</code> function returns a <code>Result&lt;(), &amp;str&gt;</code>. That
is, we don't do anything on success, and on failure we return the part of the
string slice that didn't parse correctly. A real implementation would have more
error information than that, and would actually return something created when
parsing succeeds, but we're leaving those parts of the implementation off since
they aren't relevant to the lifetimes part of this example. We're also defining
<code>parse</code> to always produce an error after the first byte. Note that this may
panic if the first byte is not on a valid character boundary; again, we're
simplifying the example in order to concentrate on the lifetimes involved.</p>
<p>So how do we fill in the lifetime parameters for the string slice in <code>Context</code>
and the reference to the <code>Context</code> in <code>Parser</code>? The most straightforward thing
to do is to use the same lifetime everywhere, as shown in Listing 19-13:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 19-13: Annotating all references in <code>Context</code> and
<code>Parser</code> with the same lifetime parameter</span></p>
<p>This compiles fine. Next, in Listing 19-14, let's write a function that takes
an instance of <code>Context</code>, uses a <code>Parser</code> to parse that context, and returns
what <code>parse</code> returns. This won't quite work:</p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-14: An attempt to add a <code>parse_context</code>
function that takes a <code>Context</code> and uses a <code>Parser</code></span></p>
<p>We get two quite verbose errors when we try to compile the code with the
addition of the <code>parse_context</code> function:</p>
<pre><code class="language-text">error: borrowed value does not live long enough
  --&gt; &lt;anon&gt;:16:5
   |
16 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
17 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --&gt; &lt;anon&gt;:15:56
   |
15 |   fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
   |  ________________________________________________________^ starting here...
16 | |     Parser { context: &amp;context }.parse()
17 | | }
   | |_^ ...ending here

error: `context` does not live long enough
  --&gt; &lt;anon&gt;:16:24
   |
16 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
17 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --&gt; &lt;anon&gt;:15:56
   |
15 |   fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
   |  ________________________________________________________^ starting here...
16 | |     Parser { context: &amp;context }.parse()
17 | | }
   | |_^ ...ending here
</code></pre>
<p>These errors are saying that both the <code>Parser</code> instance we're creating and the
<code>context</code> parameter live from the line that the <code>Parser</code> is created until the
end of the <code>parse_context</code> function, but they both need to live for the entire
lifetime of the function.</p>
<p>In other words, <code>Parser</code> and <code>context</code> need to <em>outlive</em> the entire function
and be valid before the function starts as well as after it ends in order for
all the references in this code to always be valid. Both the <code>Parser</code> we're
creating and the <code>context</code> parameter go out of scope at the end of the
function, though (since <code>parse_context</code> takes ownership of <code>context</code>).</p>
<p>Let's look at the definitions in Listing 19-13 again, especially the signature
of the <code>parse</code> method:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<p>Remember the elision rules? If we annotate the lifetimes of the references, the
signature would be:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>That is, the error part of the return value of <code>parse</code> has a lifetime that is
tied to the <code>Parser</code> instance's lifetime (that of <code>&amp;self</code> in the <code>parse</code> method
signature). That makes sense, as the returned string slice references the
string slice in the <code>Context</code> instance that the <code>Parser</code> holds, and we've
specified in the definition of the <code>Parser</code> struct that the lifetime of the
reference to <code>Context</code> that <code>Parser</code> holds and the lifetime of the string slice
that <code>Context</code> holds should be the same.</p>
<p>The problem is that the <code>parse_context</code> function returns the value returned
from <code>parse</code>, so the lifetime of the return value of <code>parse_context</code> is tied to
the lifetime of the <code>Parser</code> as well. But the <code>Parser</code> instance created in the
<code>parse_context</code> function won't live past the end of the function (it's
temporary), and the <code>context</code> will go out of scope at the end of the function
(<code>parse_context</code> takes ownership of it).</p>
<p>We're not allowed to return a reference to a value that goes out of scope at
the end of the function. Rust thinks that's what we're trying to do because we
annotated all the lifetimes with the same lifetime parameter. That told Rust
the lifetime of the string slice that <code>Context</code> holds is the same as that of
the lifetime of the reference to <code>Context</code> that <code>Parser</code> holds.</p>
<p>The <code>parse_context</code> function can't see that within the <code>parse</code> function, the
string slice returned will outlive both <code>Context</code> and <code>Parser</code>, and that the
reference <code>parse_context</code> returns refers to the string slice, not to <code>Context</code>
or <code>Parser</code>.</p>
<p>By knowing what the implementation of <code>parse</code> does, we know that the only
reason that the return value of <code>parse</code> is tied to the <code>Parser</code> is because it's
referencing the <code>Parser</code>'s <code>Context</code>, which is referencing the string slice, so
it's really the lifetime of the string slice that <code>parse_context</code> needs to care
about. We need a way to tell Rust that the string slice in <code>Context</code> and the
reference to the <code>Context</code> in <code>Parser</code> have different lifetimes and that the
return value of <code>parse_context</code> is tied to the lifetime of the string slice in
<code>Context</code>.</p>
<p>We could try only giving <code>Parser</code> and <code>Context</code> different lifetime parameters
as shown in Listing 19-15. We've chosen the lifetime parameter names <code>'s</code> and
<code>'c</code> here to be clearer about which lifetime goes with the string slice in
<code>Context</code> and which goes with the reference to <code>Context</code> in <code>Parser</code>. Note that
this won't completely fix the problem, but it's a start and we'll look at why
this isn't sufficient when we try to compile.</p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-15: Specifying different lifetime parameters
for the references to the string slice and to <code>Context</code></span></p>
<p>We've annotated the lifetimes of the references in all the same places that we
annotated them in Listing 19-13, but used different parameters depending on
whether the reference goes with the string slice or with <code>Context</code>. We've also
added an annotation to the string slice part of the return value of <code>parse</code> to
indicate that it goes with the lifetime of the string slice in <code>Context</code>.</p>
<p>Here's the error we get now:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/main.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:0
 --&gt; src/main.rs:3:1
  |
3 |   struct Parser&lt;'c, 's&gt; {
  |  _^ starting here...
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^ ...ending here
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:0
 --&gt; src/main.rs:3:1
  |
3 |   struct Parser&lt;'c, 's&gt; {
  |  _^ starting here...
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^ ...ending here
</code></pre>
<p>Rust doesn't know of any relationship between <code>'c</code> and <code>'s</code>. In order to be
valid, the referenced data in <code>Context</code> with lifetime <code>'s</code> needs to be
constrained to guarantee that it lives longer than the reference to <code>Context</code>
that has lifetime <code>'c</code>. If <code>'s</code> is not longer than <code>'c</code>, then the reference to
<code>Context</code> might not be valid.</p>
<p>Which gets us to the point of this section: Rust has a feature called <em>lifetime
subtyping</em>, which is a way to specify that one lifetime parameter lives at
least as long as another one. In the angle brackets where we declare lifetime
parameters, we can declare a lifetime <code>'a</code> as usual, and declare a lifetime
<code>'b</code> that lives at least as long as <code>'a</code> by declaring <code>'b</code> with the syntax <code>'b: 'a</code>.</p>
<p>In our definition of <code>Parser</code>, in order to say that <code>'s</code> (the lifetime of the
string slice) is guaranteed to live at least as long as <code>'c</code> (the lifetime of
the reference to <code>Context</code>), we change the lifetime declarations to look like
this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

#}</code></pre></pre>
<p>Now, the reference to <code>Context</code> in the <code>Parser</code> and the reference to the string
slice in the <code>Context</code> have different lifetimes, and we've ensured that the
lifetime of the string slice is longer than the reference to the <code>Context</code>.</p>
<p>That was a very long-winded example, but as we mentioned at the start of this
chapter, these features are pretty niche. You won't often need this syntax, but
it can come up in situations like this one, where you need to refer to
something you have a reference to.</p>
<a class="header" href="ch19-02-advanced-lifetimes.html#lifetime-bounds" id="lifetime-bounds"><h3>Lifetime Bounds</h3></a>
<p>In Chapter 10, we discussed how to use trait bounds on generic types. We can
also add lifetime parameters as constraints on generic types. For example,
let's say we wanted to make a wrapper over references. Remember <code>RefCell&lt;T&gt;</code>
from Chapter 15? This is how the <code>borrow</code> and <code>borrow_mut</code> methods work; they
return wrappers over references in order to keep track of the borrowing rules
at runtime. The struct definition, without lifetime parameters for now, would
look like Listing 19-16:</p>
<pre><code class="language-rust ignore">struct Ref&lt;T&gt;(&amp;T);
</code></pre>
<p><span class="caption">Listing 19-16: Defining a struct to wrap a reference to a
generic type; without lifetime parameters to start</span></p>
<p>However, using no lifetime bounds at all gives an error because Rust doesn't
know how long the generic type <code>T</code> will live:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; &lt;anon&gt;:2:19
  |
2 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; &lt;anon&gt;:2:19
  |
2 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>This is the same error that we'd get if we filled in <code>T</code> with a concrete type,
like <code>struct Ref(&amp;i32)</code>; all references in struct definitions need a lifetime
parameter. However, because we have a generic type parameter, we can't add a
lifetime parameter in the same way. Defining <code>Ref</code> as <code>struct Ref&lt;'a&gt;(&amp;'a T)</code>
will result in an error because Rust can't determine that <code>T</code> lives long
enough. Since <code>T</code> can be any type, <code>T</code> could itself be a reference or it could
be a type that holds one or more references, each of which have their own
lifetimes.</p>
<p>Rust helpfully gave us good advice on how to specify the lifetime parameter in
this case:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points to.
</code></pre>
<p>The code in Listing 19-17 works because <code>T: 'a</code> syntax specifies that <code>T</code> can
be any type, but if it contains any references, <code>T</code> must live as long as <code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);

#}</code></pre></pre>
<p><span class="caption">Listing 19-17: Adding lifetime bounds on <code>T</code> to specify
that any references in <code>T</code> live at least as long as <code>'a</code></span></p>
<p>We could choose to solve this in a different way as shown in Listing 19-18 by
bounding <code>T</code> on <code>'static</code>. This means if <code>T</code> contains any references, they must
have the <code>'static</code> lifetime:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);

#}</code></pre></pre>
<p><span class="caption">Listing 19-18: Adding a <code>'static</code> lifetime bound to <code>T</code>
to constrain <code>T</code> to types that have only <code>'static</code> references or no
references</span></p>
<p>Types with no references count as <code>T: 'static</code>. Because <code>'static</code> means the
reference must live as long as the entire program, a type that contains no
references meets the criteria of all references living as long as the entire
program (since there are no references). Think of it this way: if the borrow
checker is concerned about references living long enough, then there's no real
distinction between a type that has no references and a type that has
references that live forever; both of them are the same for the purpose of
determining whether or not a reference has a shorter lifetime than what it
refers to.</p>
<a class="header" href="ch19-02-advanced-lifetimes.html#lifetimes-in-trait-objects" id="lifetimes-in-trait-objects"><h3>Lifetimes in Trait Objects</h3></a>
<p>In Chapter 17, we learned about trait objects that consist of putting a trait
behind a reference in order to use dynamic dispatch. However, we didn't discuss
what happens if the type implementing the trait used in the trait object has a
lifetime. Consider Listing 19-19, where we have a trait <code>Foo</code> and a struct
<code>Bar</code> that holds a reference (and thus has a lifetime parameter) that
implements trait <code>Foo</code>, and we want to use an instance of <code>Bar</code> as the trait
object <code>Box&lt;Foo&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Foo { }

struct Bar&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo for Bar&lt;'a&gt; { }

let num = 5;

let obj = Box::new(Bar { x: &amp;num }) as Box&lt;Foo&gt;;

#}</code></pre></pre>
<p><span class="caption">Listing 19-19: Using a type that has a lifetime parameter
with a trait object</span></p>
<p>This code compiles without any errors, even though we haven't said anything
about the lifetimes involved in <code>obj</code>. This works because there are rules
having to do with lifetimes and trait objects:</p>
<ul>
<li>The default lifetime of a trait object is <code>'static</code>.</li>
<li>If we have <code>&amp;'a X</code> or <code>&amp;'a mut X</code>, then the default is <code>'a</code>.</li>
<li>If we have a single <code>T: 'a</code> clause, then the default is <code>'a</code>.</li>
<li>If we have multiple <code>T: 'a</code>-like clauses, then there is no default; we must
be explicit.</li>
</ul>
<p>When we must be explicit, we can add a lifetime bound on a trait object like
<code>Box&lt;Foo&gt;</code> with the syntax <code>Box&lt;Foo + 'a&gt;</code> or <code>Box&lt;Foo + 'static&gt;</code>, depending
on what's needed. Just as with the other bounds, this means that any
implementer of the <code>Foo</code> trait that has any references inside must have the
lifetime specified in the trait object bounds as those references.</p>
<p>Next, let's take a look at some other advanced features dealing with traits!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch19-01-unsafe-rust.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch19-01-unsafe-rust.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch19-03-advanced-traits.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
