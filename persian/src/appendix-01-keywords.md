<div dir="rtl">

## ضمیمه الف: کلمات کلیدی

لیست زیر شامل کلمات کلیدی است که برای استفاده فعلی یا آینده توسط زبان Rust رزرو شده‌اند. به همین دلیل، نمی‌توان از آن‌ها به عنوان شناسه استفاده کرد (مگر به عنوان شناسه خام، همان‌طور که در بخش “[شناسه‌های خام][raw-identifiers]” توضیح داده خواهد شد). شناسه‌ها نام‌هایی هستند که برای توابع، متغیرها، پارامترها، فیلدهای ساختار، ماژول‌ها، کرت‌ها، ثابت‌ها، ماکروها، مقادیر استاتیک، ویژگی‌ها، انواع، ویژگی‌ها، یا طول عمرها استفاده می‌شوند.

[raw-identifiers]: #raw-identifiers

### کلمات کلیدی در حال استفاده

لیست زیر شامل کلمات کلیدی در حال استفاده است، همراه با توضیح عملکرد آن‌ها:
<ul dir="rtl">
  <li>`as` - انجام تبدیل‌های اولیه، مشخص کردن ویژگی خاص شامل یک آیتم، یا تغییر نام آیتم‌ها در دستورات `use`</li>
  <li>`async` - بازگرداندن یک `Future` به جای مسدود کردن نخ جاری</li>
  <li>`await` - متوقف کردن اجرا تا زمانی که نتیجه یک `Future` آماده شود</li>
  <li>`break` - بلافاصله خروج از یک حلقه</li>
  <li>`const` - تعریف آیتم‌های ثابت یا اشاره‌گرهای خام ثابت</li>
  <li>`continue` - ادامه به تکرار بعدی حلقه</li>
  <li>`crate` - در یک مسیر ماژول، به ریشه کرت اشاره دارد</li>
  <li>`dyn` - ارسال پویا به یک شیء ویژگی</li>
  <li>`else` - حالت پیش‌فرض برای ساختارهای کنترلی `if` و `if let`</li>
  <li>`enum` - تعریف یک شمارش</li>
  <li>`extern` - لینک‌دهی به یک تابع یا متغیر خارجی</li>
  <li>`false` - مقدار بولی کاذب</li>
  <li>`fn` - تعریف یک تابع یا نوع اشاره‌گر تابع</li>
  <li>`for` - حلقه بر روی آیتم‌های یک iterator، پیاده‌سازی یک ویژگی، یا مشخص کردن یک طول عمر سطح بالاتر</li>
  <li>`if` - انشعاب بر اساس نتیجه یک عبارت شرطی</li>
  <li>`impl` - پیاده‌سازی عملکرد ذاتی یا ویژگی</li>
  <li>`in` - بخشی از سینتکس حلقه `for`</li>
  <li>`let` - بایند کردن یک متغیر</li>
  <li>`loop` - حلقه بدون قید و شرط</li>
  <li>`match` - مطابقت یک مقدار با الگوها</li>
  <li>`mod` - تعریف یک ماژول</li>
  <li>`move` - وادار کردن یک closure به تملک تمام مقادیر گرفته‌شده</li>
  <li>`mut` - نشان دادن تغییرپذیری در ارجاعات، اشاره‌گرهای خام، یا الگوهای بایندینگ</li>
  <li>`pub` - نشان دادن قابلیت دید عمومی در فیلدهای ساختار، بلوک‌های `impl`، یا ماژول‌ها</li>
  <li>`ref` - بایند کردن با ارجاع</li>
  <li>`return` - بازگشت از تابع</li>
  <li>`Self` - یک نوع مستعار برای نوعی که در حال تعریف یا پیاده‌سازی آن هستیم</li>
  <li>`self` - موضوع متد یا ماژول جاری</li>
  <li>`static` - متغیر جهانی یا طول عمر در کل اجرای برنامه</li>
  <li>`struct` - تعریف یک ساختار</li>
  <li>`super` - ماژول والد ماژول جاری</li>
  <li>`trait` - تعریف یک ویژگی</li>
  <li>`true` - مقدار بولی صحیح</li>
  <li>`type` - تعریف یک نوع مستعار یا نوع مرتبط</li>
  <li>`union` - تعریف یک [union][union]؛ فقط زمانی کلمه کلیدی است که در یک اعلان union استفاده شود</li>
  <li>`unsafe` - نشان دادن کد، توابع، ویژگی‌ها، یا پیاده‌سازی‌های ناامن</li>
  <li>`use` - وارد کردن نمادها به محدوده</li>
  <li>`where` - نشان دادن قیودی که یک نوع را محدود می‌کنند</li>
  <li>`while` - اجرای حلقه به صورت شرطی بر اساس نتیجه یک عبارت</li>
</ul>

[union]: ../reference/items/unions.html

### کلمات کلیدی رزرو شده برای استفاده در آینده

کلمات کلیدی زیر هنوز هیچ کاربردی ندارند اما توسط Rust برای استفاده احتمالی در آینده رزرو شده‌اند:

<ul dir="rtl">
  <li>`abstract`</li>
  <li>`become`</li>
  <li>`box`</li>
  <li>`do`</li>
  <li>`final`</li>
  <li>`macro`</li>
  <li>`override`</li>
  <li>`priv`</li>
  <li>`try`</li>
  <li>`typeof`</li>
  <li>`unsized`</li>
  <li>`virtual`</li>
  <li>`yield`</li>
</ul>


### شناسه‌های خام

_شناسه‌های خام_ سینتکسی هستند که به شما اجازه می‌دهند از کلمات کلیدی در جایی که معمولاً مجاز نیستند استفاده کنید. برای استفاده از یک شناسه خام، یک `r#` قبل از کلمه کلیدی اضافه کنید.

برای مثال، `match` یک کلمه کلیدی است. اگر بخواهید تابع زیر را که از `match` به عنوان نام خود استفاده می‌کند کامپایل کنید:

<span class="filename">نام فایل: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

شما این خطا را دریافت خواهید کرد:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

این خطا نشان می‌دهد که نمی‌توانید از کلمه کلیدی `match` به عنوان شناسه تابع استفاده کنید. برای استفاده از `match` به عنوان نام تابع، باید از سینتکس شناسه خام به این شکل استفاده کنید:

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

<span class="filename">نام فایل: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

این کد بدون هیچ خطایی کامپایل خواهد شد. به پیشوند `r#` روی نام تابع در تعریف آن و همچنین جایی که تابع در `main` فراخوانی می‌شود، توجه کنید.

شناسه‌های خام به شما اجازه می‌دهند از هر کلمه‌ای که انتخاب می‌کنید به عنوان یک شناسه استفاده کنید، حتی اگر آن کلمه به طور پیش‌فرض یک کلمه کلیدی رزرو شده باشد. این ویژگی آزادی بیشتری برای انتخاب نام شناسه‌ها به ما می‌دهد و همچنین امکان ادغام با برنامه‌هایی که به زبان‌هایی نوشته شده‌اند که این کلمات در آن‌ها کلمه کلیدی نیستند را فراهم می‌کند. علاوه بر این، شناسه‌های خام به شما اجازه می‌دهند از کتابخانه‌هایی استفاده کنید که با ویرایشی متفاوت از Rust نسبت به کرت شما نوشته شده‌اند. 

برای مثال، `try` در ویرایش ۲۰۱۵ یک کلمه کلیدی نیست اما در ویرایش ۲۰۱۸ یک کلمه کلیدی است. اگر به کتابخانه‌ای وابسته باشید که با ویرایش ۲۰۱۵ نوشته شده و دارای تابع `try` باشد، برای فراخوانی آن تابع از کد خود که با ویرایش ۲۰۱۸ نوشته شده است، باید از سینتکس شناسه خام، یعنی `r#try` در این مورد، استفاده کنید. برای اطلاعات بیشتر در مورد ویرایش‌ها، به [پیوست E][appendix-e] مراجعه کنید.

[appendix-e]: appendix-05-editions.html


</div>