<div dir="rtl">

## ذخیره متن‌های کدگذاری شده UTF-8 با رشته‌ها

ما در فصل ۴ درباره رشته‌ها صحبت کردیم، اما اکنون به آن‌ها با عمق بیشتری نگاه خواهیم کرد.
Rustaceanهای تازه‌وارد معمولاً به دلیل ترکیبی از سه عامل در رشته‌ها دچار مشکل می‌شوند:
گرایش Rust به آشکارسازی خطاهای ممکن، رشته‌ها به عنوان یک ساختار داده پیچیده‌تر از آنچه
بسیاری از برنامه‌نویسان تصور می‌کنند، و UTF-8. این عوامل به نحوی ترکیب می‌شوند که می‌توانند
برای کسانی که از زبان‌های برنامه‌نویسی دیگر می‌آیند دشوار باشند.

ما رشته‌ها را در زمینه مجموعه‌ها بررسی می‌کنیم، زیرا رشته‌ها به عنوان مجموعه‌ای از بایت‌ها
پیاده‌سازی شده‌اند، به علاوه تعدادی متد برای ارائه قابلیت‌های مفید زمانی که این بایت‌ها
به عنوان متن تفسیر می‌شوند. در این بخش، درباره عملیات‌هایی که روی `String` انجام می‌شود
و هر نوع مجموعه‌ای آن‌ها را دارد، مانند ایجاد، به‌روزرسانی، و خواندن صحبت خواهیم کرد.
همچنین تفاوت‌های `String` با سایر مجموعه‌ها را مورد بحث قرار می‌دهیم، به‌ویژه نحوه پیچیدگی
اندیس‌گذاری در یک `String` به دلیل تفاوت‌های بین تفسیر داده‌های `String` توسط انسان‌ها
و کامپیوترها.

### رشته چیست؟

ابتدا تعریف می‌کنیم که منظور ما از اصطلاح _رشته_ چیست. Rust فقط یک نوع رشته در زبان
هسته خود دارد که همان قطعه رشته `str` است که معمولاً به صورت قرض گرفته شده `&str`
دیده می‌شود. در فصل ۴ درباره _قطعه‌های رشته_ صحبت کردیم، که ارجاعاتی به داده‌های رشته‌ای
کدگذاری شده UTF-8 هستند که در جای دیگری ذخیره شده‌اند. به عنوان مثال، رشته‌های
لیترال در باینری برنامه ذخیره می‌شوند و بنابراین قطعه‌های رشته هستند.

نوع `String`، که توسط کتابخانه استاندارد Rust ارائه شده است و نه مستقیماً در زبان هسته
کدگذاری شده، یک نوع رشته رشدپذیر، قابل تغییر، و مالک UTF-8 است. وقتی Rustaceanها
به "رشته‌ها" در Rust اشاره می‌کنند، ممکن است به نوع `String` یا قطعه رشته `&str` اشاره
کنند، نه فقط یکی از این دو نوع. اگرچه این بخش عمدتاً درباره `String` است، اما هر دو نوع
در کتابخانه استاندارد Rust به شدت مورد استفاده قرار می‌گیرند و هر دو `String` و قطعه‌های
رشته کدگذاری UTF-8 دارند.

### ایجاد یک رشته جدید

بسیاری از عملیات مشابه موجود در `Vec<T>` برای `String` نیز در دسترس است، زیرا `String`
در واقع به عنوان یک پوششی بر روی یک بردار از بایت‌ها پیاده‌سازی شده است، با برخی
ضمانت‌ها، محدودیت‌ها، و قابلیت‌های اضافی. مثالی از یک تابع که به همان روش با
`Vec<T>` و `String` کار می‌کند، تابع `new` برای ایجاد یک نمونه است، همانطور که در لیست
۸-۱۱ نشان داده شده است.

<Listing number="8-11" caption="ایجاد یک `String` جدید و خالی">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

</Listing>

این خط یک رشته جدید و خالی به نام `s` ایجاد می‌کند که می‌توانیم داده‌ها را در آن بارگذاری کنیم.
اغلب، داده‌های اولیه‌ای خواهیم داشت که می‌خواهیم رشته را با آن‌ها شروع کنیم. برای این کار،
از متد `to_string` استفاده می‌کنیم که بر روی هر نوعی که ویژگی `Display` را پیاده‌سازی
می‌کند، همانند رشته‌های لیترال، در دسترس است. لیست ۸-۱۲ دو مثال را نشان می‌دهد.

<Listing number="8-12" caption="استفاده از متد `to_string` برای ایجاد یک `String` از یک رشته لیترال">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

</Listing>

این کد یک رشته حاوی `initial contents` ایجاد می‌کند.

ما همچنین می‌توانیم از تابع `String::from` برای ایجاد یک `String` از یک رشته لیترال
استفاده کنیم. کد در لیست ۸-۱۳ معادل کدی است که در لیست ۸-۱۲ از `to_string` استفاده می‌کند.

<Listing number="8-13" caption="استفاده از تابع `String::from` برای ایجاد یک `String` از یک رشته لیترال">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

</Listing>

از آنجا که رشته‌ها برای موارد بسیاری استفاده می‌شوند، می‌توانیم از بسیاری از APIهای
جنریک مختلف برای رشته‌ها استفاده کنیم که گزینه‌های زیادی را در اختیار ما قرار می‌دهند.
برخی از این‌ها ممکن است به نظر اضافی بیایند، اما هرکدام جایگاه خاص خود را دارند!
در این مورد، `String::from` و `to_string` عملکرد یکسانی دارند، بنابراین انتخاب بین آن‌ها
مسئله سبک و خوانایی کد است.

به یاد داشته باشید که رشته‌ها با کدگذاری UTF-8 هستند، بنابراین می‌توانیم هر داده‌ای که
به طور صحیح کدگذاری شده باشد را در آن‌ها قرار دهیم، همانطور که در لیست ۸-۱۴ نشان داده شده است.

<Listing number="8-14" caption="ذخیره سلام‌ها به زبان‌های مختلف در رشته‌ها">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

</Listing>

تمام این موارد مقادیر معتبر `String` هستند.

### به‌روزرسانی یک رشته

یک `String` می‌تواند از نظر اندازه رشد کند و محتوای آن تغییر کند، همانطور که محتوای
یک `Vec<T>` تغییر می‌کند، اگر داده بیشتری به آن اضافه کنیم. علاوه بر این، می‌توانیم به راحتی
از عملگر `+` یا ماکروی `format!` برای الحاق مقادیر `String` استفاده کنیم.

#### الحاق به یک رشته با `push_str` و `push`

ما می‌توانیم یک `String` را با استفاده از متد `push_str` برای الحاق یک قطعه رشته رشد دهیم،
همانطور که در لیست ۸-۱۵ نشان داده شده است.

<Listing number="8-15" caption="الحاق یک قطعه رشته به یک `String` با استفاده از متد `push_str`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

</Listing>

بعد از این دو خط، مقدار `s` شامل `foobar` خواهد بود. متد `push_str` یک قطعه رشته را به عنوان آرگومان می‌گیرد
زیرا ما لزوماً نمی‌خواهیم مالکیت پارامتر را بگیریم. برای مثال، در کدی که در لیست ۸-۱۶ نشان داده شده است،
ما می‌خواهیم بتوانیم پس از الحاق محتوای `s2` به `s1` همچنان از `s2` استفاده کنیم.

<Listing number="8-16" caption="استفاده از یک قطعه رشته پس از الحاق محتوای آن به یک `String`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

</Listing>

اگر متد `push_str` مالکیت `s2` را می‌گرفت، نمی‌توانستیم مقدار آن را در خط آخر چاپ کنیم. با این حال،
این کد همانطور که انتظار می‌رود کار می‌کند!

متد `push` یک کاراکتر را به عنوان پارامتر می‌گیرد و آن را به `String` اضافه می‌کند. لیست ۸-۱۷
حرف _l_ را با استفاده از متد `push` به یک `String` اضافه می‌کند.

<Listing number="8-17" caption="اضافه کردن یک کاراکتر به مقدار `String` با استفاده از `push`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

</Listing>

در نتیجه، مقدار `s` شامل `lol` خواهد بود.

#### الحاق با استفاده از عملگر `+` یا ماکروی `format!`

اغلب، ممکن است بخواهید دو رشته موجود را با هم ترکیب کنید. یکی از راه‌های انجام این کار
استفاده از عملگر `+` است، همانطور که در لیست ۸-۱۸ نشان داده شده است.

<Listing number="8-18" caption="استفاده از عملگر `+` برای ترکیب دو مقدار `String` در یک مقدار `String` جدید">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

</Listing>

مقدار `s3` شامل `Hello, world!` خواهد بود. دلیل اینکه `s1` پس از این الحاق دیگر معتبر نیست
و دلیل اینکه ما از یک مرجع به `s2` استفاده کردیم، به امضای متدی که هنگام استفاده از
عملگر `+` فراخوانی می‌شود مربوط است. عملگر `+` از متد `add` استفاده می‌کند که امضای آن به شکل زیر است:

```rust,ignore
fn add(self, s: &str) -> String {
```

در کتابخانه استاندارد، شما `add` را خواهید دید که با استفاده از جنریک‌ها و انواع مرتبط تعریف شده است.
اینجا، ما انواع مشخصی را جایگزین کرده‌ایم، که این همان چیزی است که هنگام فراخوانی این متد با مقادیر
`String` اتفاق می‌افتد. درباره جنریک‌ها در فصل ۱۰ صحبت خواهیم کرد. این امضا به ما سرنخ‌هایی می‌دهد
تا بتوانیم بخش‌های چالش‌برانگیز عملگر `+` را درک کنیم.

اول، `s2` یک `&` دارد، به این معنی که ما یک _مرجع_ از رشته دوم را به رشته اول اضافه می‌کنیم.
این به دلیل پارامتر `s` در تابع `add` است: ما فقط می‌توانیم یک `&str` را به یک `String` اضافه کنیم؛
نمی‌توانیم دو مقدار `String` را با هم جمع کنیم. اما صبر کنید—نوع `&s2`، `&String` است، نه `&str`
همانطور که در پارامتر دوم `add` مشخص شده است. پس چرا کد در لیست ۸-۱۸ کامپایل می‌شود؟

دلیل اینکه می‌توانیم از `&s2` در فراخوانی `add` استفاده کنیم این است که کامپایلر می‌تواند آرگومان
`&String` را به `&str` تبدیل کند. هنگامی که ما متد `add` را فراخوانی می‌کنیم، Rust از یک
_coercion deref_ استفاده می‌کند که در اینجا `&s2` را به `&s2[..]` تبدیل می‌کند. ما این موضوع
را در فصل ۱۵ به طور عمیق‌تری بررسی خواهیم کرد. از آنجا که `add` مالکیت پارامتر `s` را نمی‌گیرد،
`س2` پس از این عملیات همچنان یک `String` معتبر باقی خواهد ماند.

دوم، می‌توانیم در امضا ببینیم که `add` مالکیت `self` را می‌گیرد زیرا `self` یک `&` ندارد.
این بدان معناست که `s1` در لیست ۸-۱۸ به فراخوانی `add` منتقل می‌شود و پس از آن دیگر معتبر نخواهد بود.
بنابراین، اگرچه `let s3 = s1 + &s2;` به نظر می‌رسد که هر دو رشته را کپی می‌کند و یک رشته جدید ایجاد
می‌کند، این عبارت در واقع مالکیت `s1` را می‌گیرد، یک کپی از محتوای `s2` را اضافه می‌کند، و سپس مالکیت
نتیجه را بازمی‌گرداند. به عبارت دیگر، به نظر می‌رسد که کپی‌های زیادی انجام می‌دهد، اما اینطور نیست؛
پیاده‌سازی کارآمدتر از کپی کردن است.

اگر نیاز به الحاق چندین رشته داشته باشیم، رفتار عملگر `+` دست‌وپاگیر می‌شود:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

در این نقطه، مقدار `s` برابر با `tic-tac-toe` خواهد بود. با تمام این `+` و کاراکترهای `"`،
دیدن اینکه چه اتفاقی می‌افتد دشوار است. برای ترکیب رشته‌ها به روش‌های پیچیده‌تر، می‌توانیم
به جای آن از ماکروی `format!` استفاده کنیم:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

این کد نیز مقدار `s` را به `tic-tac-toe` تنظیم می‌کند. ماکروی `format!` شبیه به `println!` کار می‌کند،
اما به جای چاپ خروجی روی صفحه، یک `String` با محتوای مورد نظر بازمی‌گرداند. نسخه کد با استفاده از
`format!` بسیار خواناتر است و کدی که توسط ماکروی `format!` تولید می‌شود از مراجع استفاده می‌کند،
بنابراین این فراخوانی مالکیت هیچ‌یک از پارامترهایش را نمی‌گیرد.

### اندیس‌گذاری در رشته‌ها

در بسیاری از زبان‌های برنامه‌نویسی دیگر، دسترسی به کاراکترهای منفرد در یک رشته با اشاره به آن‌ها
توسط اندیس یک عملیات معتبر و رایج است. با این حال، اگر تلاش کنید در Rust با استفاده از سینتکس
اندیس‌گذاری به بخش‌هایی از یک `String` دسترسی پیدا کنید، با خطا مواجه می‌شوید. کد نامعتبر
در لیست ۸-۱۹ را در نظر بگیرید.

<Listing number="8-19" caption="تلاش برای استفاده از سینتکس اندیس‌گذاری با یک `String`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

</Listing>

این کد به خطای زیر منجر خواهد شد:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

خطا و توضیحات آن گویای موضوع است: رشته‌های Rust از اندیس‌گذاری پشتیبانی نمی‌کنند. اما چرا؟
برای پاسخ به این سؤال، باید درباره نحوه ذخیره‌سازی رشته‌ها در حافظه توسط Rust صحبت کنیم.

#### نمایش داخلی

یک `String` در واقع یک پوشش بر روی `Vec<u8>` است. بیایید به برخی از مثال‌های رشته‌های کدگذاری
شده UTF-8 در لیست ۸-۱۴ نگاه کنیم. ابتدا این مورد:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

در این حالت، مقدار `len` برابر با `4` خواهد بود، به این معنی که برداری که رشته `"Hola"` را
ذخیره می‌کند ۴ بایت طول دارد. هر یک از این حروف هنگام کدگذاری در UTF-8 یک بایت می‌گیرد.
با این حال، خط زیر ممکن است شما را شگفت‌زده کند (توجه داشته باشید که این رشته با حرف بزرگ
سیریلیک _Ze_ آغاز می‌شود، نه عدد ۳):

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

اگر از شما پرسیده شود طول این رشته چقدر است، ممکن است بگویید ۱۲. اما در واقع، پاسخ Rust
۲۴ است: این تعداد بایت‌هایی است که برای کدگذاری “Здравствуйте” در UTF-8 نیاز است، زیرا هر مقدار
اسکالر Unicode در این رشته ۲ بایت فضای ذخیره‌سازی می‌گیرد. بنابراین، یک اندیس در بایت‌های رشته
همیشه با یک مقدار اسکالر Unicode معتبر مطابقت ندارد. برای نشان دادن این موضوع، کد نامعتبر
زیر در Rust را در نظر بگیرید:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

شما قبلاً می‌دانید که مقدار `answer` برابر با `З`، اولین حرف، نخواهد بود. وقتی در UTF-8 کدگذاری
می‌شود، اولین بایت از `З` برابر با `208` و دومین بایت برابر با `151` است، بنابراین ممکن است به نظر
برسد که `answer` باید در واقع `208` باشد، اما `208` به تنهایی یک کاراکتر معتبر نیست. بازگرداندن
`208` احتمالاً چیزی نیست که یک کاربر بخواهد اگر درخواست اولین حرف این رشته را داشته باشد؛
با این حال، این تنها داده‌ای است که Rust در اندیس بایت ۰ دارد. کاربران به طور کلی نمی‌خواهند
مقدار بایت بازگردانده شود، حتی اگر رشته فقط حروف لاتین داشته باشد: اگر `&"hi"[0]` یک کد معتبر
بود که مقدار بایت را بازمی‌گرداند، مقدار `104` و نه `h` را بازمی‌گرداند.

پاسخ این است که برای جلوگیری از بازگرداندن یک مقدار غیرمنتظره و ایجاد باگ‌هایی که ممکن است فوراً
کشف نشوند، Rust این کد را اصلاً کامپایل نمی‌کند و از سوءتفاهم‌ها در اوایل فرآیند توسعه جلوگیری می‌کند.

#### بایت‌ها، مقادیر اسکالر و خوشه‌های گرافیمی! اوه خدای من!

نکته دیگری درباره UTF-8 این است که در واقع سه روش مرتبط برای مشاهده رشته‌ها از دیدگاه Rust وجود دارد:
به صورت بایت، مقادیر اسکالر، و خوشه‌های گرافیمی (نزدیک‌ترین چیز به چیزی که ما _حروف_ می‌نامیم).

اگر به کلمه هندی "नमस्ते" نوشته شده در اسکریپت Devanagari نگاه کنیم، این کلمه به صورت یک بردار
از مقادیر `u8` ذخیره می‌شود که به شکل زیر است:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

این ۱۸ بایت است و این همان چیزی است که کامپیوترها در نهایت این داده را ذخیره می‌کنند.
اگر به آن‌ها به عنوان مقادیر اسکالر Unicode نگاه کنیم، که همان نوع `char` در Rust است، این بایت‌ها
به این صورت به نظر می‌رسند:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

اینجا شش مقدار `char` وجود دارد، اما مقدار چهارم و ششم حروف نیستند: این‌ها دیاکریتیک‌هایی هستند که
به تنهایی معنایی ندارند. در نهایت، اگر به آن‌ها به عنوان خوشه‌های گرافیمی نگاه کنیم، همان چیزی
که یک فرد به عنوان حروف کلمه هندی تشخیص می‌دهد، اینطور خواهد بود:

```text
["न", "म", "स्", "ते"]
```

Rust روش‌های مختلفی برای تفسیر داده خام رشته ارائه می‌دهد که کامپیوترها ذخیره می‌کنند، بنابراین هر
برنامه می‌تواند تفسیری را که نیاز دارد انتخاب کند، صرف نظر از اینکه داده به چه زبان انسانی است.

یکی دیگر از دلایل اینکه Rust به ما اجازه نمی‌دهد در یک `String` اندیس‌گذاری کنیم تا یک کاراکتر را
دریافت کنیم این است که عملیات اندیس‌گذاری باید همیشه در زمان ثابت (O(1)) انجام شود. اما امکان
تضمین این عملکرد با یک `String` وجود ندارد، زیرا Rust باید محتویات را از ابتدا تا اندیس مرور کند تا
تعیین کند که چند کاراکتر معتبر وجود دارد.


### برش رشته‌ها

اندیس‌گذاری در یک رشته اغلب ایده خوبی نیست زیرا مشخص نیست که نوع بازگشتی عملیات اندیس‌گذاری
رشته چه باید باشد: یک مقدار بایت، یک کاراکتر، یک خوشه گرافیمی، یا یک قطعه رشته. بنابراین،
اگر واقعاً نیاز به استفاده از اندیس‌ها برای ایجاد قطعه‌های رشته دارید، Rust از شما می‌خواهد
بیشتر مشخص کنید.

به جای اندیس‌گذاری با استفاده از `[]` و یک عدد، می‌توانید از `[]` با یک بازه استفاده کنید
تا یک قطعه رشته که شامل بایت‌های خاصی است ایجاد کنید:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

اینجا، `s` یک `&str` خواهد بود که شامل چهار بایت اول رشته است. پیش‌تر اشاره کردیم که هر
یک از این کاراکترها دو بایت طول دارند، که به این معنی است که مقدار `s` برابر با `Зд` خواهد بود.

اگر سعی کنیم فقط بخشی از بایت‌های یک کاراکتر را با چیزی مثل `&hello[0..1]` برش دهیم،
Rust در زمان اجرا دچار خطا می‌شود، به همان شکلی که اگر یک اندیس نامعتبر در یک بردار
دسترسی داده شود:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

هنگام ایجاد قطعه‌های رشته با بازه‌ها باید احتیاط کنید، زیرا این کار ممکن است باعث خرابی
برنامه شما شود.

### متدهایی برای پیمایش در رشته‌ها

بهترین راه برای کار با بخش‌هایی از رشته‌ها این است که به وضوح مشخص کنید که آیا می‌خواهید
روی کاراکترها یا بایت‌ها کار کنید. برای مقادیر اسکالر Unicode منفرد، از متد `chars` استفاده کنید.
فراخوانی `chars` روی `"Зд"` دو مقدار از نوع `char` را جدا کرده و بازمی‌گرداند، و می‌توانید
با استفاده از نتیجه پیمایش کنید تا به هر عنصر دسترسی پیدا کنید:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

این کد خروجی زیر را چاپ خواهد کرد:

```text
З
д
```

به صورت جایگزین، متد `bytes` هر بایت خام را بازمی‌گرداند که ممکن است برای حوزه کاری شما مناسب باشد:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

این کد چهار بایتی که این رشته را تشکیل می‌دهند چاپ خواهد کرد:

```text
208
151
208
180
```

اما حتماً به یاد داشته باشید که مقادیر اسکالر Unicode معتبر ممکن است از بیش از یک بایت تشکیل شده باشند.

دریافت خوشه‌های گرافیمی از رشته‌ها، همانند اسکریپت Devanagari، پیچیده است، بنابراین این قابلیت
توسط کتابخانه استاندارد ارائه نمی‌شود. اگر به این قابلیت نیاز دارید، کرایت‌هایی در 
[crates.io](https://crates.io/)<!-- ignore --> موجود هستند.

### رشته‌ها اینقدر ساده نیستند

به طور خلاصه، رشته‌ها پیچیده هستند. زبان‌های برنامه‌نویسی مختلف انتخاب‌های متفاوتی درباره نحوه
نمایش این پیچیدگی به برنامه‌نویس می‌کنند. Rust انتخاب کرده است که مدیریت صحیح داده‌های
`String` رفتار پیش‌فرض برای تمام برنامه‌های Rust باشد، که به این معنی است که برنامه‌نویسان
باید در ابتدا بیشتر درباره مدیریت داده‌های UTF-8 فکر کنند. این معامله پیچیدگی بیشتری از رشته‌ها
را نسبت به سایر زبان‌های برنامه‌نویسی نشان می‌دهد، اما از مواجهه با خطاهای مربوط به کاراکترهای
غیر-ASCII در مراحل بعدی چرخه توسعه جلوگیری می‌کند.

خبر خوب این است که کتابخانه استاندارد عملکردهای زیادی را بر اساس انواع `String` و `&str`
برای کمک به مدیریت صحیح این شرایط پیچیده ارائه می‌دهد. حتماً مستندات را برای متدهای مفیدی مانند
`contains` برای جستجو در یک رشته و `replace` برای جایگزینی بخش‌هایی از یک رشته با رشته‌ای دیگر
بررسی کنید.

بیایید به چیزی کمی کمتر پیچیده برویم: هش مپ‌ها!

</div>