<div dir="rtl">

## توسعه قابلیت‌های کتابخانه با توسعه آزمون‌محور (TDD) یا همان (Test-Driven Development)

اکنون که منطق را به _src/lib.rs_ استخراج کرده‌ایم و جمع‌آوری آرگومان‌ها و مدیریت خطاها را در _src/main.rs_ باقی گذاشته‌ایم، نوشتن تست برای قابلیت‌های اصلی کد ما بسیار آسان‌تر شده است. می‌توانیم مستقیماً توابع را با آرگومان‌های مختلف فراخوانی کرده و مقادیر بازگشتی را بررسی کنیم، بدون اینکه نیاز باشد از باینری ما از خط فرمان استفاده کنیم.

در این بخش، منطق جستجو را با استفاده از فرآیند توسعه آزمون‌محور (TDD) به برنامه `minigrep` اضافه خواهیم کرد. مراحل این فرآیند به شرح زیر است:

<ol dir="rtl">
  <li>نوشتن یک تست که شکست می‌خورد و اجرای آن برای اطمینان از اینکه به دلیلی که انتظار داشتید شکست می‌خورد.</li>
  <li>نوشتن یا تغییر کد به اندازه‌ای که تست جدید پاس شود.</li>
  <li>بازسازی کدی که به تازگی اضافه یا تغییر داده شده و اطمینان از اینکه تست‌ها همچنان پاس می‌شوند.</li>
  <li>تکرار از مرحله ۱!</li>
</ol>

TDD تنها یکی از روش‌های نوشتن نرم‌افزار است، اما می‌تواند به طراحی بهتر کد کمک کند. نوشتن تست قبل از نوشتن کدی که تست را پاس می‌کند، کمک می‌کند تا پوشش تست بالا در طول فرآیند حفظ شود.

ما با استفاده از TDD پیاده‌سازی قابلیت جستجوی رشته کوئری در محتوای فایل و تولید لیستی از خطوط مطابق با کوئری را توسعه خواهیم داد. این قابلیت را در تابعی به نام `search` اضافه خواهیم کرد.

### نوشتن یک تست که شکست می‌خورد

از آنجا که دیگر به آن‌ها نیاز نداریم، بیایید عبارت‌های `println!` را از _src/lib.rs_ و _src/main.rs_ که برای بررسی رفتار برنامه استفاده می‌کردیم حذف کنیم. سپس، در _src/lib.rs_، یک ماژول `tests` با یک تابع تست اضافه خواهیم کرد، همانطور که در [فصل ۱۱][ch11-anatomy] انجام دادیم. تابع تست، رفتاری که می‌خواهیم تابع `search` داشته باشد را مشخص می‌کند: این تابع یک کوئری و متن برای جستجو دریافت می‌کند و تنها خطوطی از متن که شامل کوئری هستند را بازمی‌گرداند. لیست ۱۲-۱۵ این تست را نشان می‌دهد که هنوز کامپایل نخواهد شد.

<Listing number="12-15" file-name="src/lib.rs" caption="ایجاد یک تست شکست‌خورده برای تابع `search` که آرزو می‌کنیم داشته باشیم">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

</Listing>

این تست به دنبال رشته `"duct"` می‌گردد. متنی که در آن جستجو می‌کنیم شامل سه خط است که تنها یکی از آن‌ها شامل `"duct"` است (توجه داشته باشید که بک‌اسلش بعد از علامت نقل قول بازکننده به Rust می‌گوید که کاراکتر newline در ابتدای محتویات این literal رشته قرار ندهد). ما تأیید می‌کنیم که مقدار بازگردانده شده از تابع `search` تنها شامل خطی است که انتظار داریم.

هنوز قادر به اجرای این تست و مشاهده شکست آن نیستیم زیرا تست حتی کامپایل نمی‌شود: تابع `search` هنوز وجود ندارد! بر اساس اصول TDD، ما تنها به اندازه‌ای کد اضافه می‌کنیم که تست کامپایل و اجرا شود، با اضافه کردن یک تعریف از تابع `search` که همیشه یک بردار خالی بازمی‌گرداند، همانطور که در لیست ۱۲-۱۶ نشان داده شده است. سپس تست باید کامپایل و شکست بخورد زیرا یک بردار خالی با یک بردار شامل خط `"safe, fast, productive."` مطابقت ندارد.

<Listing number="12-16" file-name="src/lib.rs" caption="تعریف حداقل کد برای تابع `search` تا تست ما کامپایل شود">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

</Listing>


متوجه می‌شوید که ما نیاز داریم یک طول عمر صریح `'a` در امضای تابع `search` تعریف کنیم و از آن طول عمر با آرگومان `contents` و مقدار بازگشتی استفاده کنیم. به یاد داشته باشید که در [فصل ۱۰][ch10-lifetimes] توضیح دادیم که پارامترهای طول عمر مشخص می‌کنند کدام طول عمر آرگومان به طول عمر مقدار بازگشتی متصل است. در این مورد، ما مشخص می‌کنیم که بردار بازگشتی باید شامل برش‌های رشته‌ای باشد که به برش‌های آرگومان `contents` اشاره دارند (نه آرگومان `query`).

به عبارت دیگر، به Rust می‌گوییم داده‌ای که توسط تابع `search` بازگردانده می‌شود به اندازه داده‌ای که به تابع `search` در آرگومان `contents` منتقل می‌شود زنده خواهد بود. این مهم است! داده‌ای که توسط یک برش مرجع داده می‌شود باید معتبر باشد تا مرجع نیز معتبر باشد؛ اگر کامپایلر فرض کند که ما در حال ساختن برش‌های رشته‌ای از `query` هستیم به جای `contents`، بررسی‌های ایمنی را به اشتباه انجام خواهد داد.

اگر طول عمرها را فراموش کنیم و سعی کنیم این تابع را کامپایل کنیم، این خطا را دریافت خواهیم کرد:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

Rust به هیچ وجه نمی‌تواند بداند کدام یک از دو آرگومان مورد نیاز است، بنابراین ما باید به صورت صریح به آن بگوییم. از آنجایی که `contents` آرگومانی است که شامل تمام متن ما است و ما می‌خواهیم قسمت‌هایی از آن متن که مطابقت دارند را بازگردانیم، می‌دانیم که `contents` آرگومانی است که باید با استفاده از نحو طول عمر به مقدار بازگشتی متصل شود.

دیگر زبان‌های برنامه‌نویسی نیازی ندارند آرگومان‌ها را به مقادیر بازگشتی در امضا متصل کنید، اما این تمرین با گذشت زمان آسان‌تر می‌شود. ممکن است بخواهید این مثال را با مثال‌های موجود در بخش [“اعتبارسنجی مراجع با طول عمر”][validating-references-with-lifetimes] از فصل ۱۰ مقایسه کنید.

اکنون بیایید تست را اجرا کنیم:

```console
{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
```

عالی است، تست دقیقا همانطور که انتظار داشتیم شکست می‌خورد. بیایید تست را پاس کنیم!

### نوشتن کدی برای پاس کردن تست

در حال حاضر، تست ما به دلیل اینکه همیشه یک بردار خالی بازمی‌گرداند، شکست می‌خورد. برای رفع این مشکل و پیاده‌سازی `search`، برنامه ما باید این مراحل را دنبال کند:

<ol dir="rtl">
  <li>تکرار از طریق هر خط از محتوای فایل.</li>
  <li>بررسی اینکه آیا خط شامل رشته کوئری ما هست یا نه.</li>
  <li>اگر خط شامل کوئری بود، آن را به لیست مقادیر بازگشتی اضافه کنیم.</li>
  <li>اگر نبود، کاری انجام ندهیم.</li>
  <li>لیست نتایجی که مطابقت دارند را بازگردانیم.</li>
</ol>

بیایید هر مرحله را یکی‌یکی اجرا کنیم، با تکرار از طریق خطوط شروع می‌کنیم.

#### تکرار از طریق خطوط با متد `lines`

Rust یک متد مفید برای مدیریت تکرار خط به خط در رشته‌ها ارائه می‌دهد که به طور مناسبی `lines` نامیده شده است و همانطور که در لیست ۱۲-۱۷ نشان داده شده کار می‌کند. توجه داشته باشید که این کد هنوز کامپایل نخواهد شد.

<Listing number="12-17" file-name="src/lib.rs" caption="تکرار از طریق هر خط در `contents`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

</Listing>

متد `lines` یک iterator برمی‌گرداند. ما در [فصل ۱۳][ch13-iterators] عمیقاً در مورد iteratorها صحبت خواهیم کرد، اما به یاد داشته باشید که قبلاً این روش استفاده از یک iterator را در [لیست ۳-۵][ch3-iter] دیدید، جایی که از یک حلقه `for` با یک iterator برای اجرای کدی روی هر آیتم در یک مجموعه استفاده کردیم.

#### جستجو در هر خط برای کوئری

اکنون، بررسی خواهیم کرد که آیا خط فعلی شامل رشته کوئری ما هست یا نه. خوشبختانه، رشته‌ها یک متد مفید به نام `contains` دارند که این کار را برای ما انجام می‌دهد! یک فراخوانی به متد `contains` را در تابع `search` اضافه کنید، همانطور که در لیست ۱۲-۱۸ نشان داده شده است. توجه داشته باشید که این کد همچنان کامپایل نخواهد شد.

<Listing number="12-18" file-name="src/lib.rs" caption="اضافه کردن قابلیت بررسی اینکه آیا خط شامل رشته موجود در `query` هست یا نه">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

</Listing>

در حال حاضر، ما در حال ایجاد قابلیت‌های بیشتر هستیم. برای اینکه کد کامپایل شود، نیاز داریم مقداری را از بدنه تابع بازگردانیم همانطور که در امضای تابع اشاره کردیم.

#### ذخیره خطوط مطابق

برای تکمیل این تابع، نیاز داریم روشی برای ذخیره خطوط مطابق که می‌خواهیم بازگردانیم داشته باشیم. برای این کار، می‌توانیم یک بردار mutable قبل از حلقه `for` ایجاد کنیم و با استفاده از متد `push` یک خط را در بردار ذخیره کنیم. بعد از حلقه `for`، بردار را بازمی‌گردانیم، همانطور که در لیست ۱۲-۱۹ نشان داده شده است.

<Listing number="12-19" file-name="src/lib.rs" caption="ذخیره خطوط مطابق برای بازگرداندن آن‌ها">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

</Listing>

اکنون تابع `search` باید فقط خطوطی را که شامل `query` هستند بازگرداند، و تست ما باید پاس شود. بیایید تست را اجرا کنیم:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

تست ما پاس شد، بنابراین می‌دانیم که کار می‌کند!

در این مرحله، می‌توانیم فرصت‌هایی برای بازسازی پیاده‌سازی تابع جستجو در نظر بگیریم و در عین حال تست‌ها را پاس نگه داریم تا همان قابلیت را حفظ کنیم. کد در تابع جستجو چندان بد نیست، اما از برخی ویژگی‌های مفید iteratorها استفاده نمی‌کند. ما در [فصل ۱۳][ch13-iterators] به این مثال بازخواهیم گشت، جایی که iteratorها را با جزئیات بررسی می‌کنیم و به نحوه بهبود آن می‌پردازیم.

#### استفاده از تابع `search` در تابع `run`

اکنون که تابع `search` کار می‌کند و تست شده است، باید تابع `search` را از تابع `run` فراخوانی کنیم. ما باید مقدار `config.query` و `contents` که `run` از فایل می‌خواند را به تابع `search` بدهیم. سپس `run` هر خطی که از `search` برگردانده شده را چاپ خواهد کرد:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

ما هنوز از یک حلقه `for` برای بازگرداندن هر خط از `search` و چاپ آن استفاده می‌کنیم.

اکنون کل برنامه باید کار کند! بیایید آن را امتحان کنیم، ابتدا با کلمه‌ای که باید دقیقاً یک خط از شعر امیلی دیکینسون را برگرداند: _frog_.

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

عالی! حالا بیایید کلمه‌ای را امتحان کنیم که چندین خط را مطابقت دهد، مثل _body_:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

و در نهایت، مطمئن شویم که وقتی کلمه‌ای را جستجو می‌کنیم که در هیچ جای شعر وجود ندارد، مثل _monomorphization_، هیچ خطی دریافت نخواهیم کرد:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

عالی! ما نسخه کوچکی از یک ابزار کلاسیک ساختیم و چیزهای زیادی درباره نحوه ساختاردهی برنامه‌ها آموختیم. همچنین کمی درباره ورودی و خروجی فایل، طول عمر‌ها، تست کردن و تجزیه دستورات خط فرمان یاد گرفتیم.

برای تکمیل این پروژه، به طور مختصر نشان خواهیم داد که چگونه با متغیرهای محیطی کار کنیم و چگونه به خطای استاندارد (standard error) چاپ کنیم، که هر دو در هنگام نوشتن برنامه‌های خط فرمان مفید هستند.

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html

</div>