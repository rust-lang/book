<div dir="rtl">

## چگونه تست بنویسیم

تست‌ها توابعی در Rust هستند که بررسی می‌کنند کد غیرتستی به شکل مورد انتظار کار می‌کند. بدنه توابع تست معمولاً این سه عمل را انجام می‌دهد:

- تنظیم هر داده یا وضعیت مورد نیاز.
- اجرای کدی که می‌خواهید تست کنید.
- تأیید اینکه نتایج همان چیزی است که انتظار دارید.

بیایید به ویژگی‌هایی که Rust به طور خاص برای نوشتن تست‌هایی که این اقدامات را انجام می‌دهند فراهم کرده است نگاهی بیندازیم. این ویژگی‌ها شامل ویژگی `test`، چند ماکرو و ویژگی `should_panic` هستند.

### آناتومی یک تابع تست

در ساده‌ترین حالت، یک تست در Rust یک تابع است که با ویژگی `test` حاشیه‌نویسی شده است. ویژگی‌ها متاداده‌هایی درباره بخش‌های کد Rust هستند؛ یک مثال ویژگی `derive` است که در فصل ۵ با ساختارها استفاده کردیم. برای تغییر یک تابع به یک تابع تست، `#[test]` را به خط قبل از `fn` اضافه کنید. وقتی تست‌های خود را با فرمان `cargo test` اجرا می‌کنید، Rust یک باینری تست رانر ایجاد می‌کند که توابع حاشیه‌نویسی‌شده را اجرا می‌کند و گزارش می‌دهد که آیا هر تابع تست موفق یا ناموفق بوده است.

هر زمان که یک پروژه کتابخانه‌ای جدید با Cargo ایجاد می‌کنیم، یک ماژول تست با یک تابع تست در آن به صورت خودکار برای ما تولید می‌شود. این ماژول یک قالب برای نوشتن تست‌های شما فراهم می‌کند تا نیازی به جستجوی ساختار و نحو دقیق هر بار که یک پروژه جدید شروع می‌کنید نداشته باشید. می‌توانید هر تعداد تابع تست اضافی و هر تعداد ماژول تست اضافی که می‌خواهید اضافه کنید!

ما برخی از جنبه‌های نحوه عملکرد تست‌ها را با آزمایش قالب تست قبل از اینکه واقعاً کدی را تست کنیم بررسی خواهیم کرد. سپس تست‌هایی در دنیای واقعی می‌نویسیم که برخی کدهایی که نوشته‌ایم را فراخوانی می‌کنند و تأیید می‌کنند که رفتار آن صحیح است.

بیایید یک پروژه کتابخانه‌ای جدید به نام `adder` ایجاد کنیم که دو عدد را با هم جمع کند:

```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

محتویات فایل _src/lib.rs_ در کتابخانه `adder` شما باید شبیه به لیست ۱۱-۱ باشد.

<Listing number="11-1" file-name="src/lib.rs" caption="کدی که به طور خودکار توسط `cargo new` تولید می‌شود">

<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

</Listing>


این فایل با یک تابع نمونه به نام `add` شروع می‌شود تا چیزی برای تست کردن داشته باشیم.

فعلاً روی تابع `it_works` تمرکز می‌کنیم. به حاشیه‌نویسی `#[test]` توجه کنید: این ویژگی نشان می‌دهد که این یک تابع تست است، بنابراین تست رانر می‌داند که این تابع را به عنوان یک تست در نظر بگیرد. ممکن است توابع غیرتستی نیز در ماژول `tests` داشته باشیم که به تنظیم سناریوهای مشترک یا انجام عملیات‌های مشترک کمک می‌کنند، بنابراین همیشه باید مشخص کنیم کدام توابع تست هستند.

بدنه تابع نمونه از ماکرو `assert_eq!` استفاده می‌کند تا اطمینان حاصل کند که `result`، که حاوی نتیجه فراخوانی `add` با مقادیر ۲ و ۲ است، برابر با ۴ باشد. این اطمینان به عنوان یک مثال از فرمت یک تست معمولی عمل می‌کند. بیایید آن را اجرا کنیم تا ببینیم این تست پاس می‌شود.

فرمان `cargo test` تمام تست‌های پروژه ما را اجرا می‌کند، همانطور که در لیست ۱۱-۲ نشان داده شده است.

<Listing number="11-2" caption="خروجی اجرای تستی که به طور خودکار تولید شده است">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}
```

</Listing>

Cargo تست را کامپایل و اجرا کرد. خط `running 1 test` را می‌بینیم. خط بعدی نام تابع تست تولیدشده را نشان می‌دهد، که `tests::it_works` نام دارد، و نتیجه اجرای آن تست `ok` است. خلاصه کلی `test result: ok.` نشان می‌دهد که تمام تست‌ها پاس شده‌اند، و بخشی که `1 passed; 0 failed` را می‌خواند تعداد تست‌هایی که پاس شده‌اند یا ناموفق بوده‌اند را نشان می‌دهد.

این امکان وجود دارد که یک تست را به عنوان نادیده‌گرفته‌شده علامت‌گذاری کنیم تا در یک نمونه خاص اجرا نشود؛ ما این مورد را در بخش [“نادیده‌گرفتن برخی تست‌ها مگر اینکه صریحاً درخواست شوند”][ignoring]<!-- ignore --> در ادامه این فصل پوشش خواهیم داد. چون اینجا این کار را انجام نداده‌ایم، خلاصه `0 ignored` را نشان می‌دهد.

آمار `0 measured` برای تست‌های بنچمارک است که عملکرد را اندازه‌گیری می‌کنند. تست‌های بنچمارک، در زمان نوشتن این متن، فقط در نسخه شبانه Rust موجود هستند. برای اطلاعات بیشتر مستندات مربوط به [تست‌های بنچمارک][bench] را ببینید.

ما می‌توانیم یک آرگومان به فرمان `cargo test` بدهیم تا فقط تست‌هایی که نام آن‌ها با یک رشته مطابقت دارد اجرا شوند؛ این به _فیلتر کردن_ معروف است و ما آن را در بخش [“اجرای زیرمجموعه‌ای از تست‌ها با نام”][subset]<!-- ignore --> پوشش خواهیم داد. اینجا ما تست‌های در حال اجرا را فیلتر نکرده‌ایم، بنابراین پایان خلاصه `0 filtered out` را نشان می‌دهد.

قسمت بعدی خروجی تست که با `Doc-tests adder` شروع می‌شود، نتایج هر تست مستنداتی را نشان می‌دهد. هنوز هیچ تست مستنداتی نداریم، اما Rust می‌تواند هر نمونه کدی که در مستندات API ما ظاهر می‌شود را کامپایل کند. این ویژگی به همگام نگه داشتن مستندات و کد شما کمک می‌کند! ما نحوه نوشتن تست‌های مستنداتی را در بخش [“توضیحات مستندات به عنوان تست‌ها”][doc-comments]<!-- ignore --> از فصل ۱۴ بررسی خواهیم کرد. فعلاً خروجی `Doc-tests` را نادیده می‌گیریم.

بیایید تست را مطابق نیازهای خود شخصی‌سازی کنیم. ابتدا نام تابع `it_works` را به یک نام دیگر، مانند `exploration` تغییر دهید، به این صورت:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}
```

سپس دوباره `cargo test` را اجرا کنید. خروجی اکنون به جای `it_works` نام `exploration` را نشان می‌دهد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}
```

حالا یک تست دیگر اضافه می‌کنیم، اما این بار تستی می‌نویسیم که شکست بخورد! تست‌ها زمانی شکست می‌خورند که چیزی در تابع تست باعث ایجاد panic شود. هر تست در یک نخ (thread) جدید اجرا می‌شود، و وقتی نخ اصلی می‌بیند که یک نخ تست متوقف شده است، تست به عنوان شکست‌خورده علامت‌گذاری می‌شود. در فصل ۹، درباره اینکه ساده‌ترین راه برای panic کردن فراخوانی ماکروی `panic!` است صحبت کردیم. تابع جدیدی به نام `another` وارد کنید تا فایل _src/lib.rs_ شما شبیه به لیست ۱۱-۳ شود.

<Listing number="11-3" file-name="src/lib.rs" caption="اضافه کردن یک تست دوم که به دلیل فراخوانی ماکروی `panic!` شکست می‌خورد">

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs}}
```

</Listing>

دوباره تست‌ها را با استفاده از `cargo test` اجرا کنید. خروجی باید شبیه به لیست ۱۱-۴ باشد، که نشان می‌دهد تست `exploration` موفق شده است و `another` شکست خورده است.

<Listing number="11-4" caption="نتایج تست زمانی که یک تست موفق می‌شود و یک تست شکست می‌خورد">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}
```

</Listing>

به جای `ok`، خط `test tests::another` نشان می‌دهد `FAILED`. دو بخش جدید بین نتایج فردی و خلاصه ظاهر می‌شود: بخش اول دلیل دقیق شکست هر تست را نشان می‌دهد. در این مورد، ما جزئیات را دریافت می‌کنیم که `another` به دلیل `panicked at 'Make this test fail'` در خط ۱۷ فایل _src/lib.rs_ شکست خورده است. بخش بعدی فقط نام تمام تست‌های شکست‌خورده را لیست می‌کند، که وقتی تعداد زیادی تست و خروجی‌های شکست‌خورده زیاد هستند مفید است. ما می‌توانیم نام یک تست شکست‌خورده را برای اجرای فقط همان تست استفاده کنیم تا راحت‌تر آن را اشکال‌زدایی کنیم؛ ما در بخش [“کنترل نحوه اجرای تست‌ها”][controlling-how-tests-are-run]<!-- ignore --> بیشتر در مورد روش‌های اجرای تست‌ها صحبت خواهیم کرد.

خط خلاصه در انتها نمایش داده می‌شود: به طور کلی، نتیجه تست ما `FAILED` است. یک تست موفق شد و یک تست شکست خورد.

حالا که دیدید نتایج تست در سناریوهای مختلف چگونه به نظر می‌رسند، بیایید به برخی از ماکروهای دیگر به جز `panic!` که در تست‌ها مفید هستند نگاهی بیندازیم.

### بررسی نتایج با ماکروی `assert!`

ماکروی `assert!` که توسط کتابخانه استاندارد ارائه شده است، زمانی مفید است که بخواهید اطمینان حاصل کنید که یک شرط در یک تست به `true` ارزیابی می‌شود. ماکروی `assert!` یک آرگومان می‌گیرد که به یک مقدار بولی ارزیابی می‌شود. اگر مقدار `true` باشد، هیچ اتفاقی نمی‌افتد و تست پاس می‌شود. اگر مقدار `false` باشد، ماکروی `assert!` فراخوانی `panic!` را انجام می‌دهد تا باعث شکست تست شود. استفاده از ماکروی `assert!` به ما کمک می‌کند تا بررسی کنیم که کد ما همانطور که قصد داریم عمل می‌کند.

در فصل ۵، لیست ۵-۱۵، از یک ساختار `Rectangle` و یک متد `can_hold` استفاده کردیم، که در لیست ۱۱-۵ دوباره تکرار شده است. این کد را در فایل _src/lib.rs_ قرار دهید، سپس با استفاده از ماکروی `assert!` چند تست برای آن بنویسید.

<Listing number="11-5" file-name="src/lib.rs" caption="ساختار `Rectangle` و متد `can_hold` آن از فصل ۵">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs}}
```

</Listing>

متد `can_hold` یک مقدار بولی بازمی‌گرداند، که به این معنی است که یک مورد استفاده عالی برای ماکروی `assert!` است. در لیست ۱۱-۶، ما تستی می‌نویسیم که متد `can_hold` را با ایجاد یک نمونه از `Rectangle` که عرض ۸ و ارتفاع ۷ دارد آزمایش می‌کند و تأیید می‌کند که می‌تواند نمونه دیگری از `Rectangle` که عرض ۵ و ارتفاع ۱ دارد را در خود جای دهد.

<Listing number="11-6" file-name="src/lib.rs" caption="تستی برای `can_hold` که بررسی می‌کند آیا یک مستطیل بزرگ‌تر می‌تواند واقعاً یک مستطیل کوچک‌تر را در خود جای دهد">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}
```

</Listing>

به خط `use super::*;` در داخل ماژول `tests` توجه کنید. ماژول `tests` یک ماژول معمولی است که از قوانین دیدپذیری معمولی که در فصل ۷ در بخش [“مسیرها برای اشاره به یک مورد در درخت ماژول”][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore --> پوشش دادیم پیروی می‌کند. از آنجا که ماژول `tests` یک ماژول داخلی است، باید کدی که در ماژول خارجی است را به دامنه ماژول داخلی بیاوریم. در اینجا از یک glob استفاده می‌کنیم، بنابراین هر چیزی که در ماژول خارجی تعریف کنیم برای این ماژول `tests` در دسترس است.

تست خود را `larger_can_hold_smaller` نام‌گذاری کرده‌ایم، و دو نمونه `Rectangle` که نیاز داشتیم را ایجاد کرده‌ایم. سپس ماکروی `assert!` را فراخوانی کردیم و نتیجه فراخوانی `larger.can_hold(&smaller)` را به آن پاس دادیم. این عبارت قرار است `true` بازگرداند، بنابراین تست ما باید پاس شود. بیایید ببینیم چه اتفاقی می‌افتد!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}
```

پاس شد! حالا یک تست دیگر اضافه کنیم، این بار تأیید می‌کنیم که یک مستطیل کوچک‌تر نمی‌تواند یک مستطیل بزرگ‌تر را در خود جای دهد:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}
```

از آنجا که نتیجه صحیح تابع `can_hold` در این مورد `false` است، باید آن نتیجه را قبل از پاس دادن به ماکروی `assert!` منفی کنیم. به این ترتیب، تست ما زمانی پاس می‌شود که `can_hold` مقدار `false` را بازگرداند:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}
```

دو تست که پاس می‌شوند! حالا بیایید ببینیم وقتی باگی به کد خود وارد می‌کنیم چه اتفاقی برای نتایج تست ما می‌افتد. پیاده‌سازی متد `can_hold` را با جایگزینی علامت بزرگتر (`>`) با علامت کوچکتر (`<`) هنگام مقایسه عرض‌ها تغییر می‌دهیم:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}
```

اجرای تست‌ها اکنون خروجی زیر را تولید می‌کند:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}
```

تست‌های ما باگ را پیدا کردند! از آنجا که `larger.width` مقدار `8` و `smaller.width` مقدار `5` دارد، مقایسه عرض‌ها در `can_hold` اکنون `false` بازمی‌گرداند: ۸ کمتر از ۵ نیست.

### تست برابری با ماکروهای `assert_eq!` و `assert_ne!`

یک روش معمول برای بررسی عملکرد، تست برابری بین نتیجه کد تحت تست و مقدار مورد انتظار است. می‌توانید این کار را با استفاده از ماکروی `assert!` و پاس دادن یک عبارت با استفاده از عملگر `==` انجام دهید. با این حال، این یک تست بسیار معمول است که کتابخانه استاندارد یک جفت ماکرو—`assert_eq!` و `assert_ne!`—برای انجام این تست به صورت راحت‌تر فراهم کرده است. این ماکروها به ترتیب دو آرگومان را برای برابری یا نابرابری مقایسه می‌کنند. اگر ادعا شکست بخورد، این ماکروها دو مقدار را نیز چاپ می‌کنند، که مشاهده دلیل شکست تست را آسان‌تر می‌کند. در مقابل، ماکروی `assert!` فقط نشان می‌دهد که یک مقدار `false` برای عبارت `==` دریافت کرده است، بدون چاپ مقادیری که منجر به مقدار `false` شده‌اند.

در لیست ۱۱-۷، تابعی به نام `add_two` می‌نویسیم که `۲` را به پارامتر خود اضافه می‌کند، سپس این تابع را با استفاده از ماکروی `assert_eq!` تست می‌کنیم.

<Listing number="11-7" file-name="src/lib.rs" caption="تست تابع `add_two` با استفاده از ماکروی `assert_eq!`">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}
```

</Listing>

بیایید بررسی کنیم که آیا پاس می‌شود!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}
```

یک متغیر به نام `result` ایجاد می‌کنیم که نتیجه فراخوانی `add_two(2)` را نگه می‌دارد. سپس `result` و `4` را به عنوان آرگومان‌ها به `assert_eq!` پاس می‌دهیم. خط خروجی برای این تست `test tests::it_adds_two ... ok` است، و متن `ok` نشان می‌دهد که تست ما پاس شده است!

بیایید یک باگ به کد خود وارد کنیم تا ببینیم ماکروی `assert_eq!` وقتی شکست می‌خورد چگونه به نظر می‌رسد. پیاده‌سازی تابع `add_two` را تغییر می‌دهیم تا به جای `۲` مقدار `۳` را اضافه کند:


```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}
```

تست‌ها را دوباره اجرا کنید:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}
```

تست ما باگ را پیدا کرد! تست `it_adds_two` شکست خورد، و پیام به ما می‌گوید ``assertion `left == right` failed`` و مقادیر `left` و `right` چیستند. این پیام به ما کمک می‌کند اشکال‌زدایی را شروع کنیم: آرگومان `left`، جایی که نتیجه فراخوانی `add_two(2)` را داشتیم، مقدار `5` بود، اما آرگومان `right` مقدار `4` بود. می‌توانید تصور کنید که این موضوع وقتی تعداد زیادی تست داشته باشیم بسیار مفید خواهد بود.

توجه داشته باشید که در برخی زبان‌ها و چارچوب‌های تست، پارامترهای توابع بررسی برابری `expected` و `actual` نامیده می‌شوند و ترتیب مشخص کردن آرگومان‌ها مهم است. اما در Rust، آن‌ها `left` و `right` نامیده می‌شوند، و ترتیب مشخص کردن مقداری که انتظار داریم و مقداری که کد تولید می‌کند مهم نیست. می‌توانیم ادعا را در این تست به صورت `assert_eq!(4, result)` بنویسیم، که همان پیام شکست را که `` assertion failed: `(left == right)` `` نمایش می‌دهد، تولید می‌کند.

ماکروی `assert_ne!` زمانی پاس می‌شود که دو مقداری که به آن می‌دهیم برابر نباشند و شکست می‌خورد اگر برابر باشند. این ماکرو برای مواردی مفید است که مطمئن نیستیم یک مقدار _چه خواهد بود_، اما می‌دانیم که مقدار به طور قطع _چه نباید باشد_. برای مثال، اگر تابعی را تست می‌کنیم که تضمین شده است ورودی خود را به نوعی تغییر دهد، اما نحوه تغییر ورودی به روز هفته‌ای که تست‌های خود را اجرا می‌کنیم بستگی دارد، بهترین چیزی که می‌توانیم تأیید کنیم این است که خروجی تابع برابر با ورودی نیست.

در پس‌زمینه، ماکروهای `assert_eq!` و `assert_ne!` به ترتیب از عملگرهای `==` و `!=` استفاده می‌کنند. وقتی ادعا شکست می‌خورد، این ماکروها آرگومان‌های خود را با استفاده از قالب‌بندی دیباگ چاپ می‌کنند، که به این معنی است که مقادیر مقایسه‌شده باید ویژگی‌های `PartialEq` و `Debug` را پیاده‌سازی کنند. تمام نوع‌های اولیه و بیشتر نوع‌های کتابخانه استاندارد این ویژگی‌ها را پیاده‌سازی می‌کنند. برای ساختارها و انوم‌هایی که خودتان تعریف می‌کنید، باید `PartialEq` را برای تأیید برابری این نوع‌ها پیاده‌سازی کنید. همچنین باید `Debug` را برای چاپ مقادیر زمانی که ادعا شکست می‌خورد پیاده‌سازی کنید. از آنجا که هر دو ویژگی قابل اشتقاق هستند، همانطور که در لیست ۵-۱۲ فصل ۵ اشاره شد، این معمولاً به سادگی افزودن حاشیه‌نویسی `#[derive(PartialEq, Debug)]` به تعریف ساختار یا انوم شما است. برای جزئیات بیشتر در مورد این ویژگی‌ها و سایر ویژگی‌های قابل اشتقاق، به پیوست C، [“ویژگی‌های قابل اشتقاق”][derivable-traits]<!-- ignore --> مراجعه کنید.

### افزودن پیام‌های شکست سفارشی

همچنین می‌توانید یک پیام سفارشی برای چاپ همراه با پیام شکست به عنوان آرگومان‌های اختیاری به ماکروهای `assert!`، `assert_eq!` و `assert_ne!` اضافه کنید. هر آرگومانی که بعد از آرگومان‌های اجباری مشخص شده باشد به ماکروی `format!` (که در فصل ۸ در بخش [“ادغام با عملگر `+` یا ماکروی `format!`”][concatenation-with-the--operator-or-the-format-macro]<!-- ignore --> بحث شد) پاس داده می‌شود، بنابراین می‌توانید یک رشته قالب که شامل نگهدارنده‌های `{}` است و مقادیری که در آن نگهدارنده‌ها قرار می‌گیرند را پاس دهید. پیام‌های سفارشی برای مستندسازی معنای یک ادعا مفید هستند؛ وقتی یک تست شکست می‌خورد، ایده بهتری از مشکل کد خواهید داشت.

برای مثال، فرض کنید تابعی داریم که افراد را با نامشان خوشامد می‌گوید و می‌خواهیم تست کنیم که نامی که به تابع پاس می‌دهیم در خروجی ظاهر می‌شود:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}
```

نیازمندی‌های این برنامه هنوز مورد توافق قرار نگرفته‌اند، و ما تقریباً مطمئن هستیم که متن `Hello` در ابتدای پیام خوشامد تغییر خواهد کرد. تصمیم گرفتیم که نمی‌خواهیم وقتی نیازمندی‌ها تغییر می‌کنند، تست را به‌روزرسانی کنیم، بنابراین به جای بررسی برابری دقیق با مقدار بازگشتی از تابع `greeting`، فقط تأیید می‌کنیم که خروجی شامل متن پارامتر ورودی است.

حالا بیایید یک باگ به این کد وارد کنیم با تغییر `greeting` به‌طوری که `name` را شامل نشود تا ببینیم پیام شکست تست پیش‌فرض چگونه است:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}
```

اجرای این تست خروجی زیر را تولید می‌کند:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}
```

این نتیجه فقط نشان می‌دهد که ادعا شکست خورده است و خطی که ادعا در آن قرار دارد کدام است. یک پیام شکست مفیدتر مقدار بازگشتی از تابع `greeting` را چاپ می‌کرد. بیایید یک پیام شکست سفارشی اضافه کنیم که از یک رشته قالب با یک نگهدارنده که با مقدار واقعی بازگشتی از تابع `greeting` پر شده است، تشکیل شده باشد:

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}
```

حالا وقتی تست را اجرا می‌کنیم، یک پیام خطای اطلاع‌رسان‌تر دریافت خواهیم کرد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}
```

ما می‌توانیم مقدار واقعی‌ای که در خروجی تست دریافت کردیم را ببینیم، که به ما کمک می‌کند تا اشکال‌زدایی کنیم که چه اتفاقی افتاد به جای آنچه که انتظار داشتیم اتفاق بیفتد.

### بررسی پانیک با `should_panic`

علاوه بر بررسی مقادیر بازگشتی، مهم است که بررسی کنیم کد ما شرایط خطا را همانطور که انتظار داریم مدیریت می‌کند. برای مثال، نوع `Guess` را که در فصل ۹، لیست ۹-۱۳ ایجاد کردیم در نظر بگیرید. سایر کدهایی که از `Guess` استفاده می‌کنند به این تضمین وابسته هستند که نمونه‌های `Guess` فقط مقادیر بین ۱ و ۱۰۰ را شامل می‌شوند. می‌توانیم تستی بنویسیم که اطمینان حاصل کند که تلاش برای ایجاد یک نمونه `Guess` با مقداری خارج از این بازه منجر به پانیک می‌شود.

این کار را با افزودن ویژگی `should_panic` به تابع تست خود انجام می‌دهیم. اگر کد داخل تابع پانیک کند، تست پاس می‌شود؛ اگر کد داخل تابع پانیک نکند، تست شکست می‌خورد.

لیست ۱۱-۸ یک تست را نشان می‌دهد که بررسی می‌کند شرایط خطای `Guess::new` زمانی که انتظار داریم رخ می‌دهند.

<Listing number="11-8" file-name="src/lib.rs" caption="تست کردن اینکه آیا یک شرط باعث یک `panic!` می‌شود">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}
```

</Listing>

ما ویژگی `#[should_panic]` را بعد از ویژگی `#[test]` و قبل از تابع تستی که به آن اعمال می‌شود قرار می‌دهیم. بیایید به نتیجه‌ای که وقتی این تست پاس می‌شود نگاه کنیم:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}
```

به نظر خوب می‌آید! حالا بیایید یک باگ در کد خود وارد کنیم با حذف شرطی که تابع `new` را مجبور می‌کند اگر مقدار بیشتر از ۱۰۰ باشد پانیک کند:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}
```

وقتی تست در لیست ۱۱-۸ را اجرا می‌کنیم، شکست می‌خورد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}
```

در این مورد پیام خیلی مفیدی دریافت نمی‌کنیم، اما وقتی به تابع تست نگاه می‌کنیم، می‌بینیم که با `#[should_panic]` حاشیه‌نویسی شده است. شکست به این معناست که کدی که در تابع تست قرار دارد باعث یک پانیک نشده است.

تست‌هایی که از `should_panic` استفاده می‌کنند می‌توانند دقیق نباشند. یک تست `should_panic` حتی اگر تست برای دلیلی غیر از آنچه انتظار داشتیم پانیک کند، پاس می‌شود. برای دقیق‌تر کردن تست‌های `should_panic`، می‌توانیم یک پارامتر اختیاری `expected` به ویژگی `should_panic` اضافه کنیم. تست رانر اطمینان حاصل می‌کند که پیام شکست شامل متن ارائه‌شده است. برای مثال، کد تغییر داده‌شده برای `Guess` در لیست ۱۱-۹ را در نظر بگیرید که تابع `new` با پیام‌های مختلف بسته به اینکه مقدار خیلی کوچک یا خیلی بزرگ باشد پانیک می‌کند.

<Listing number="11-9" file-name="src/lib.rs" caption="تست کردن یک `panic!` با یک پیام پانیک که حاوی یک زیررشته مشخص است">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}
```

</Listing>

این تست پاس می‌شود زیرا مقداری که در پارامتر `expected` ویژگی `should_panic` قرار داده‌ایم یک زیررشته از پیامی است که تابع `Guess::new` با آن پانیک می‌کند. می‌توانستیم کل پیام پانیکی که انتظار داریم را مشخص کنیم، که در این مورد می‌شد `Guess value must be less than or equal to 100, got 200`. آنچه انتخاب می‌کنید بستگی به این دارد که چه مقدار از پیام پانیک منحصر به فرد یا پویا است و چقدر می‌خواهید تست شما دقیق باشد. در این مورد، یک زیررشته از پیام پانیک کافی است تا اطمینان حاصل شود که کد در تابع تست مورد `else if value > 100` را اجرا می‌کند.

برای دیدن اینکه وقتی یک تست `should_panic` با یک پیام `expected` شکست می‌خورد چه اتفاقی می‌افتد، بیایید دوباره یک باگ به کد خود وارد کنیم با جابه‌جا کردن بدنه‌های بلوک‌های `if value < 1` و `else if value > 100`:

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}
```

این بار وقتی تست `should_panic` را اجرا می‌کنیم، شکست خواهد خورد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}
```

پیام شکست نشان می‌دهد که این تست همانطور که انتظار داشتیم پانیک کرد، اما پیام پانیک شامل رشته مورد انتظار `less than or equal to 100` نبود. پیام پانیکی که در این مورد دریافت کردیم `Guess value must be greater than or equal to 1, got 200.` بود. حالا می‌توانیم شروع به پیدا کردن محل باگ کنیم!

### استفاده از `Result<T, E>` در تست‌ها

تست‌های ما تا اینجا همه زمانی که شکست می‌خورند پانیک می‌کنند. همچنین می‌توانیم تست‌هایی بنویسیم که از `Result<T, E>` استفاده کنند! در اینجا تست لیست ۱۱-۱ را بازنویسی کرده‌ایم تا از `Result<T, E>` استفاده کند و به جای پانیک کردن، یک `Err` بازگرداند:

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs:here}}
```

تابع `it_works` اکنون نوع بازگشتی `Result<(), String>` دارد. در بدنه تابع، به جای فراخوانی ماکروی `assert_eq!`، وقتی تست پاس می‌شود `Ok(())` و وقتی تست شکست می‌خورد یک `Err` با یک `String` داخل آن بازمی‌گردانیم.

نوشتن تست‌هایی که یک `Result<T, E>` بازمی‌گردانند به شما اجازه می‌دهد از عملگر سوالی `?` در بدنه تست‌ها استفاده کنید، که می‌تواند راهی راحت برای نوشتن تست‌هایی باشد که اگر هر عملیاتی در آن‌ها یک واریانت `Err` بازگرداند، شکست بخورند.

شما نمی‌توانید از حاشیه‌نویسی `#[should_panic]` در تست‌هایی که از `Result<T, E>` استفاده می‌کنند استفاده کنید. برای تأیید اینکه یک عملیات یک واریانت `Err` بازمی‌گرداند، _از_ عملگر سوالی روی مقدار `Result<T, E>` استفاده نکنید. در عوض، از `assert!(value.is_err())` استفاده کنید.

حالا که چندین روش برای نوشتن تست‌ها را یاد گرفتید، بیایید نگاهی به آنچه هنگام اجرای تست‌ها اتفاق می‌افتد بیندازیم و گزینه‌های مختلفی را که می‌توانیم با `cargo test` استفاده کنیم بررسی کنیم.

[concatenation-with-the--operator-or-the-format-macro]: ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro  
[bench]: ../unstable-book/library-features/test.html  
[ignoring]: ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested  
[subset]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name  
[controlling-how-tests-are-run]: ch11-02-running-tests.html#controlling-how-tests-are-run  
[derivable-traits]: appendix-03-derivable-traits.html  
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests  
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html

</div>