## تشغيل الكود عند التنظيف باستخدام سِمة `Drop`

السِمة الثانية المهمة لنمط المؤشر الذكي هي `Drop`، والتي تتيح لك تخصيص ما يحدث عندما تكون القيمة على وشك الخروج من النطاق. يمكنك توفير تنفيذ لسِمة `Drop` على أي نوع، ويمكن استخدام هذا الكود لتحرير موارد مثل الملفات أو اتصالات الشبكة.

نقدم `Drop` في سياق المؤشرات الذكية لأن وظيفة سِمة `Drop` تُستخدم دائمًا تقريبًا عند تنفيذ مؤشر ذكي. على سبيل المثال، عندما يتم إسقاط `Box<T>`، سيتم إلغاء تخصيص المساحة على الكومة التي يشير إليها الصندوق.

في بعض اللغات، لبعض الأنواع، يجب على المبرمج استدعاء كود لتحرير الذاكرة أو الموارد في كل مرة ينتهون فيها من استخدام نسخة من تلك الأنواع. تشمل الأمثلة معالجات الملفات (file handles) والمآخذ (sockets) والأقفال (locks). إذا نسي المبرمج، قد يصبح النظام محملاً بشكل زائد وقد ينهار. في Rust، يمكنك تحديد أن يتم تشغيل جزء معين من الكود كلما خرجت قيمة عن النطاق، وسيُدرج المصرِّف هذا الكود تلقائيًا. نتيجة لذلك، لا تحتاج إلى أن تكون حذرًا بشأن وضع كود التنظيف في كل مكان في البرنامج حيث تنتهي نسخة من نوع معين—ولن تسرّب الموارد!

تحدد الكود الذي سيتم تشغيله عندما تخرج قيمة عن النطاق عن طريق تنفيذ سِمة `Drop`. تتطلب سِمة `Drop` منك تنفيذ وسيلة واحدة باسم `drop` تأخذ مرجعًا قابلًا للتغيير إلى `self`. لمعرفة متى تستدعي Rust `drop`، دعنا ننفذ `drop` مع عبارات `println!` الآن.

توضح القائمة 15-14 struct `CustomSmartPointer` الذي وظيفته المخصصة الوحيدة هي أنه سيطبع `Dropping CustomSmartPointer!` عندما تخرج النسخة عن النطاق، لإظهار متى تشغل Rust وسيلة `drop`.

<Listing number="15-14" file-name="src/main.rs" caption="struct `CustomSmartPointer` ينفذ سِمة `Drop` حيث سنضع كود التنظيف الخاص بنا">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-14/src/main.rs}}
```

</Listing>

سِمة `Drop` مضمنة في الـ prelude، لذلك لا نحتاج إلى إدخالها إلى النطاق. ننفذ سِمة `Drop` على `CustomSmartPointer` ونوفر تنفيذًا لوسيلة `drop` التي تستدعي `println!`. جسم وسيلة `drop` هو المكان الذي ستضع فيه أي منطق تريد تشغيله عندما تخرج نسخة من نوعك عن النطاق. نطبع بعض النص هنا لتوضيح متى ستستدعي Rust `drop` بصريًا.

في `main`، ننشئ نسختين من `CustomSmartPointer` ثم نطبع `CustomSmartPointers created`. في نهاية `main`، ستخرج نسخ `CustomSmartPointer` الخاصة بنا عن النطاق، وستستدعي Rust الكود الذي وضعناه في وسيلة `drop`، لتطبع رسالتنا النهائية. لاحظ أننا لم نكن بحاجة إلى استدعاء وسيلة `drop` بشكل صريح.

عندما نشغل هذا البرنامج، سنرى المخرجات التالية:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-14/output.txt}}
```

استدعت Rust تلقائيًا `drop` لنا عندما خرجت نسخنا عن النطاق، مستدعية الكود الذي حددناه. يتم إسقاط المتغيرات بترتيب عكسي لإنشائها، لذلك تم إسقاط `d` قبل `c`. الغرض من هذا المثال هو إعطاؤك دليلاً مرئيًا لكيفية عمل وسيلة `drop`؛ عادةً ستحدد كود التنظيف الذي يحتاجه نوعك لتشغيله بدلاً من رسالة الطباعة.

<!-- Old headings. Do not remove or links may break. -->

<a id="dropping-a-value-early-with-std-mem-drop"></a>

للأسف، ليس من المباشر تعطيل وظيفة `drop` التلقائية. تعطيل `drop` عادةً ليس ضروريًا؛ النقطة الكاملة من سِمة `Drop` هي أنها تُعالج تلقائيًا. ومع ذلك، في بعض الأحيان، قد ترغب في تنظيف قيمة مبكرًا. مثال واحد هو عند استخدام مؤشرات ذكية تدير الأقفال: قد ترغب في إجبار وسيلة `drop` التي تحرر القفل حتى يتمكن الكود الآخر في نفس النطاق من الحصول على القفل. لا تتيح لك Rust استدعاء وسيلة `drop` الخاصة بسِمة `Drop` يدويًا؛ بدلاً من ذلك، يجب عليك استدعاء دالة `std::mem::drop` المقدمة من المكتبة القياسية إذا كنت تريد إجبار قيمة على الإسقاط قبل نهاية نطاقها.

محاولة استدعاء وسيلة `drop` الخاصة بسِمة `Drop` يدويًا عن طريق تعديل دالة `main` من القائمة 15-14 لن تعمل، كما هو موضح في القائمة 15-15.

<Listing number="15-15" file-name="src/main.rs" caption="محاولة استدعاء وسيلة `drop` من سِمة `Drop` يدويًا للتنظيف مبكرًا">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-15/src/main.rs:here}}
```

</Listing>

عندما نحاول ترجمة هذا الكود، سنحصل على هذا الخطأ:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-15/output.txt}}
```

تنص رسالة الخطأ هذه على أنه غير مسموح لنا استدعاء `drop` بشكل صريح. تستخدم رسالة الخطأ المصطلح _destructor_، وهو المصطلح العام للبرمجة لدالة تنظف نسخة. _المدمّر_ (destructor) مماثل لـ _المنشئ_ (constructor)، الذي ينشئ نسخة. دالة `drop` في Rust هي مدمّر معين.

لا تتيح لنا Rust استدعاء `drop` بشكل صريح، لأن Rust ستستدعي `drop` على القيمة تلقائيًا في نهاية `main`. سيتسبب هذا في خطأ _تحرير مزدوج_ (double free) لأن Rust ستحاول تنظيف نفس القيمة مرتين.

لا يمكننا تعطيل الإدراج التلقائي لـ `drop` عندما تخرج قيمة عن النطاق، ولا يمكننا استدعاء وسيلة `drop` بشكل صريح. لذلك، إذا كنا بحاجة لإجبار قيمة على التنظيف مبكرًا، نستخدم دالة `std::mem::drop`.

دالة `std::mem::drop` مختلفة عن وسيلة `drop` في سِمة `Drop`. نستدعيها عن طريق تمرير القيمة التي نريد إسقاطها بالقوة كمعامل. الدالة موجودة في الـ prelude، لذلك يمكننا تعديل `main` في القائمة 15-15 لاستدعاء دالة `drop`، كما هو موضح في القائمة 15-16.

<Listing number="15-16" file-name="src/main.rs" caption="استدعاء `std::mem::drop` لإسقاط قيمة بشكل صريح قبل أن تخرج عن النطاق">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-16/src/main.rs:here}}
```

</Listing>

سيطبع تشغيل هذا الكود ما يلي:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-16/output.txt}}
```

يُطبع النص ``Dropping CustomSmartPointer with data `some data`!`` بين النص `CustomSmartPointer created` والنص `CustomSmartPointer dropped before the end of main`، مما يوضح أن كود وسيلة `drop` يُستدعى لإسقاط `c` في تلك النقطة.

يمكنك استخدام الكود المحدد في تنفيذ سِمة `Drop` بطرق عديدة لجعل التنظيف مريحًا وآمنًا: على سبيل المثال، يمكنك استخدامه لإنشاء مخصص الذاكرة الخاص بك! مع سِمة `Drop` ونظام الملكية في Rust، لا يتعين عليك تذكر التنظيف، لأن Rust تفعل ذلك تلقائيًا.

كما أنك لا تحتاج للقلق بشأن المشاكل الناتجة عن تنظيف القيم عن طريق الخطأ والتي لا تزال قيد الاستخدام: نظام الملكية الذي يتأكد من أن المراجع دائمًا صالحة يضمن أيضًا أن `drop` يُستدعى مرة واحدة فقط عندما لا تعد القيمة قيد الاستخدام.

الآن بعد أن فحصنا `Box<T>` وبعض خصائص المؤشرات الذكية، دعنا ننظر في بعض المؤشرات الذكية الأخرى المعرّفة في المكتبة القياسية.
