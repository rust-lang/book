<!-- Old headings. Do not remove or links may break. -->

<a id="using-trait-objects-that-allow-for-values-of-different-types"></a>

## استخدام كائنات السِمة للتجريد على السلوك المشترك

في الفصل 8، ذكرنا أن أحد قيود المتجهات (vectors) هو أنها يمكن أن تخزن عناصر من نوع واحد فقط. أنشأنا حلاً بديلاً في القائمة 8-9 حيث عرّفنا تعداد `SpreadsheetCell` الذي كان لديه متغيرات لحمل الأعداد الصحيحة والعشرية والنصوص. هذا يعني أنه يمكننا تخزين أنواع مختلفة من البيانات في كل خلية ولا يزال لدينا متجه يمثل صفًا من الخلايا. هذا حل جيد تمامًا عندما تكون عناصرنا القابلة للتبديل مجموعة ثابتة من الأنواع التي نعرفها عندما يتم تصريف كودنا.

ومع ذلك، في بعض الأحيان نريد أن يتمكن مستخدم مكتبتنا من توسيع مجموعة الأنواع الصالحة في موقف معين. لإظهار كيف يمكننا تحقيق ذلك، سنقوم بإنشاء مثال لأداة واجهة مستخدم رسومية (GUI) تتكرر عبر قائمة من العناصر، وتستدعي دالة `draw` على كل واحدة لرسمها على الشاشة—وهي تقنية شائعة لأدوات GUI. سنقوم بإنشاء صندوق مكتبة يسمى `gui` يحتوي على بنية مكتبة GUI. قد يتضمن هذا الصندوق بعض الأنواع لاستخدامها من قبل الناس، مثل `Button` أو `TextField`. بالإضافة إلى ذلك، سيرغب مستخدمو `gui` في إنشاء أنواعهم الخاصة التي يمكن رسمها: على سبيل المثال، قد يضيف أحد المبرمجين `Image`، وقد يضيف آخر `SelectBox`.

في وقت كتابة المكتبة، لا يمكننا معرفة وتعريف جميع الأنواع التي قد يرغب المبرمجون الآخرون في إنشائها. لكننا نعلم أن `gui` يحتاج إلى تتبع العديد من القيم من أنواع مختلفة، ويحتاج إلى استدعاء دالة `draw` على كل من هذه القيم المختلفة الأنواع. لا يحتاج إلى معرفة بالضبط ما سيحدث عندما نستدعي دالة `draw`، فقط أن القيمة ستكون لديها تلك الدالة متاحة لنا لنستدعيها.

للقيام بذلك في لغة تحتوي على وراثة، قد نعرّف فئة باسم `Component` لها دالة باسم `draw` عليها. الفئات الأخرى، مثل `Button` و`Image` و`SelectBox`، سترث من `Component` وبالتالي ترث دالة `draw`. يمكن لكل منها تجاوز دالة `draw` لتعريف سلوكها المخصص، لكن الإطار يمكن أن يتعامل مع جميع الأنواع كما لو كانت نسخًا من `Component` ويستدعي `draw` عليها. لكن نظرًا لأن Rust لا تحتوي على وراثة، نحتاج إلى طريقة أخرى لهيكلة مكتبة `gui` للسماح للمستخدمين بإنشاء أنواع جديدة متوافقة مع المكتبة.

### تعريف سِمة للسلوك المشترك

لتنفيذ السلوك الذي نريد أن يكون لـ `gui`، سنعرّف سِمة (trait) باسم `Draw` سيكون لها دالة واحدة باسم `draw`. بعد ذلك، يمكننا تعريف متجه يأخذ كائن سِمة (trait object). _كائن السِمة_ (trait object) يشير إلى كل من نسخة من نوع يُنفذ السِمة المحددة وجدول يُستخدم للبحث عن دوال السِمة على هذا النوع في وقت التشغيل. نقوم بإنشاء كائن سِمة من خلال تحديد نوع من المؤشر، مثل مرجع أو مؤشر ذكي `Box<T>`، ثم الكلمة المفتاحية `dyn`، ثم تحديد السِمة ذات الصلة. (سنتحدث عن سبب وجوب استخدام كائنات السِمة لمؤشر في ["أنواع الحجم الديناميكي وسِمة `Sized`"][dynamically-sized]<!-- ignore --> في الفصل 20.) يمكننا استخدام كائنات السِمة بدلاً من نوع عمومي أو نوع محدد. أينما نستخدم كائن سِمة، سيضمن نظام الأنواع في Rust في وقت التصريف أن أي قيمة تُستخدم في هذا السياق ستُنفذ سِمة كائن السِمة. وبالتالي، لا نحتاج إلى معرفة جميع الأنواع المحتملة في وقت التصريف.

ذكرنا أنه في Rust، نمتنع عن تسمية البُنى والتعدادات "كائنات" لتمييزها عن كائنات اللغات الأخرى. في بنية أو تعداد، البيانات في حقول البنية والسلوك في كتل `impl` منفصلان، بينما في اللغات الأخرى، البيانات والسلوك المجمعان في مفهوم واحد غالبًا ما يُسمى كائنًا. كائنات السِمة تختلف عن الكائنات في اللغات الأخرى في أننا لا يمكننا إضافة بيانات إلى كائن سِمة. كائنات السِمة ليست مفيدة بشكل عام مثل الكائنات في اللغات الأخرى: غرضها المحدد هو السماح بالتجريد عبر السلوك المشترك.

القائمة 18-3 توضح كيفية تعريف سِمة باسم `Draw` مع دالة واحدة باسم `draw`.

<Listing number="18-3" file-name="src/lib.rs" caption="تعريف السِمة `Draw`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-03/src/lib.rs}}
```

</Listing>

يجب أن يبدو هذا الصياغة مألوفًا من مناقشاتنا حول كيفية تعريف السِمات في الفصل 10. بعد ذلك يأتي بعض الصياغة الجديدة: القائمة 18-4 تعرّف بنية باسم `Screen` تحتوي على متجه باسم `components`. هذا المتجه من النوع `Box<dyn Draw>`، وهو كائن سِمة؛ إنه بديل لأي نوع داخل `Box` يُنفذ السِمة `Draw`.

<Listing number="18-4" file-name="src/lib.rs" caption="تعريف بنية `Screen` مع حقل `components` يحتوي على متجه من كائنات السِمة التي تُنفذ السِمة `Draw`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-04/src/lib.rs:here}}
```

</Listing>

على بنية `Screen`، سنعرّف دالة باسم `run` ستستدعي دالة `draw` على كل من مكوناتها `components`، كما هو موضح في القائمة 18-5.

<Listing number="18-5" file-name="src/lib.rs" caption="دالة `run` على `Screen` تستدعي دالة `draw` على كل مكون">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-05/src/lib.rs:here}}
```

</Listing>

هذا يعمل بشكل مختلف عن تعريف بنية تستخدم معامل نوع عمومي مع قيود سِمة. يمكن استبدال معامل نوع عمومي بنوع محدد واحد فقط في المرة الواحدة، بينما تسمح كائنات السِمة بملء أنواع محددة متعددة لكائن السِمة في وقت التشغيل. على سبيل المثال، كان بإمكاننا تعريف بنية `Screen` باستخدام نوع عمومي وقيد سِمة، كما في القائمة 18-6.

<Listing number="18-6" file-name="src/lib.rs" caption="تنفيذ بديل لبنية `Screen` ودالتها `run` باستخدام الأنواع العمومية وقيود السِمات">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-06/src/lib.rs:here}}
```

</Listing>

هذا يقيدنا بنسخة `Screen` لها قائمة مكونات كلها من نوع `Button` أو كلها من نوع `TextField`. إذا كان لديك دائمًا مجموعات متجانسة فقط، فإن استخدام الأنواع العمومية وقيود السِمات هو الأفضل لأن التعريفات ستكون أحادية الشكل (monomorphized) في وقت التصريف لاستخدام الأنواع المحددة.

من ناحية أخرى، مع الدالة التي تستخدم كائنات السِمة، يمكن لنسخة واحدة من `Screen` أن تحتوي على `Vec<T>` يحتوي على `Box<Button>` بالإضافة إلى `Box<TextField>`. دعونا ننظر إلى كيفية عمل هذا، ثم سنتحدث عن تأثيرات الأداء في وقت التشغيل.

### تنفيذ السِمة

الآن سنضيف بعض الأنواع التي تُنفذ السِمة `Draw`. سنوفر نوع `Button`. مرة أخرى، تنفيذ مكتبة GUI فعلاً يتجاوز نطاق هذا الكتاب، لذا لن تحتوي دالة `draw` على أي تنفيذ مفيد في جسمها. لتخيل كيف قد يبدو التنفيذ، قد تحتوي بنية `Button` على حقول لـ `width` و`height` و`label`، كما هو موضح في القائمة 18-7.

<Listing number="18-7" file-name="src/lib.rs" caption="بنية `Button` التي تُنفذ السِمة `Draw`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-07/src/lib.rs:here}}
```

</Listing>

حقول `width` و`height` و`label` على `Button` ستختلف عن الحقول على المكونات الأخرى؛ على سبيل المثال، قد يحتوي نوع `TextField` على نفس هذه الحقول بالإضافة إلى حقل `placeholder`. سيُنفذ كل من الأنواع التي نريد رسمها على الشاشة السِمة `Draw` لكن سيستخدم كودًا مختلفًا في دالة `draw` لتعريف كيفية رسم هذا النوع المعين، كما يحتوي `Button` هنا (دون كود GUI الفعلي، كما ذكرنا). قد يكون لنوع `Button`، على سبيل المثال، كتلة `impl` إضافية تحتوي على دوال تتعلق بما يحدث عندما ينقر مستخدم على الزر. هذه الأنواع من الدوال لن تنطبق على أنواع مثل `TextField`.

إذا قرر شخص يستخدم مكتبتنا تنفيذ بنية `SelectBox` تحتوي على حقول `width` و`height` و`options`، فسينفذون السِمة `Draw` على نوع `SelectBox` أيضًا، كما هو موضح في القائمة 18-8.

<Listing number="18-8" file-name="src/main.rs" caption="صندوق آخر يستخدم `gui` ويُنفذ السِمة `Draw` على بنية `SelectBox`">

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-18-08/src/main.rs:here}}
```

</Listing>

يمكن لمستخدم مكتبتنا الآن كتابة دالة `main` الخاصة بهم لإنشاء نسخة `Screen`. إلى نسخة `Screen`، يمكنهم إضافة `SelectBox` و`Button` بوضع كل منهما في `Box<T>` ليصبح كائن سِمة. يمكنهم بعد ذلك استدعاء دالة `run` على نسخة `Screen`، والتي ستستدعي `draw` على كل من المكونات. القائمة 18-9 توضح هذا التنفيذ.

<Listing number="18-9" file-name="src/main.rs" caption="استخدام كائنات السِمة لتخزين قيم من أنواع مختلفة تُنفذ نفس السِمة">

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-18-09/src/main.rs:here}}
```

</Listing>

عندما كتبنا المكتبة، لم نكن نعلم أن شخصًا ما قد يضيف نوع `SelectBox`، لكن تنفيذ `Screen` الخاص بنا كان قادرًا على العمل على النوع الجديد ورسمه لأن `SelectBox` يُنفذ السِمة `Draw`، مما يعني أنه يُنفذ دالة `draw`.

هذا المفهوم—من الاهتمام فقط بالرسائل التي تستجيب لها القيمة بدلاً من النوع المحدد للقيمة—يشبه مفهوم _كتابة البط_ (duck typing) في اللغات ذات الكتابة الديناميكية: إذا كان يمشي مثل البطة ويصدر أصواتًا مثل البطة، فهو بطة! في تنفيذ `run` على `Screen` في القائمة 18-5، لا تحتاج `run` إلى معرفة ما هو النوع المحدد لكل مكون. لا تتحقق مما إذا كان المكون نسخة من `Button` أو `SelectBox`، بل تستدعي فقط دالة `draw` على المكون. من خلال تحديد `Box<dyn Draw>` كنوع القيم في متجه `components`، عرّفنا `Screen` لتحتاج إلى قيم يمكننا استدعاء دالة `draw` عليها.

ميزة استخدام كائنات السِمة ونظام الأنواع في Rust لكتابة كود مشابه للكود الذي يستخدم كتابة البط هي أننا لن نضطر أبدًا إلى التحقق مما إذا كانت القيمة تُنفذ دالة معينة في وقت التشغيل أو القلق بشأن الحصول على أخطاء إذا كانت القيمة لا تُنفذ دالة لكننا نستدعيها على أي حال. لن يُصرّف Rust كودنا إذا كانت القيم لا تُنفذ السِمات التي تحتاجها كائنات السِمة.

على سبيل المثال، القائمة 18-10 توضح ما يحدث إذا حاولنا إنشاء `Screen` بـ `String` كمكون.

<Listing number="18-10" file-name="src/main.rs" caption="محاولة استخدام نوع لا يُنفذ سِمة كائن السِمة">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-oop/listing-18-10/src/main.rs}}
```

</Listing>

سنحصل على هذا الخطأ لأن `String` لا يُنفذ السِمة `Draw`:

```console
{{#include ../listings/ch18-oop/listing-18-10/output.txt}}
```

يعلمنا هذا الخطأ أننا إما نُمرر شيئًا إلى `Screen` لم نقصد تمريره وبالتالي يجب أن نُمرر نوعًا مختلفًا، أو يجب أن نُنفذ `Draw` على `String` حتى تتمكن `Screen` من استدعاء `draw` عليها.

<!-- Old headings. Do not remove or links may break. -->

<a id="trait-objects-perform-dynamic-dispatch"></a>

### إجراء الإرسال الديناميكي

تذكر في ["أداء الكود الذي يستخدم الأنواع العمومية"][performance-of-code-using-generics]<!-- ignore --> في الفصل 10 مناقشتنا حول عملية أحادية الشكل (monomorphization) التي يقوم بها المُصرف على الأنواع العمومية: يُنشئ المُصرف تنفيذات غير عامة للدوال والأساليب لكل نوع محدد نستخدمه بدلاً من معامل نوع عمومي. الكود الذي ينتج عن أحادية الشكل يقوم بـ _الإرسال الثابت_ (static dispatch)، وهو عندما يعرف المُصرف أي دالة تستدعيها في وقت التصريف. هذا يقابل _الإرسال الديناميكي_ (dynamic dispatch)، وهو عندما لا يستطيع المُصرف معرفة أي دالة تستدعيها في وقت التصريف. في حالات الإرسال الديناميكي، يُصدر المُصرف كودًا سيعرف في وقت التشغيل أي دالة يستدعيها.

عندما نستخدم كائنات السِمة، يجب على Rust استخدام الإرسال الديناميكي. لا يعرف المُصرف جميع الأنواع التي قد تُستخدم مع الكود الذي يستخدم كائنات السِمة، لذا لا يعرف أي دالة مُنفذة على أي نوع يستدعيها. بدلاً من ذلك، في وقت التشغيل، تستخدم Rust المؤشرات داخل كائن السِمة لمعرفة أي دالة يستدعيها. يتحمل هذا البحث تكلفة في وقت التشغيل لا تحدث مع الإرسال الثابت. يمنع الإرسال الديناميكي أيضًا المُصرف من اختيار إدراج كود الدالة مضمنًا، مما يمنع بعض التحسينات، ولدى Rust بعض القواعد حول أين يمكنك وأين لا يمكنك استخدام الإرسال الديناميكي، تُسمى _توافق dyn_ (dyn compatibility). هذه القواعد تتجاوز نطاق هذا النقاش، لكن يمكنك قراءة المزيد عنها [في المرجع][dyn-compatibility]<!-- ignore -->. ومع ذلك، حصلنا على مرونة إضافية في الكود الذي كتبناه في القائمة 18-5 وتمكنا من دعمه في القائمة 18-9، لذا فهو مفاضلة يجب أخذها في الاعتبار.

[performance-of-code-using-generics]: ch10-01-syntax.html#performance-of-code-using-generics
[dynamically-sized]: ch20-03-advanced-types.html#dynamically-sized-types-and-the-sized-trait
[dyn-compatibility]: https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility
