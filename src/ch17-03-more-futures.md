<!-- Old headings. Do not remove or links may break. -->

<a id="yielding"></a>

### تسليم السيطرة إلى بيئة التشغيل (runtime)

تذكر من قسم ["برنامجنا الأول غير المتزامن"][async-program]<!-- ignore --> أنه في كل نقطة await، تمنح Rust بيئة التشغيل (runtime) فرصة لإيقاف المهمة (task) مؤقتًا والتبديل إلى أخرى إذا لم يكن المستقبل (future) الذي تنتظره جاهزًا. العكس صحيح أيضًا: Rust _فقط_ توقف كتل async وتعيد التحكم إلى بيئة التشغيل في نقطة await. كل شيء بين نقاط await هو متزامن.

هذا يعني أنه إذا قمت بالكثير من العمل في كتلة async بدون نقطة await، فإن ذلك المستقبل سيحجب أي مستقبلات أخرى من إحراز تقدم. قد تسمع هذا أحيانًا يشار إليه باسم مستقبل واحد _يجوّع_ (starving) مستقبلات أخرى. في بعض الحالات، قد لا يكون ذلك صفقة كبيرة. ومع ذلك، إذا كنت تقوم ببعض أنواع الإعداد المكلف أو العمل طويل الأمد، أو إذا كان لديك مستقبل سيستمر في القيام ببعض المهام المعينة إلى أجل غير مسمى، فستحتاج إلى التفكير في متى وأين تعيد التحكم إلى بيئة التشغيل.

لنحاكي عملية طويلة الأمد لتوضيح مشكلة التجويع، ثم استكشف كيفية حلها. تقدم القائمة 17-14 دالة `slow`.

<Listing number="17-14" caption="استخدام `thread::sleep` لمحاكاة العمليات البطيئة" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-14/src/main.rs:slow}}
```

</Listing>

يستخدم هذا الكود `std::thread::sleep` بدلاً من `trpl::sleep` بحيث يؤدي استدعاء `slow` إلى حجب الخيط الحالي لعدد معين من الميلي ثانية. يمكننا استخدام `slow` كبديل لعمليات العالم الحقيقي التي تكون طويلة الأمد وحاجبة.

في القائمة 17-15، نستخدم `slow` لمحاكاة القيام بهذا النوع من العمل المرتبط بالمعالج في زوج من المستقبلات.

<Listing number="17-15" caption="استدعاء `slow` لمحاكاة تشغيل العمليات البطيئة" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-15/src/main.rs:slow-futures}}
```

</Listing>

كل مستقبل يعيد التحكم إلى بيئة التشغيل فقط _بعد_ تنفيذ مجموعة من العمليات البطيئة. إذا قمت بتشغيل هذا الكود، سترى هذا الناتج:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo run
انسخ الناتج فقط
-->

```text
'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
```

كما هو الحال مع القائمة 17-5 حيث استخدمنا `trpl::select` للتسابق بين المستقبلات التي تجلب عنواني URL، لا يزال `select` ينتهي بمجرد انتهاء `a`. ومع ذلك، لا يوجد تداخل بين استدعاءات `slow` في المستقبلين. ينفذ مستقبل `a` كل عمله حتى يتم انتظار استدعاء `trpl::sleep`، ثم ينفذ مستقبل `b` كل عمله حتى يتم انتظار استدعاء `trpl::sleep` الخاص به، وأخيرًا يكتمل مستقبل `a`. للسماح لكلا المستقبلين بإحراز تقدم بين مهامهما البطيئة، نحتاج إلى نقاط await حتى نتمكن من إعادة التحكم إلى بيئة التشغيل. هذا يعني أننا بحاجة إلى شيء يمكننا انتظاره!

يمكننا بالفعل رؤية هذا النوع من التسليم يحدث في القائمة 17-15: إذا أزلنا `trpl::sleep` في نهاية مستقبل `a`، فسيكتمل دون تشغيل مستقبل `b` _على الإطلاق_. دعنا نحاول استخدام دالة `trpl::sleep` كنقطة انطلاق للسماح للعمليات بالتبديل في إحراز التقدم، كما هو موضح في القائمة 17-16.

<Listing number="17-16" caption="استخدام `trpl::sleep` للسماح للعمليات بالتبديل في إحراز التقدم" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-16/src/main.rs:here}}
```

</Listing>

أضفنا استدعاءات `trpl::sleep` مع نقاط await بين كل استدعاء لـ `slow`. الآن يتداخل عمل المستقبلين:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo run
انسخ الناتج فقط
-->

```text
'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
```

لا يزال مستقبل `a` يعمل لبعض الوقت قبل تسليم التحكم إلى `b`، لأنه يستدعي `slow` قبل أن يستدعي `trpl::sleep`، ولكن بعد ذلك يتبادل المستقبلان ذهابًا وإيابًا في كل مرة يصل أحدهما إلى نقطة await. في هذه الحالة، فعلنا ذلك بعد كل استدعاء لـ `slow`، ولكن يمكننا تقسيم العمل بأي طريقة منطقية بالنسبة لنا.

لا نريد حقًا _النوم_ هنا؛ نريد إحراز تقدم في أسرع وقت ممكن. نحتاج فقط إلى إعادة التحكم إلى بيئة التشغيل. يمكننا القيام بذلك مباشرة، باستخدام دالة `trpl::yield_now`. في القائمة 17-17، نستبدل جميع استدعاءات `trpl::sleep` تلك بـ `trpl::yield_now`.

<Listing number="17-17" caption="استخدام `yield_now` للسماح للعمليات بالتبديل في إحراز التقدم" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-17/src/main.rs:yields}}
```

</Listing>

هذا الكود أوضح بكثير حول النية الفعلية ويمكن أن يكون أسرع بكثير من استخدام `sleep`، لأن المؤقتات مثل تلك التي يستخدمها `sleep` غالبًا ما تكون لها حدود على مدى دقتها. نسخة `sleep` التي نستخدمها، على سبيل المثال، ستنام دائمًا لمدة ميلي ثانية واحدة على الأقل، حتى لو مررناها `Duration` من نانو ثانية واحدة. مرة أخرى، أجهزة الكمبيوتر الحديثة _سريعة_: يمكنها القيام بالكثير في ميلي ثانية واحدة!

هذا يعني أن async يمكن أن يكون مفيدًا حتى للمهام المرتبطة بالحساب، اعتمادًا على ما يفعله باقي برنامجك، لأنه يوفر أداة مفيدة لهيكلة العلاقات بين أجزاء مختلفة من البرنامج (ولكن على حساب النفقات العامة لآلة حالة async). هذا شكل من أشكال _تعدد المهام التعاوني_ (cooperative multitasking)، حيث لكل مستقبل القدرة على تحديد متى يسلم السيطرة عبر نقاط await. وبالتالي فإن لكل مستقبل أيضًا مسؤولية تجنب الحجب لفترة طويلة جدًا. في بعض أنظمة التشغيل المضمنة المستندة إلى Rust، هذا هو النوع _الوحيد_ من تعدد المهام!

في كود العالم الحقيقي، لن تتناوب عادةً استدعاءات الدوال مع نقاط await في كل سطر واحد، بالطبع. بينما إعادة السيطرة بهذه الطريقة غير مكلفة نسبيًا، إلا أنها ليست مجانية. في كثير من الحالات، قد تؤدي محاولة تقسيم مهمة مرتبطة بالحساب إلى جعلها أبطأ بكثير، لذلك في بعض الأحيان يكون من الأفضل للأداء _العام_ السماح لعملية ما بالحجب لفترة وجيزة. قم دائمًا بالقياس لمعرفة ما هي اختناقات الأداء الفعلية للكود الخاص بك. الديناميكية الأساسية مهمة أن نضعها في الاعتبار، مع ذلك، إذا كنت _ترى_ الكثير من العمل يحدث بشكل تسلسلي كنت تتوقع أن يحدث بشكل متزامن!

### بناء تجريدات Async الخاصة بنا

يمكننا أيضًا تكوين المستقبلات معًا لإنشاء أنماط جديدة. على سبيل المثال، يمكننا بناء دالة `timeout` مع أحجار البناء غير المتزامنة التي لدينا بالفعل. عندما ننتهي، ستكون النتيجة حجر بناء آخر يمكننا استخدامه لإنشاء المزيد من التجريدات غير المتزامنة.

توضح القائمة 17-18 كيف نتوقع أن يعمل `timeout` هذا مع مستقبل بطيء.

<Listing number="17-18" caption="استخدام `timeout` المتخيل لتشغيل عملية بطيئة مع حد زمني" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-18/src/main.rs:here}}
```

</Listing>

لنقم بتنفيذ هذا! للبدء، دعنا نفكر في واجهة برمجة التطبيقات لـ `timeout`:

- يجب أن تكون دالة async نفسها حتى نتمكن من انتظارها.
- يجب أن يكون معاملها الأول مستقبلًا لتشغيله. يمكننا جعله عامًا للسماح له بالعمل مع أي مستقبل.
- سيكون معاملها الثاني هو الحد الأقصى للوقت للانتظار. إذا استخدمنا `Duration`، فسيسهل ذلك تمريره إلى `trpl::sleep`.
- يجب أن يُرجع `Result`. إذا اكتمل المستقبل بنجاح، سيكون `Result` هو `Ok` مع القيمة التي ينتجها المستقبل. إذا انقضى المهلة أولاً، سيكون `Result` هو `Err` مع المدة التي انتظرتها المهلة.

توضح القائمة 17-19 هذا التصريح.

<!-- This is not tested because it intentionally does not compile. -->

<Listing number="17-19" caption="تحديد توقيع `timeout`" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-19/src/main.rs:declaration}}
```

</Listing>

هذا يلبي أهدافنا للأنواع. الآن دعنا نفكر في _السلوك_ الذي نحتاجه: نريد التسابق بين المستقبل الممرر والمدة. يمكننا استخدام `trpl::sleep` لصنع مستقبل مؤقت من المدة، واستخدام `trpl::select` لتشغيل ذلك المؤقت مع المستقبل الذي يمرره المتصل.

في القائمة 17-20، ننفذ `timeout` عن طريق المطابقة على نتيجة انتظار `trpl::select`.

<Listing number="17-20" caption="تحديد `timeout` باستخدام `select` و `sleep`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-20/src/main.rs:implementation}}
```

</Listing>

تنفيذ `trpl::select` ليس عادلاً: فهو يستطلع الوسائط دائمًا بالترتيب الذي يتم تمريرها به (تنفيذات `select` الأخرى ستختار عشوائيًا الوسيطة التي يجب استطلاعها أولاً). وبالتالي، نمرر `future_to_try` إلى `select` أولاً حتى تحصل على فرصة للاكتمال حتى لو كانت `max_time` مدة قصيرة جدًا. إذا انتهى `future_to_try` أولاً، سيُرجع `select` `Left` مع الناتج من `future_to_try`. إذا انتهى `timer` أولاً، سيُرجع `select` `Right` مع ناتج المؤقت `()`.

إذا نجح `future_to_try` وحصلنا على `Left(output)`، نُرجع `Ok(output)`. إذا انقضى مؤقت النوم بدلاً من ذلك وحصلنا على `Right(())`، نتجاهل `()` بـ `_` ونُرجع `Err(max_time)` بدلاً من ذلك.

بذلك، لدينا `timeout` عامل مبني من مساعدين غير متزامنين آخرين. إذا قمنا بتشغيل الكود الخاص بنا، فسيطبع وضع الفشل بعد المهلة:

```text
Failed after 2 seconds
```

نظرًا لأن المستقبلات تتكون مع مستقبلات أخرى، يمكنك بناء أدوات قوية حقًا باستخدام أحجار بناء غير متزامنة أصغر. على سبيل المثال، يمكنك استخدام نفس النهج لدمج المهلات الزمنية مع إعادة المحاولة، وبدورها استخدام تلك مع عمليات مثل استدعاءات الشبكة (مثل تلك الموجودة في القائمة 17-5).

في الممارسة العملية، ستعمل عادةً مباشرة مع `async` و `await`، وثانويًا مع دوال مثل `select` وماكرو مثل ماكرو `join!` للتحكم في كيفية تنفيذ المستقبلات الخارجية.

لقد رأينا الآن عددًا من الطرق للعمل مع مستقبلات متعددة في نفس الوقت. بعد ذلك، سننظر في كيفية العمل مع مستقبلات متعددة في تسلسل بمرور الوقت مع _التدفقات_ (streams).

[async-program]: ch17-01-futures-and-syntax.html#our-first-async-program
