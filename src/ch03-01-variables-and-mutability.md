## المتغيرات والقابلية للتعديل

كما ذكرنا في قسم ["تخزين القيم باستخدام المتغيرات"][storing-values-with-variables]<!-- ignore -->، تكون المتغيرات افتراضياً غير قابلة للتعديل. هذه واحدة من العديد من التوجيهات التي تقدمها Rust لك لكتابة كودك بطريقة تستفيد من الأمان والتزامن السهل الذي تقدمه Rust. ومع ذلك، لا يزال لديك خيار جعل متغيراتك قابلة للتعديل. دعنا نستكشف كيف ولماذا تشجعك Rust على تفضيل عدم القابلية للتعديل ولماذا قد ترغب أحياناً في الخروج عن ذلك.

عندما يكون متغير غير قابل للتعديل، بمجرد ربط قيمة باسم، لا يمكنك تغيير تلك القيمة. لتوضيح ذلك، قم بإنشاء مشروع جديد يسمى _variables_ في دليل _projects_ الخاص بك باستخدام `cargo new variables`.

بعد ذلك، في دليل _variables_ الجديد، افتح _src/main.rs_ واستبدل كوده بالكود التالي، والذي لن يتم تجميعه بعد:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

احفظ البرنامج وشغله باستخدام `cargo run`. يجب أن تتلقى رسالة خطأ تتعلق بخطأ عدم القابلية للتعديل، كما هو موضح في هذا الناتج:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

يوضح هذا المثال كيف يساعدك المترجم في العثور على الأخطاء في برامجك. قد تكون أخطاء المترجم محبطة، لكنها في الواقع تعني فقط أن برنامجك لا يفعل بأمان ما تريده أن يفعله بعد؛ فهي _لا_ تعني أنك لست مبرمجاً جيداً! حتى مستخدمو Rust ذوو الخبرة لا يزالون يحصلون على أخطاء المترجم.

لقد تلقيت رسالة الخطأ `` cannot assign twice to immutable variable `x` `` لأنك حاولت تعيين قيمة ثانية للمتغير `x` غير القابل للتعديل.

من المهم أن نحصل على أخطاء وقت الترجمة عندما نحاول تغيير قيمة تم تعيينها كغير قابلة للتعديل، لأن هذا الوضع بالذات يمكن أن يؤدي إلى أخطاء. إذا كان جزء من كودنا يعمل على افتراض أن القيمة لن تتغير أبداً وجزء آخر من كودنا يغير تلك القيمة، فمن الممكن أن الجزء الأول من الكود لن يفعل ما صُمم للقيام به. يمكن أن يكون سبب هذا النوع من الأخطاء صعب التتبع بعد حدوثه، خاصة عندما يغير الجزء الثاني من الكود القيمة فقط _أحياناً_. يضمن مترجم Rust أنه عندما تذكر أن القيمة لن تتغير، فإنها حقاً لن تتغير، لذلك لا يتعين عليك تتبعها بنفسك. وبالتالي يكون كودك أسهل للتفكير فيه.

لكن القابلية للتعديل يمكن أن تكون مفيدة جداً ويمكن أن تجعل الكود أكثر ملاءمة للكتابة. على الرغم من أن المتغيرات غير قابلة للتعديل افتراضياً، يمكنك جعلها قابلة للتعديل عن طريق إضافة `mut` أمام اسم المتغير كما فعلت في [الفصل 2][storing-values-with-variables]<!-- ignore -->. إضافة `mut` ينقل أيضاً النية إلى القراء المستقبليين للكود من خلال الإشارة إلى أن أجزاء أخرى من الكود ستغير قيمة هذا المتغير.

على سبيل المثال، دعنا نغير _src/main.rs_ إلى ما يلي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

عندما نشغل البرنامج الآن، نحصل على هذا:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

يُسمح لنا بتغيير القيمة المرتبطة بـ `x` من `5` إلى `6` عندما يتم استخدام `mut`. في النهاية، قرار استخدام القابلية للتعديل أم لا متروك لك ويعتمد على ما تعتقد أنه الأوضح في تلك الحالة المعينة.

<!-- Old headings. Do not remove or links may break. -->
<a id="constants"></a>

### إعلان الثوابت

مثل المتغيرات غير القابلة للتعديل، _الثوابت_ هي قيم مرتبطة باسم وغير مسموح بتغييرها، ولكن هناك بعض الاختلافات بين الثوابت والمتغيرات.

أولاً، لا يُسمح لك باستخدام `mut` مع الثوابت. الثوابت ليست فقط غير قابلة للتعديل افتراضياً - فهي دائماً غير قابلة للتعديل. تعلن عن الثوابت باستخدام الكلمة المفتاحية `const` بدلاً من الكلمة المفتاحية `let`، ويجب _يجب_ توضيح نوع القيمة. سنغطي الأنواع وتعليقات الأنواع في القسم التالي، ["أنواع البيانات"][data-types]<!-- ignore -->، لذا لا تقلق بشأن التفاصيل الآن. فقط اعلم أنه يجب عليك دائماً توضيح النوع.

يمكن إعلان الثوابت في أي نطاق، بما في ذلك النطاق العام، مما يجعلها مفيدة للقيم التي تحتاج أجزاء كثيرة من الكود إلى معرفتها.

الاختلاف الأخير هو أن الثوابت يمكن تعيينها فقط لتعبير ثابت، وليس لنتيجة قيمة يمكن حسابها فقط في وقت التشغيل.

إليك مثال على إعلان ثابت:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

اسم الثابت هو `THREE_HOURS_IN_SECONDS`، وقيمته مضبوطة على نتيجة ضرب 60 (عدد الثواني في دقيقة) في 60 (عدد الدقائق في ساعة) في 3 (عدد الساعات التي نريد حسابها في هذا البرنامج). اتفاقية تسمية Rust للثوابت هي استخدام جميع الأحرف الكبيرة مع شرطات سفلية بين الكلمات. المترجم قادر على تقييم مجموعة محدودة من العمليات في وقت الترجمة، مما يتيح لنا اختيار كتابة هذه القيمة بطريقة أسهل للفهم والتحقق، بدلاً من تعيين هذا الثابت للقيمة 10,800. راجع [قسم مرجع Rust حول تقييم الثوابت][const-eval] لمزيد من المعلومات حول العمليات التي يمكن استخدامها عند إعلان الثوابت.

الثوابت صالحة طوال الوقت الذي يعمل فيه البرنامج، ضمن النطاق الذي تم إعلانها فيه. تجعل هذه الخاصية الثوابت مفيدة للقيم في نطاق تطبيقك والتي قد تحتاج أجزاء متعددة من البرنامج إلى معرفتها، مثل الحد الأقصى لعدد النقاط التي يُسمح لأي لاعب في لعبة بكسبها، أو سرعة الضوء.

تسمية القيم المشفرة المستخدمة في جميع أنحاء برنامجك كثوابت مفيدة في نقل معنى تلك القيمة إلى مشرفي الكود المستقبليين. كما أنه يساعد على وجود مكان واحد فقط في كودك تحتاج إلى تغييره إذا كانت القيمة المشفرة بحاجة إلى التحديث في المستقبل.

### الإخفاء

كما رأيت في درس لعبة التخمين في [الفصل 2][comparing-the-guess-to-the-secret-number]<!-- ignore -->، يمكنك إعلان متغير جديد بنفس الاسم كمتغير سابق. يقول مستخدمو Rust أن المتغير الأول _مخفي_ بواسطة الثاني، مما يعني أن المتغير الثاني هو ما سيراه المترجم عندما تستخدم اسم المتغير. في الواقع، يطغى المتغير الثاني على الأول، آخذاً أي استخدامات لاسم المتغير لنفسه حتى يتم إخفاؤه هو نفسه أو ينتهي النطاق. يمكننا إخفاء متغير باستخدام نفس اسم المتغير وتكرار استخدام الكلمة المفتاحية `let` كما يلي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

يربط هذا البرنامج أولاً `x` بقيمة `5`. ثم ينشئ متغيراً جديداً `x` عن طريق تكرار `let x =`، آخذاً القيمة الأصلية وإضافة `1` بحيث تصبح قيمة `x` هي `6`. بعد ذلك، ضمن نطاق داخلي تم إنشاؤه باستخدام الأقواس المعقوفة، يخفي أيضاً البيان `let` الثالث `x` وينشئ متغيراً جديداً، مضاعفاً القيمة السابقة بـ `2` لإعطاء `x` قيمة `12`. عندما ينتهي هذا النطاق، ينتهي الإخفاء الداخلي ويعود `x` إلى `6`. عندما نشغل هذا البرنامج، سيخرج ما يلي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

الإخفاء يختلف عن وضع علامة على متغير كـ `mut` لأننا سنحصل على خطأ وقت الترجمة إذا حاولنا عن طريق الخطأ إعادة التعيين لهذا المتغير دون استخدام الكلمة المفتاحية `let`. باستخدام `let`، يمكننا إجراء بعض التحويلات على قيمة ولكن جعل المتغير غير قابل للتعديل بعد اكتمال تلك التحويلات.

الاختلاف الآخر بين `mut` والإخفاء هو أنه لأننا نقوم فعلياً بإنشاء متغير جديد عندما نستخدم الكلمة المفتاحية `let` مرة أخرى، يمكننا تغيير نوع القيمة ولكن إعادة استخدام نفس الاسم. على سبيل المثال، لنفترض أن برنامجنا يطلب من المستخدم إظهار عدد المسافات التي يريدها بين بعض النصوص عن طريق إدخال أحرف المسافة، ثم نريد تخزين هذا الإدخال كرقم:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

المتغير الأول `spaces` هو من نوع سلسلة نصية، والمتغير الثاني `spaces` هو من نوع رقم. وبالتالي، يوفر علينا الإخفاء من الحاجة إلى التوصل إلى أسماء مختلفة، مثل `spaces_str` و `spaces_num`؛ بدلاً من ذلك، يمكننا إعادة استخدام الاسم الأبسط `spaces`. ومع ذلك، إذا حاولنا استخدام `mut` لهذا، كما هو موضح هنا، فسنحصل على خطأ وقت الترجمة:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

يقول الخطأ أننا غير مسموح لنا بتغيير نوع المتغير:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

الآن بعد أن استكشفنا كيفية عمل المتغيرات، دعنا ننظر إلى المزيد من أنواع البيانات التي يمكن أن تمتلكها.

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
