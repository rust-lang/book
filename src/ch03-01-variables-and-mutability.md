## ตัวแปรและการเปลี่ยนแปลงค่า (Variables and Mutability)

ดังที่กล่าวไว้ในส่วน [“การเก็บค่าด้วยตัวแปร”][storing-values-with-variables]<!-- ignore --> โดยค่าเริ่มต้นแล้ว ตัวแปรจะไม่สามารถเปลี่ยนแปลงค่าได้ (immutable) นี่เป็นหนึ่งในหลายๆ วิธีที่ Rust กระตุ้นให้คุณเขียนโค้ดในลักษณะที่ใช้ประโยชน์จากความปลอดภัยและการทำงานพร้อมกัน (concurrency) ที่ง่ายดายซึ่ง Rust มอบให้ อย่างไรก็ตาม คุณยังคงมีทางเลือกที่จะทำให้ตัวแปรของคุณสามารถเปลี่ยนแปลงค่าได้ (mutable) เรามาสำรวจกันว่า Rust สนับสนุนให้คุณเลือกใช้ immutability อย่างไรและเพราะเหตุใด และทำไมในบางครั้งคุณอาจต้องการที่จะไม่ทำตามนั้น

เมื่อตัวแปรเป็น immutable เมื่อค่าถูกผูกเข้ากับชื่อแล้ว คุณจะไม่สามารถเปลี่ยนแปลงค่านั้นได้ เพื่อแสดงให้เห็นสิ่งนี้ ให้สร้างโปรเจกต์ใหม่ชื่อ _variables_ ในไดเรกทอรี _projects_ ของคุณโดยใช้ `cargo new variables`

จากนั้น ในไดเรกทอรี _variables_ ใหม่ของคุณ ให้เปิด _src/main.rs_ และแทนที่โค้ดด้วยโค้ดต่อไปนี้ ซึ่งจะยังไม่คอมไพล์ในตอนนี้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

บันทึกและรันโปรแกรมโดยใช้ `cargo run` คุณควรจะได้รับข้อความแสดงข้อผิดพลาดเกี่ยวกับข้อผิดพลาดของ immutability ดังที่แสดงในผลลัพธ์นี้:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

ตัวอย่างนี้แสดงให้เห็นว่าคอมไพเลอร์ช่วยคุณค้นหาข้อผิดพลาดในโปรแกรมของคุณได้อย่างไร ข้อผิดพลาดของคอมไพเลอร์อาจน่าหงุดหงิด แต่จริงๆ แล้วมันหมายความเพียงว่าโปรแกรมของคุณยังไม่ได้ทำในสิ่งที่คุณต้องการอย่างปลอดภัยเท่านั้น มัน _ไม่ได้_ หมายความว่าคุณไม่ใช่นักพัฒนาโปรแกรมที่ดี! Rustaceans ที่มีประสบการณ์ก็ยังคงได้รับข้อผิดพลาดของคอมไพเลอร์

คุณได้รับข้อความแสดงข้อผิดพลาด `` cannot assign twice to immutable variable `x` `` เพราะคุณพยายามกำหนดค่าที่สองให้กับตัวแปร `x` ที่เป็น immutable

เป็นสิ่งสำคัญที่เราจะได้รับข้อผิดพลาดขณะคอมไพล์ (compile-time errors) เมื่อเราพยายามเปลี่ยนแปลงค่าที่ถูกกำหนดให้เป็น immutable เพราะสถานการณ์เช่นนี้สามารถนำไปสู่ข้อบกพร่องได้ หากส่วนหนึ่งของโค้ดของเราทำงานโดยตั้งอยู่บนสมมติฐานว่าค่าจะไม่เปลี่ยนแปลง และอีกส่วนหนึ่งของโค้ดของเราเปลี่ยนแปลงค่านั้น ก็เป็นไปได้ว่าส่วนแรกของโค้ดจะไม่ทำงานตามที่ได้ออกแบบไว้ สาเหตุของข้อบกพร่องประเภทนี้อาจติดตามได้ยากหลังจากเกิดเหตุการณ์ขึ้นแล้ว โดยเฉพาะอย่างยิ่งเมื่อโค้ดส่วนที่สองเปลี่ยนแปลงค่าเพียง _บางครั้ง_ เท่านั้น คอมไพเลอร์ Rust รับประกันว่าเมื่อคุณระบุว่าค่าจะไม่เปลี่ยนแปลง มันจะไม่เปลี่ยนแปลงจริงๆ ดังนั้นคุณจึงไม่ต้องคอยติดตามมันด้วยตัวเอง โค้ดของคุณจึงง่ายต่อการทำความเข้าใจมากขึ้น

แต่ mutability ก็มีประโยชน์มาก และสามารถทำให้การเขียนโค้ดสะดวกยิ่งขึ้น แม้ว่าตัวแปรจะเป็น immutable โดยค่าเริ่มต้น คุณสามารถทำให้มันเป็น mutable ได้โดยการเพิ่ม `mut` หน้าชื่อตัวแปรดังที่คุณทำใน [บทที่ 2][storing-values-with-variables]<!-- ignore --> การเพิ่ม `mut` ยังเป็นการสื่อสารเจตนาไปยังผู้อ่านโค้ดในอนาคตด้วย โดยระบุว่าส่วนอื่นๆ ของโค้ดจะเปลี่ยนแปลงค่าของตัวแปรนี้

ตัวอย่างเช่น เรามาเปลี่ยน _src/main.rs_ เป็นดังนี้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

เมื่อเรารันโปรแกรมตอนนี้ เราจะได้ผลลัพธ์นี้:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

เราได้รับอนุญาตให้เปลี่ยนค่าที่ผูกกับ `x` จาก `5` เป็น `6` เมื่อใช้ `mut` ท้ายที่สุดแล้ว การตัดสินใจว่าจะใช้ mutability หรือไม่นั้นขึ้นอยู่กับคุณและขึ้นอยู่กับว่าคุณคิดว่าอะไรชัดเจนที่สุดในสถานการณ์นั้นๆ

### ค่าคงที่ (Constants)

เช่นเดียวกับตัวแปร immutable _ค่าคงที่_ (constants) คือค่าที่ผูกกับชื่อและไม่อนุญาตให้เปลี่ยนแปลง แต่มีความแตกต่างเล็กน้อยระหว่างค่าคงที่และตัวแปร

ประการแรก คุณไม่ได้รับอนุญาตให้ใช้ `mut` กับค่าคงที่ ค่าคงที่ไม่เพียงแต่เป็น immutable โดยค่าเริ่มต้นเท่านั้น—มันเป็น immutable เสมอ คุณประกาศค่าคงที่โดยใช้ keyword `const` แทน keyword `let` และไทป์ของค่า _ต้อง_ ถูกระบุ (annotate) เราจะครอบคลุมไทป์และการระบุไทป์ในส่วนถัดไป [“ชนิดข้อมูล”][data-types]<!-- ignore --> ดังนั้นอย่ากังวลเกี่ยวกับรายละเอียดในตอนนี้ เพียงแค่รู้ว่าคุณต้องระบุไทป์เสมอ

ค่าคงที่สามารถประกาศได้ในทุกขอบเขต (scope) รวมถึงขอบเขตโกลบอล (global scope) ซึ่งทำให้มีประโยชน์สำหรับค่าที่โค้ดหลายส่วนจำเป็นต้องรู้

ความแตกต่างสุดท้ายคือค่าคงที่สามารถตั้งค่าได้เฉพาะกับนิพจน์คงที่ (constant expression) เท่านั้น ไม่ใช่ผลลัพธ์ของค่าที่สามารถคำนวณได้ในขณะรันไทม์ (runtime) เท่านั้น

นี่คือตัวอย่างของการประกาศค่าคงที่:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

ชื่อของค่าคงที่คือ `THREE_HOURS_IN_SECONDS` และค่าของมันถูกตั้งค่าเป็นผลลัพธ์ของการคูณ 60 (จำนวนวินาทีในหนึ่งนาที) ด้วย 60 (จำนวนนาทีในหนึ่งชั่วโมง) ด้วย 3 (จำนวนชั่วโมงที่เราต้องการนับในโปรแกรมนี้) แบบแผนการตั้งชื่อของ Rust สำหรับค่าคงที่คือการใช้อักษรตัวพิมพ์ใหญ่ทั้งหมดพร้อมด้วยเครื่องหมายอันเดอร์สกอร์ระหว่างคำ คอมไพเลอร์สามารถประเมินชุดของการดำเนินการที่จำกัดในขณะคอมไพล์ ซึ่งช่วยให้เราเลือกที่จะเขียนค่านี้ในลักษณะที่เข้าใจและตรวจสอบได้ง่ายกว่า แทนที่จะตั้งค่าคงที่นี้เป็นค่า 10,800 ดู [ส่วนของ Rust Reference เกี่ยวกับการประเมินค่าคงที่][const-eval] สำหรับข้อมูลเพิ่มเติมเกี่ยวกับการดำเนินการที่สามารถใช้ได้เมื่อประกาศค่าคงที่

ค่าคงที่ใช้ได้ตลอดระยะเวลาที่โปรแกรมทำงาน ภายในขอบเขตที่มันถูกประกาศ คุณสมบัตินี้ทำให้ค่าคงที่มีประโยชน์สำหรับค่าในโดเมนแอปพลิเคชันของคุณที่ส่วนต่างๆ ของโปรแกรมอาจจำเป็นต้องรู้ เช่น จำนวนคะแนนสูงสุดที่ผู้เล่นเกมคนใดคนหนึ่งสามารถได้รับ หรือความเร็วแสง

การตั้งชื่อค่าที่ฮาร์ดโค้ด (hardcoded values) ที่ใช้ทั่วทั้งโปรแกรมของคุณเป็นค่าคงที่นั้นมีประโยชน์ในการสื่อความหมายของค่านั้นไปยังผู้ดูแลโค้ดในอนาคต นอกจากนี้ยังช่วยให้มีเพียงที่เดียวในโค้ดของคุณที่คุณจะต้องเปลี่ยนแปลงหากค่าที่ฮาร์ดโค้ดจำเป็นต้องอัปเดตในอนาคต

### การบดบัง (Shadowing)

ดังที่คุณเห็นในบทช่วยสอนเกมทายตัวเลขใน [บทที่ 2][comparing-the-guess-to-the-secret-number]<!-- ignore --> คุณสามารถประกาศตัวแปรใหม่ที่มีชื่อเดียวกับตัวแปรก่อนหน้าได้ Rustaceans กล่าวว่าตัวแปรแรกถูก _บดบัง_ (shadowed) โดยตัวแปรที่สอง ซึ่งหมายความว่าตัวแปรที่สองคือสิ่งที่คอมไพเลอร์จะเห็นเมื่อคุณใช้ชื่อของตัวแปรนั้น โดยสรุปคือ ตัวแปรที่สองจะบดบังตัวแปรแรก โดยนำการใช้ชื่อตัวแปรทั้งหมดมาที่ตัวเองจนกว่าตัวมันเองจะถูกบดบังหรือขอบเขตสิ้นสุดลง เราสามารถบดบังตัวแปรได้โดยใช้ชื่อตัวแปรเดียวกันและใช้ keyword `let` ซ้ำดังนี้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

โปรแกรมนี้ผูก `x` เข้ากับค่า `5` เป็นอันดับแรก จากนั้นสร้างตัวแปรใหม่ `x` โดยใช้ `let x =` ซ้ำ โดยนำค่าเดิมมาบวก `1` ดังนั้นค่าของ `x` จึงเป็น `6` จากนั้น ภายในขอบเขตด้านในที่สร้างด้วยวงเล็บปีกกา คำสั่ง `let` ที่สามก็บดบัง `x` และสร้างตัวแปรใหม่ โดยคูณค่าก่อนหน้าด้วย `2` เพื่อให้ `x` มีค่าเป็น `12` เมื่อขอบเขตนั้นสิ้นสุดลง การบดบังด้านในจะสิ้นสุดลงและ `x` จะกลับไปเป็น `6` เมื่อเรารันโปรแกรมนี้ มันจะแสดงผลลัพธ์ดังนี้:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

การบดบังแตกต่างจากการทำเครื่องหมายตัวแปรเป็น `mut` เพราะเราจะได้รับข้อผิดพลาดขณะคอมไพล์หากเราพยายามกำหนดค่าใหม่ให้กับตัวแปรนี้โดยไม่ได้ตั้งใจโดยไม่ใช้ keyword `let` ด้วยการใช้ `let` เราสามารถทำการแปลงค่าเล็กน้อยได้ แต่ให้ตัวแปรเป็น immutable หลังจากที่การแปลงเหล่านั้นเสร็จสิ้นแล้ว

ความแตกต่างอีกประการระหว่าง `mut` และการบดบังคือ เนื่องจากเรากำลังสร้างตัวแปรใหม่อย่างมีประสิทธิภาพเมื่อเราใช้ keyword `let` อีกครั้ง เราจึงสามารถเปลี่ยนไทป์ของค่าได้แต่ยังคงใช้ชื่อเดิมซ้ำได้ ตัวอย่างเช่น สมมติว่าโปรแกรมของเราขอให้ผู้ใช้แสดงจำนวนช่องว่างที่ต้องการระหว่างข้อความบางส่วนโดยการป้อนอักขระช่องว่าง จากนั้นเราต้องการเก็บอินพุตนั้นเป็นตัวเลข:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

ตัวแปร `spaces` ตัวแรกเป็นไทป์สตริง และตัวแปร `spaces` ตัวที่สองเป็นไทป์ตัวเลข การบดบังจึงช่วยให้เราไม่ต้องคิดชื่อที่แตกต่างกัน เช่น `spaces_str` และ `spaces_num` แต่เราสามารถใช้ชื่อ `spaces` ที่เรียบง่ายกว่าซ้ำได้ อย่างไรก็ตาม หากเราพยายามใช้ `mut` สำหรับสิ่งนี้ ดังที่แสดงไว้ที่นี่ เราจะได้รับข้อผิดพลาดขณะคอมไพล์:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

ข้อผิดพลาดระบุว่าเราไม่ได้รับอนุญาตให้เปลี่ยนแปลงไทป์ของตัวแปร:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

ตอนนี้เราได้สำรวจวิธีการทำงานของตัวแปรแล้ว เรามาดูชนิดข้อมูลอื่นๆ ที่ตัวแปรสามารถมีได้กัน

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
