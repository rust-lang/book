## التحقق من صحة المراجع باستخدام فترات الحياة (lifetimes)

فترات الحياة (lifetimes) هي نوع آخر من الأنواع العمومية (generic types) التي كنا نستخدمها بالفعل. بدلاً من ضمان أن النوع له السلوك الذي نريده، تضمن فترات الحياة (lifetimes) أن المراجع صالحة طالما أننا بحاجة إليها.

أحد التفاصيل التي لم نناقشها في قسم ["المراجع والاستعارة"][references-and-borrowing]<!-- ignore --> في الفصل 4 هو أن كل مرجع في Rust له فترة حياة (lifetime)، وهي النطاق الذي يكون فيه ذلك المرجع صالحًا. في معظم الأحيان، تكون فترات الحياة (lifetimes) ضمنية ومستنتجة، تمامًا كما يتم استنتاج الأنواع في معظم الأحيان. نحتاج فقط إلى تحديد الأنواع عندما تكون هناك أنواع متعددة ممكنة. وبطريقة مماثلة، يجب علينا تحديد فترات الحياة (lifetimes) عندما يمكن أن تكون فترات حياة المراجع مرتبطة ببعضها بطرق مختلفة. يطلب منا Rust تحديد العلاقات باستخدام معاملات فترة الحياة العامة (generic lifetime parameters) للتأكد من أن المراجع الفعلية المستخدمة في وقت التشغيل ستكون بالتأكيد صالحة.

تحديد فترات الحياة (lifetimes) ليس حتى مفهومًا تمتلكه معظم لغات البرمجة الأخرى، لذا سيبدو هذا غير مألوف. على الرغم من أننا لن نغطي فترات الحياة (lifetimes) بالكامل في هذا الفصل، سنناقش الطرق الشائعة التي قد تواجه فيها صياغة فترات الحياة (lifetimes) حتى تتمكن من الشعور بالراحة مع المفهوم.

<!-- Old headings. Do not remove or links may break. -->

<a id="preventing-dangling-references-with-lifetimes"></a>

### المراجع المعلقة

الهدف الرئيسي من فترات الحياة (lifetimes) هو منع المراجع المعلقة، والتي، إذا كان مسموحًا بوجودها، ستتسبب في إشارة البرنامج إلى بيانات غير البيانات المقصودة. ضع في اعتبارك البرنامج في القائمة 10-16، الذي يحتوي على نطاق خارجي ونطاق داخلي.

<Listing number="10-16" caption="محاولة استخدام مرجع قيمته خرجت من النطاق">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}
```

</Listing>

> ملاحظة: تعلن الأمثلة في القوائم 10-16، 10-17، و 10-23 عن متغيرات دون إعطائها قيمة أولية، لذا يوجد اسم المتغير في النطاق الخارجي. للوهلة الأولى، قد يبدو هذا متعارضًا مع عدم وجود قيم خالية في Rust. ومع ذلك، إذا حاولنا استخدام متغير قبل إعطائه قيمة، سنحصل على خطأ في وقت الترجمة، مما يوضح أن Rust بالفعل لا يسمح بالقيم الخالية.

يعلن النطاق الخارجي عن متغير يسمى `r` بدون قيمة أولية، ويعلن النطاق الداخلي عن متغير يسمى `x` بالقيمة الأولية `5`. داخل النطاق الداخلي، نحاول تعيين قيمة `r` كمرجع إلى `x`. ثم ينتهي النطاق الداخلي، ونحاول طباعة القيمة في `r`. لن يتم ترجمة هذا الكود، لأن القيمة التي يشير إليها `r` قد خرجت من النطاق قبل أن نحاول استخدامها. هذه هي رسالة الخطأ:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
```

تقول رسالة الخطأ أن المتغير `x` "لا يعيش لفترة كافية". السبب هو أن `x` سيكون خارج النطاق عندما ينتهي النطاق الداخلي في السطر 7. لكن `r` لا يزال صالحًا للنطاق الخارجي؛ لأن نطاقه أكبر، نقول إنه "يعيش لفترة أطول". إذا سمح Rust لهذا الكود بالعمل، فإن `r` سيشير إلى ذاكرة تم تحريرها عندما خرج `x` من النطاق، وأي شيء نحاول القيام به مع `r` لن يعمل بشكل صحيح. إذن، كيف يحدد Rust أن هذا الكود غير صالح؟ يستخدم مدقق الاستعارة.

### مدقق الاستعارة

يحتوي مصرِّف Rust على _مدقق استعارة_ يقارن النطاقات لتحديد ما إذا كانت جميع الاستعارات صالحة. تُظهر القائمة 10-17 نفس الكود الموجود في القائمة 10-16 ولكن مع تعليقات توضح فترات حياة (lifetimes) المتغيرات.

<Listing number="10-17" caption="تعليقات توضيحية لفترات حياة `r` و `x`، مسماة `'a` و `'b`، على التوالي">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}
```

</Listing>

هنا، قمنا بتعليق فترة حياة (lifetime) `r` بـ `'a` وفترة حياة (lifetime) `x` بـ `'b`. كما ترى، كتلة `'b` الداخلية أصغر بكثير من كتلة فترة الحياة (lifetime) الخارجية `'a`. في وقت الترجمة، يقارن Rust حجم فترتي الحياة (lifetimes) ويرى أن `r` له فترة حياة (lifetime) `'a` لكنه يشير إلى ذاكرة بفترة حياة (lifetime) `'b`. يُرفض البرنامج لأن `'b` أقصر من `'a`: موضوع المرجع لا يعيش طالما المرجع.

تصلح القائمة 10-18 الكود بحيث لا يحتوي على مرجع معلق ويتم ترجمته بدون أي أخطاء.

<Listing number="10-18" caption="مرجع صالح لأن البيانات لها فترة حياة أطول من المرجع">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}
```

</Listing>

هنا، لدى `x` فترة الحياة (lifetime) `'b`، والتي في هذه الحالة أكبر من `'a`. هذا يعني أن `r` يمكن أن يشير إلى `x` لأن Rust يعرف أن المرجع في `r` سيكون دائمًا صالحًا طالما أن `x` صالح.

الآن بعد أن عرفت أين توجد فترات حياة (lifetimes) المراجع وكيف يحلل Rust فترات الحياة (lifetimes) للتأكد من أن المراجع ستكون دائمًا صالحة، دعنا نستكشف فترات الحياة العامة (generic lifetimes) في معاملات (parameters) الدوال والقيم المرجعة.

### فترات الحياة العامة (generic lifetimes) في الدوال

سنكتب دالة تُرجع الأطول من شريحتي سلسلة نصية. ستأخذ هذه الدالة شريحتي سلسلة نصية وتُرجع شريحة سلسلة نصية واحدة. بعد تنفيذ (implementation) دالة `longest`، يجب أن يطبع الكود في القائمة 10-19 `The longest string is abcd`.

<Listing number="10-19" file-name="src/main.rs" caption="دالة `main` تستدعي دالة `longest` لإيجاد الأطول من شريحتي سلسلة نصية">

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}
```

</Listing>

لاحظ أننا نريد أن تأخذ الدالة شرائح سلسلة نصية، وهي مراجع، بدلاً من السلاسل النصية، لأننا لا نريد أن تأخذ دالة `longest` ملكية معاملاتها. راجع ["شرائح السلاسل النصية كمعاملات"][string-slices-as-parameters]<!-- ignore --> في الفصل 4 لمزيد من المناقشة حول سبب كون المعاملات التي نستخدمها في القائمة 10-19 هي تلك التي نريدها.

إذا حاولنا تنفيذ دالة `longest` كما هو موضح في القائمة 10-20، فلن يتم ترجمتها.

<Listing number="10-20" file-name="src/main.rs" caption="تنفيذ لدالة `longest` تُرجع الأطول من شريحتي سلسلة نصية لكنها لم تُترجم بعد">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}
```

</Listing>

بدلاً من ذلك، نحصل على الخطأ التالي الذي يتحدث عن فترات الحياة (lifetimes):

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}
```

يكشف نص المساعدة أن نوع الإرجاع يحتاج إلى معامل فترة حياة عامة (generic lifetime parameter) لأن Rust لا يمكنه معرفة ما إذا كان المرجع الذي يتم إرجاعه يشير إلى `x` أو `y`. في الواقع، نحن أيضًا لا نعرف، لأن كتلة `if` في جسم هذه الدالة تُرجع مرجعًا إلى `x` وكتلة `else` تُرجع مرجعًا إلى `y`!

عندما نعرّف هذه الدالة، لا نعرف القيم الفعلية التي سيتم تمريرها إلى هذه الدالة، لذا لا نعرف ما إذا كانت حالة `if` أو حالة `else` ستُنفذ. كما أننا لا نعرف فترات الحياة (lifetimes) الفعلية للمراجع التي سيتم تمريرها، لذا لا يمكننا النظر إلى النطاقات كما فعلنا في القوائم 10-17 و 10-18 لتحديد ما إذا كان المرجع الذي نرجعه سيكون دائمًا صالحًا. لا يمكن لمدقق الاستعارة تحديد ذلك أيضًا، لأنه لا يعرف كيف ترتبط فترات حياة (lifetimes) `x` و `y` بفترة حياة (lifetime) القيمة المرجعة. لإصلاح هذا الخطأ، سنضيف معاملات فترة حياة عامة (generic lifetime parameters) تحدد العلاقة بين المراجع حتى يتمكن مدقق الاستعارة من إجراء تحليله.

### صياغة تعليق فترة الحياة (lifetime)

تعليقات فترة الحياة (lifetime) لا تغير المدة التي تعيشها أي من المراجع. بل، تصف العلاقات بين فترات حياة (lifetimes) المراجع المتعددة دون التأثير على فترات الحياة (lifetimes). تمامًا كما يمكن للدوال قبول أي نوع عندما يحدد التوقيع معامل نوع عمومي (generic type parameter)، يمكن للدوال قبول المراجع بأي فترة حياة (lifetime) من خلال تحديد معامل فترة حياة عامة (generic lifetime parameter).

تعليقات فترة الحياة (lifetime) لها صياغة غير عادية قليلاً: أسماء معاملات فترة الحياة (lifetime parameters) يجب أن تبدأ بعلامة الاقتباس الفردية (`'`) وعادة ما تكون كلها أحرفًا صغيرة وقصيرة جدًا، مثل الأنواع العمومية (generic types). معظم الناس يستخدمون الاسم `'a` لأول تعليق لفترة الحياة (lifetime). نضع تعليقات معامل فترة الحياة (lifetime parameter) بعد `&` من المرجع، باستخدام مسافة لفصل التعليق عن نوع المرجع.

فيما يلي بعض الأمثلة: مرجع إلى `i32` بدون معامل فترة حياة (lifetime parameter)، مرجع إلى `i32` الذي له معامل فترة حياة (lifetime parameter) يسمى `'a`، ومرجع قابل للتعديل إلى `i32` الذي له أيضًا فترة الحياة (lifetime) `'a`.

```rust,ignore
&i32        // مرجع
&'a i32     // مرجع مع فترة حياة (lifetime) صريحة
&'a mut i32 // مرجع قابل للتعديل مع فترة حياة (lifetime) صريحة
```

تعليق فترة حياة (lifetime) واحد في حد ذاته ليس له معنى كبير، لأن التعليقات تهدف إلى إخبار Rust بكيفية ارتباط معاملات فترة الحياة العامة (generic lifetime parameters) للمراجع المتعددة ببعضها البعض. دعنا نفحص كيف ترتبط تعليقات فترة الحياة (lifetime) ببعضها البعض في سياق دالة `longest`.

### تعليقات فترة الحياة (lifetime) في توقيعات الدوال

لاستخدام تعليقات فترة الحياة (lifetime) في توقيعات الدوال، نحتاج إلى تعريف معاملات فترة الحياة العامة (generic lifetime parameters) داخل الأقواس الزاوية بين اسم الدالة وقائمة المعاملات (parameters)، تمامًا كما فعلنا مع معاملات النوع العام (generic type parameters).

نريد أن يعبر التوقيع عن القيد (bound) التالي: المرجع المرجع سيكون صالحًا طالما أن كلا المعاملين (parameters) صالحين. هذه هي العلاقة بين فترات حياة (lifetimes) المعاملات (parameters) والقيمة المرجعة. سنسمي فترة الحياة (lifetime) `'a` ثم نضيفها إلى كل مرجع، كما هو موضح في القائمة 10-21.

<Listing number="10-21" file-name="src/main.rs" caption="تعريف دالة `longest` الذي يحدد أن جميع المراجع في التوقيع يجب أن يكون لها نفس فترة الحياة `'a`">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}
```

</Listing>

يجب أن يتم ترجمة هذا الكود وإنتاج النتيجة التي نريدها عندما نستخدمه مع دالة `main` في القائمة 10-19.

التوقيع يخبر Rust الآن أنه لبعض فترة الحياة (lifetime) `'a`، تأخذ الدالة معاملين (parameters)، وكلاهما شرائح سلسلة نصية تعيش على الأقل طالما فترة الحياة (lifetime) `'a`. يخبر توقيع الدالة أيضًا Rust أن شريحة السلسلة النصية المرجعة من الدالة ستعيش على الأقل طالما فترة الحياة (lifetime) `'a`. في الممارسة، هذا يعني أن فترة حياة (lifetime) المرجع المرجع من دالة `longest` هي نفسها أصغر فترات حياة (lifetimes) القيم المشار إليها بواسطة معاملات (parameters) الدالة. هذه العلاقات هي ما نريد من Rust استخدامها عند تحليل هذا الكود.

تذكر، عندما نحدد معاملات فترة الحياة (lifetime parameters) في توقيع هذه الدالة، فإننا لا نغير فترات حياة (lifetimes) أي قيم تمر أو تُرجع. بل، نحدد أن مدقق الاستعارة يجب أن يرفض أي قيم لا تلتزم بهذه القيود (bounds). لاحظ أن دالة `longest` لا تحتاج إلى معرفة بالضبط كم من الوقت ستعيش `x` و `y`، فقط أن هناك بعض النطاق الذي يمكن استبداله بـ `'a` الذي سيحقق هذا التوقيع.

عند تعليق فترات الحياة (lifetimes) في الدوال، تنتقل التعليقات في توقيع الدالة، وليس في جسم الدالة. يمكن لـ Rust تحليل الكود داخل الدالة دون أي مساعدة. ومع ذلك، عندما تحتوي دالة على مراجع إلى أو من كود خارج تلك الدالة، يصبح من المستحيل تقريبًا على Rust معرفة فترات حياة (lifetimes) المعاملات (parameters) أو القيم المرجعة بمفرده. قد تكون فترات الحياة (lifetimes) مختلفة في كل مرة يتم استدعاء الدالة. لهذا السبب نحتاج إلى تعليق فترات الحياة (lifetimes) يدويًا.

عندما نمرر مراجع فعلية إلى `longest`، فإن فترة الحياة (lifetime) المحددة التي يتم استبدالها بـ `'a` هي جزء من نطاق `x` الذي يتداخل مع نطاق `y`. بعبارة أخرى، فترة الحياة العامة (generic lifetime) `'a` ستحصل على فترة الحياة (lifetime) المحددة التي تساوي الأصغر من فترات حياة (lifetimes) `x` و `y`. لأننا قمنا بتعليق المرجع المرجع بنفس معامل فترة الحياة (lifetime parameter) `'a`، فإن المرجع المرجع سيكون أيضًا صالحًا طول فترة الحياة (lifetime) الأصغر من `x` و `y`.

دعنا ننظر إلى كيفية تقييد (bound) تعليقات فترة الحياة (lifetime) لدالة `longest` من خلال تمرير مراجع لها فترات حياة (lifetimes) فعلية مختلفة. القائمة 10-22 هي مثال مباشر.

<Listing number="10-22" file-name="src/main.rs" caption="استخدام دالة `longest` مع مراجع إلى قيم `String` التي لها فترات حياة (lifetimes) فعلية مختلفة">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}
```

</Listing>

في هذا المثال، `string1` صالحة حتى نهاية النطاق الخارجي، و `string2` صالحة حتى نهاية النطاق الداخلي، و `result` تشير إلى شيء صالح حتى نهاية النطاق الداخلي. قم بتشغيل هذا الكود، وسترى أن مدقق الاستعارة يوافق؛ سيتم ترجمته وطباعة `The longest string is long string is long`.

بعد ذلك، دعنا نجرب مثالًا يوضح أن فترة حياة (lifetime) المرجع في `result` يجب أن تكون الفترة الأصغر من فترتي حياة (lifetimes) المعاملين (parameters). سنقوم بنقل تعريف متغير `result` خارج النطاق الداخلي لكن نترك تعيين قيمة متغير `result` داخل النطاق مع `string2`. ثم سننقل `println!` الذي يستخدم `result` خارج النطاق الداخلي، بعد انتهاء النطاق الداخلي. الكود في القائمة 10-23 لن يتم ترجمته.

<Listing number="10-23" file-name="src/main.rs" caption="محاولة استخدام `result` بعد خروج `string2` من النطاق">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}
```

</Listing>

عندما نحاول ترجمة هذا الكود، نحصل على هذا الخطأ:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}
```

يُظهر الخطأ أنه لكي تكون `result` صالحة لعبارة `println!`، يجب أن تكون `string2` صالحة حتى نهاية النطاق الخارجي. يعرف Rust ذلك لأننا قمنا بتعليق فترات حياة (lifetimes) معاملات (parameters) الدالة والقيم المرجعة باستخدام نفس معامل فترة الحياة (lifetime parameter) `'a`.

كبشر، يمكننا النظر إلى هذا الكود ونرى أن `string1` أطول من `string2` وبالتالي فإن `result` ستحتوي على مرجع إلى `string1`. لأن `string1` لم تخرج من النطاق بعد، فإن المرجع إلى `string1` سيظل صالحًا لعبارة `println!`. ومع ذلك، لا يمكن للمصرِّف رؤية أن المرجع صالح في هذه الحالة. لقد أخبرنا Rust أن فترة حياة (lifetime) المرجع المرجع من دالة `longest` هي نفسها الأصغر من فترات حياة (lifetimes) المراجع الممررة. لذلك، يرفض مدقق الاستعارة الكود في القائمة 10-23 كمحتمل أن يكون له مرجعًا غير صالح.

جرّب تصميم تجارب أخرى تختلف في القيم وفترات حياة (lifetimes) المراجع الممررة إلى دالة `longest` وكيفية استخدام المرجع المرجع. قم بوضع فرضيات حول ما إذا كانت تجاربك ستمر مدقق الاستعارة قبل الترجمة؛ ثم تحقق لترى ما إذا كنت على حق!

### التفكير من حيث فترات الحياة (lifetimes)

الطريقة التي تحتاج بها إلى تحديد معاملات فترة الحياة (lifetime parameters) تعتمد على ما تفعله دالتك. على سبيل المثال، إذا قمنا بتغيير تنفيذ (implementation) دالة `longest` لتُرجع دائمًا المعامل (parameter) الأول بدلاً من أطول شريحة سلسلة نصية، فلن نحتاج إلى تحديد فترة حياة (lifetime) على المعامل (parameter) `y`. الكود التالي سيتم ترجمته:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}
```

</Listing>

لقد حددنا معامل فترة الحياة (lifetime parameter) `'a` للمعامل (parameter) `x` ونوع الإرجاع، لكن ليس للمعامل (parameter) `y`، لأن فترة حياة (lifetime) `y` ليس لها أي علاقة بفترة حياة (lifetime) `x` أو القيمة المرجعة.

عند إرجاع مرجع من دالة، يجب أن يتطابق معامل فترة الحياة (lifetime parameter) لنوع الإرجاع مع معامل فترة الحياة (lifetime parameter) لأحد المعاملات (parameters). إذا كان المرجع المرجع _لا_ يشير إلى أحد المعاملات (parameters)، فيجب أن يشير إلى قيمة تم إنشاؤها داخل هذه الدالة. ومع ذلك، سيكون هذا مرجعًا معلقًا لأن القيمة ستخرج من النطاق في نهاية الدالة. ضع في اعتبارك محاولة التنفيذ (implementation) هذه لدالة `longest` التي لن تتم ترجمتها:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}
```

</Listing>

هنا، على الرغم من أننا حددنا معامل فترة حياة (lifetime parameter) `'a` لنوع الإرجاع، فإن هذا التنفيذ (implementation) سيفشل في الترجمة لأن قيمة فترة الحياة (lifetime) للإرجاع غير مرتبطة على الإطلاق بفترة حياة (lifetime) المعاملات (parameters). هذه هي رسالة الخطأ التي نحصل عليها:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}
```

المشكلة هي أن `result` يخرج من النطاق ويتم تنظيفه في نهاية دالة `longest`. نحاول أيضًا إرجاع مرجع إلى `result` من الدالة. لا توجد طريقة يمكننا بها تحديد معاملات فترة الحياة (lifetime parameters) التي من شأنها تغيير المرجع المعلق، ولا يسمح لنا Rust بإنشاء مرجع معلق. في هذه الحالة، أفضل حل هو إرجاع نوع بيانات مملوك بدلاً من مرجع بحيث تكون الدالة المستدعية مسؤولة بعد ذلك عن تنظيف القيمة.

في النهاية، صياغة فترة الحياة (lifetime) تتعلق بربط فترات حياة (lifetimes) معاملات (parameters) مختلفة وقيم الإرجاع للدوال. بمجرد ربطها، يكون لدى Rust معلومات كافية للسماح بعمليات آمنة للذاكرة ورفض العمليات التي قد تنشئ مؤشرات معلقة أو تنتهك سلامة الذاكرة.

### تعليقات فترة الحياة (lifetime) في تعريفات البنية

حتى الآن، عرّفنا البنى لتحتفظ بأنواع مملوكة. يمكننا تعريف البنى لتحتفظ بمراجع، لكننا في هذه الحالة نحتاج إلى إضافة تعليق فترة حياة (lifetime) على كل مرجع في تعريف البنية. القائمة 10-24 لديها بنية تسمى `ImportantExcerpt` التي تحتفظ بشريحة سلسلة نصية.

<Listing number="10-24" file-name="src/main.rs" caption="بنية تحتفظ بمرجع، تتطلب تعليق فترة حياة (lifetime)">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}
```

</Listing>

تحتوي هذه البنية على حقل واحد، `part`، الذي يحتفظ بشريحة سلسلة نصية، وهي مرجع. كما هو الحال مع أنواع البيانات العامة (generic data types)، نعلن عن اسم معامل فترة الحياة العامة (generic lifetime parameter) داخل الأقواس الزاوية بعد اسم البنية بحيث يمكننا استخدام معامل فترة الحياة (lifetime parameter) في جسم تعريف البنية. يعني هذا التعليق أن نسخة من `ImportantExcerpt` لا يمكنها أن تعيش أطول من المرجع الذي تحتفظ به في حقلها `part`.

دالة `main` هنا تنشئ نسخة من بنية `ImportantExcerpt` التي تحتفظ بمرجع إلى الجملة الأولى من `String` المملوكة بواسطة متغير `novel`. البيانات في `novel` موجودة قبل إنشاء نسخة `ImportantExcerpt`. بالإضافة إلى ذلك، `novel` لا تخرج من النطاق حتى بعد خروج `ImportantExcerpt` من النطاق، لذا فإن المرجع في نسخة `ImportantExcerpt` صالح.

### استبعاد فترة الحياة (lifetime)

لقد تعلمت أن كل مرجع له فترة حياة (lifetime) وأنك تحتاج إلى تحديد معاملات فترة الحياة (lifetime parameters) للدوال أو البنى التي تستخدم المراجع. ومع ذلك، كان لدينا دالة في القائمة 4-9، موضحة مرة أخرى في القائمة 10-25، التي تم ترجمتها دون تعليقات فترة الحياة (lifetime).

<Listing number="10-25" file-name="src/lib.rs" caption="دالة عرّفناها في القائمة 4-9 التي تم ترجمتها دون تعليقات فترة الحياة (lifetime)، على الرغم من أن المعامل (parameter) والقيمة المرجعة كلاهما مراجع">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}
```

</Listing>

السبب في أن هذه الدالة تُترجم دون تعليقات فترة الحياة (lifetime) تاريخي: في الإصدارات المبكرة (قبل 1.0) من Rust، لم يكن هذا الكود ليُترجم لأن كل مرجع كان يحتاج إلى فترة حياة (lifetime) صريحة. في ذلك الوقت، كان توقيع الدالة سيُكتب هكذا:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

بعد كتابة الكثير من كود Rust، وجد فريق Rust أن مبرمجي Rust كانوا يدخلون تعليقات فترة الحياة (lifetime) نفسها مرارًا وتكرارًا في حالات معينة. كانت هذه الحالات متوقعة وتتبع بعض الأنماط الحتمية. قام المطورون ببرمجة هذه الأنماط في كود المصرِّف بحيث يمكن لمدقق الاستعارة استنتاج فترات الحياة (lifetimes) في هذه الحالات ولا يحتاج إلى تعليقات صريحة.

يُذكر هذا الجزء من تاريخ Rust لأنه من الممكن أن تظهر المزيد من الأنماط الحتمية وتضاف إلى المصرِّف. في المستقبل، قد تكون هناك حاجة إلى عدد أقل من تعليقات فترة الحياة (lifetime).

الأنماط المبرمجة في تحليل Rust للمراجع تسمى _قواعد استبعاد فترة الحياة_ (lifetime elision rules). هذه ليست قواعد يجب على المبرمجين اتباعها؛ إنها مجموعة من الحالات الخاصة التي سينظر فيها المصرِّف، وإذا كان كودك يتناسب مع هذه الحالات، فلن تحتاج إلى كتابة فترات الحياة (lifetimes) بشكل صريح.

قواعد الاستبعاد لا توفر استنتاجًا كاملاً. إذا طبق Rust القواعد بشكل حتمي لكن لا يزال هناك غموض حول ماهية فترات حياة (lifetimes) المراجع، فلن يخمن المصرِّف ما يجب أن تكون عليه فترة حياة (lifetime) المراجع المتبقية. بدلاً من التخمين، سيعطيك المصرِّف خطأ يمكنك حله عن طريق إضافة تعليقات فترة الحياة (lifetime).

فترات الحياة (lifetimes) على معاملات (parameters) الدالة أو الدالة تسمى _فترات حياة الإدخال_ (input lifetimes)، وفترات الحياة (lifetimes) على القيم المرجعة تسمى _فترات حياة الإخراج_ (output lifetimes).

يستخدم المصرِّف ثلاث قواعد لمعرفة فترات حياة (lifetimes) المراجع عندما لا توجد تعليقات صريحة. تنطبق القاعدة الأولى على فترات حياة الإدخال (input lifetimes)، وتنطبق القاعدتان الثانية والثالثة على فترات حياة الإخراج (output lifetimes). إذا وصل المصرِّف إلى نهاية القواعد الثلاث ولا يزال هناك مراجع لا يمكنه معرفة فترات حياتها (lifetimes)، سيتوقف المصرِّف مع خطأ. تنطبق هذه القواعد على تعريفات `fn` وكذلك كتل `impl`.

القاعدة الأولى هي أن المصرِّف يعين معامل فترة حياة (lifetime parameter) لكل معامل (parameter) هو مرجع. بعبارة أخرى، دالة بمعامل (parameter) واحد تحصل على معامل فترة حياة (lifetime parameter) واحد: `fn foo<'a>(x: &'a i32)`؛ دالة بمعاملين (parameters) تحصل على معاملي فترة حياة (lifetime parameters) منفصلين: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`؛ وهكذا.

القاعدة الثانية هي أنه إذا كان هناك معامل فترة حياة إدخال (input lifetime parameter) واحد بالضبط، فإن تلك فترة الحياة (lifetime) يتم تعيينها لجميع معاملات فترة حياة الإخراج (output lifetime parameters): `fn foo<'a>(x: &'a i32) -> &'a i32`.

القاعدة الثالثة هي أنه إذا كان هناك معاملات فترة حياة إدخال (input lifetime parameters) متعددة، لكن أحدها هو `&self` أو `&mut self` لأن هذه دالة، فإن فترة حياة (lifetime) `self` يتم تعيينها لجميع معاملات فترة حياة الإخراج (output lifetime parameters). هذه القاعدة الثالثة تجعل الدوال أكثر سهولة في القراءة والكتابة لأن عددًا أقل من الرموز ضروري.

دعنا نتظاهر بأننا المصرِّف. سنطبق هذه القواعد لمعرفة فترات حياة المراجع في توقيع دالة `first_word` في القائمة 10-25. يبدأ التوقيع دون أي فترات حياة مرتبطة بالمراجع:

```rust,ignore
fn first_word(s: &str) -> &str {
```

ثم، يطبق المصرِّف القاعدة الأولى، التي تحدد أن كل معامل يحصل على فترة حياته الخاصة. سنسميها `'a` كالعادة، لذا فإن التوقيع الآن هو:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

تنطبق القاعدة الثانية لأن هناك معامل فترة حياة إدخال واحد بالضبط. تحدد القاعدة الثانية أن فترة حياة معامل الإدخال الواحد يتم تعيينها لفترة حياة الإخراج، لذا فإن التوقيع الآن هو:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

الآن جميع المراجع في توقيع هذه الدالة لها فترات حياة، ويمكن للمصرِّف متابعة تحليله دون الحاجة إلى أن يعلق المبرمج على فترات الحياة في توقيع هذه الدالة.

دعنا ننظر إلى مثال آخر، هذه المرة باستخدام دالة `longest` التي لم يكن لها معاملات فترة حياة عندما بدأنا العمل بها في القائمة 10-20:

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

دعنا نطبق القاعدة الأولى: كل معامل يحصل على فترة حياته الخاصة. هذه المرة لدينا معاملان بدلاً من واحد، لذا لدينا فترتا حياة:

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

يمكنك أن ترى أن القاعدة الثانية لا تنطبق، لأن هناك أكثر من فترة حياة إدخال واحدة. القاعدة الثالثة لا تنطبق أيضًا، لأن `longest` هي دالة بدلاً من دالة، لذا لا يوجد معامل `self`. بعد العمل من خلال القواعد الثلاث جميعها، لا نزال لم نكتشف ما هي فترة حياة نوع الإرجاع. لهذا السبب حصلنا على خطأ عند محاولة ترجمة الكود في القائمة 10-20: عمل المصرِّف من خلال قواعد استبعاد فترة الحياة لكنه لا يزال لا يمكنه معرفة جميع فترات حياة المراجع في التوقيع.

لأن القاعدة الثالثة تنطبق فقط في توقيعات الدوال، سننظر إلى فترات الحياة في هذا السياق بعد ذلك لنرى لماذا القاعدة الثالثة تعني أنه لا يتعين علينا تعليق فترات الحياة في توقيعات الدوال في كثير من الأحيان.

<!-- Old headings. Do not remove or links may break. -->

<a id="lifetime-annotations-in-method-definitions"></a>

### في تعريفات الدوال

عندما نطبق الدوال على بنية بها فترات حياة، نستخدم نفس الصياغة الخاصة بمعاملات النوع العام، كما هو موضح في القائمة 10-11. حيث نعلن ونستخدم معاملات فترة الحياة يعتمد على ما إذا كانت مرتبطة بحقول البنية أو معاملات الدالة والقيم المرجعة.

أسماء فترات الحياة لحقول البنية تحتاج دائمًا إلى التعريف بعد كلمة `impl` ثم استخدامها بعد اسم البنية لأن فترات الحياة هذه جزء من نوع البنية.

في توقيعات الدوال داخل كتلة `impl`، قد تكون المراجع مرتبطة بفترة حياة المراجع في حقول البنية، أو قد تكون مستقلة. بالإضافة إلى ذلك، غالبًا ما تجعل قواعد استبعاد فترة الحياة من غير الضروري أن تكون تعليقات فترة الحياة في توقيعات الدوال. دعنا ننظر إلى بعض الأمثلة باستخدام البنية المسماة `ImportantExcerpt` التي عرّفناها في القائمة 10-24.

أولاً، سنستخدم دالة تسمى `level` التي معاملها الوحيد هو مرجع إلى `self` وقيمتها المرجعة هي `i32`، والتي ليست مرجعًا لأي شيء:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}
```

تعريف معامل فترة الحياة بعد `impl` واستخدامه بعد اسم النوع مطلوب، ولكن بسبب قاعدة الاستبعاد الأولى، لسنا مطالبين بتعليق فترة حياة المرجع إلى `self`.

هنا مثال حيث تنطبق قاعدة استبعاد فترة الحياة الثالثة:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}
```

هناك فترتا حياة إدخال، لذا يطبق Rust قاعدة استبعاد فترة الحياة الأولى ويعطي كلاً من `&self` و `announcement` فترات حياتهما الخاصة. ثم، لأن أحد المعاملات هو `&self`، يحصل نوع الإرجاع على فترة حياة `&self`، وتم حساب جميع فترات الحياة.

### فترة الحياة الثابتة (static lifetime)

فترة حياة (lifetime) خاصة واحدة نحتاج إلى مناقشتها هي `'static`، والتي تشير إلى أن المرجع المتأثر _يمكن أن_ يعيش طوال مدة البرنامج بأكملها. جميع السلاسل النصية الحرفية لها فترة الحياة (lifetime) `'static`، والتي يمكننا تعليقها كما يلي:

```rust
let s: &'static str = "I have a static lifetime.";
```

يتم تخزين نص هذه السلسلة النصية مباشرة في ملف البرنامج الثنائي، والذي يكون متاحًا دائمًا. لذلك، فإن فترة حياة (lifetime) جميع السلاسل النصية الحرفية هي `'static`.

قد ترى اقتراحات في رسائل الخطأ لاستخدام فترة الحياة (lifetime) `'static`. ولكن قبل تحديد `'static` كفترة حياة (lifetime) للمرجع، فكر فيما إذا كان المرجع الذي لديك يعيش فعلاً طوال فترة حياة (lifetime) البرنامج بأكملها، وما إذا كنت تريد ذلك. في معظم الأحيان، تنتج رسالة خطأ تقترح فترة الحياة (lifetime) `'static` عن محاولة إنشاء مرجع معلق أو عدم تطابق فترات الحياة (lifetimes) المتاحة. في مثل هذه الحالات، الحل هو إصلاح تلك المشاكل، وليس تحديد فترة الحياة (lifetime) `'static`.

<!-- Old headings. Do not remove or links may break. -->

<a id="generic-type-parameters-trait-bounds-and-lifetimes-together"></a>

## معاملات النوع العام (generic type parameters)، قيود السمات (trait bounds)، وفترات الحياة (lifetimes)

دعنا ننظر بإيجاز إلى صياغة تحديد معاملات النوع العام (generic type parameters)، قيود السمات (trait bounds)، وفترات الحياة (lifetimes) كلها في دالة واحدة!

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
```

هذه هي دالة `longest` من القائمة 10-21 التي تُرجع الأطول من شريحتي سلسلة نصية. لكنها الآن تحتوي على معامل (parameter) إضافي يسمى `ann` من النوع العام (generic type) `T`، والذي يمكن ملؤه بأي نوع ينفذ (implementation) سمة (trait) `Display` كما هو محدد بواسطة شرط `where`. سيتم طباعة هذا المعامل (parameter) الإضافي باستخدام `{}`، ولهذا السبب يكون قيد سمة (trait bound) `Display` ضروريًا. لأن فترات الحياة (lifetimes) هي نوع من الأنواع العمومية (generic types)، تذهب تعريفات معامل فترة الحياة (lifetime parameter) `'a` ومعامل النوع العام (generic type parameter) `T` في نفس القائمة داخل الأقواس الزاوية بعد اسم الدالة.

## الخلاصة

قمنا بتغطية الكثير في هذا الفصل! الآن بعد أن تعرف عن معاملات النوع العام (generic type parameters)، والسمات (traits) وقيود السمات (trait bounds)، ومعاملات فترة الحياة العامة (generic lifetime parameters)، أنت مستعد لكتابة كود دون تكرار يعمل في العديد من المواقف المختلفة. معاملات النوع العام (generic type parameters) تتيح لك تطبيق (implementation) الكود على أنواع مختلفة. السمات (traits) وقيود السمات (trait bounds) تضمن أنه حتى مع كون الأنواع عامة (generic)، فإنها ستمتلك السلوك الذي يحتاجه الكود. لقد تعلمت كيفية استخدام تعليقات فترة الحياة (lifetime) للتأكد من أن هذا الكود المرن لن يحتوي على أي مراجع معلقة. وكل هذا التحليل يحدث في وقت الترجمة، مما لا يؤثر على أداء وقت التشغيل!

صدق أو لا تصدق، هناك الكثير لتعلمه حول المواضيع التي ناقشناها في هذا الفصل: يناقش الفصل 18 كائنات السمات (trait objects)، وهي طريقة أخرى لاستخدام السمات (traits). هناك أيضًا سيناريوهات أكثر تعقيدًا تتضمن تعليقات فترة الحياة (lifetime) التي ستحتاجها فقط في سيناريوهات متقدمة جدًا؛ لتلك، يجب عليك قراءة [مرجع Rust][reference]. ولكن بعد ذلك، ستتعلم كيفية كتابة الاختبارات في Rust حتى تتمكن من التأكد من أن كودك يعمل بالطريقة التي ينبغي أن يعمل بها.

[references-and-borrowing]: ch04-02-references-and-borrowing.html#references-and-borrowing
[string-slices-as-parameters]: ch04-03-slices.html#string-slices-as-parameters
[reference]: ../reference/trait-bounds.html
