## Rust غير الآمن (Unsafe Rust)

جميع الأكواد التي ناقشناها حتى الآن كانت لديها ضمانات أمان الذاكرة في Rust مفروضة في وقت الترجمة. ومع ذلك، لدى Rust لغة ثانية مخفية بداخلها لا تفرض ضمانات أمان الذاكرة هذه: تُسمى _unsafe Rust_ (Rust غير الآمن) وتعمل تمامًا مثل Rust العادي ولكنها تمنحنا قوى خارقة إضافية.

يوجد Rust غير الآمن لأن التحليل الثابت بطبيعته محافظ. عندما يحاول المصرِّف تحديد ما إذا كان الكود يحافظ على الضمانات أم لا، من الأفضل له رفض بعض البرامج الصحيحة بدلاً من قبول بعض البرامج غير الصحيحة. على الرغم من أن الكود _قد_ يكون صحيحًا، إذا لم يكن لدى مصرِّف Rust معلومات كافية ليكون واثقًا، فسيرفض الكود. في هذه الحالات، يمكنك استخدام الكود غير الآمن لإخبار المصرِّف، "ثق بي، أعرف ما أفعله". كن على حذر، مع ذلك، أنك تستخدم Rust غير الآمن على مسؤوليتك الخاصة: إذا استخدمت الكود غير الآمن بشكل غير صحيح، يمكن أن تحدث مشاكل بسبب عدم أمان الذاكرة، مثل إلغاء مرجعية مؤشر فارغ.

سبب آخر لوجود نسخة غير آمنة من Rust هو أن الأجهزة الحاسوبية الأساسية غير آمنة بطبيعتها. إذا لم يسمح لك Rust بإجراء عمليات غير آمنة، لن تتمكن من القيام بمهام معينة. يحتاج Rust إلى السماح لك بإجراء برمجة أنظمة منخفضة المستوى، مثل التفاعل مباشرة مع نظام التشغيل أو حتى كتابة نظام التشغيل الخاص بك. العمل مع برمجة الأنظمة منخفضة المستوى هو أحد أهداف اللغة. دعنا نستكشف ما يمكننا فعله مع Rust غير الآمن وكيفية القيام بذلك.

<!-- Old headings. Do not remove or links may break. -->

<a id="unsafe-superpowers"></a>

### تنفيذ القوى الخارقة غير الآمنة

للتبديل إلى Rust غير الآمن، استخدم الكلمة المفتاحية `unsafe` ثم ابدأ كتلة جديدة تحتوي على الكود غير الآمن (unsafe code). يمكنك اتخاذ خمسة إجراءات في Rust غير الآمن لا يمكنك القيام بها في Rust الآمن، والتي نسميها _القوى الخارقة غير الآمنة_ (unsafe superpowers). تشمل هذه القوى الخارقة القدرة على:

1. إلغاء مرجعية مؤشر خام (raw pointer).
1. استدعاء دالة أو طريقة غير آمنة (unsafe function).
1. الوصول إلى متغير ثابت قابل للتغيير أو تعديله.
1. تطبيق سِمَة غير آمنة (unsafe trait).
1. الوصول إلى حقول `union`.

من المهم أن نفهم أن `unsafe` لا يوقف فاحص الاستعارة (borrow checker) أو يعطل أي من فحوصات الأمان الأخرى في Rust: إذا استخدمت مرجعًا في كود غير آمن، فسيتم فحصه. الكلمة المفتاحية `unsafe` تمنحك فقط الوصول إلى هذه الميزات الخمس التي لا يتم فحصها بعد ذلك من قبل المصرِّف لأمان الذاكرة. ستحصل على درجة معينة من الأمان داخل كتلة غير آمنة (unsafe block).

بالإضافة إلى ذلك، `unsafe` لا يعني أن الكود داخل الكتلة خطير بالضرورة أو أنه سيواجه بالتأكيد مشاكل في أمان الذاكرة: القصد هو أنك كمبرمج، ستضمن أن الكود داخل كتلة `unsafe` سيصل إلى الذاكرة بطريقة صحيحة.

البشر قابلون للخطأ وستحدث أخطاء، ولكن بمطالبة هذه العمليات الخمس غير الآمنة بأن تكون داخل كتل موسومة بـ `unsafe`، ستعرف أن أي أخطاء تتعلق بأمان الذاكرة يجب أن تكون داخل كتلة `unsafe`. اجعل كتل `unsafe` صغيرة؛ ستكون ممتنًا لذلك لاحقًا عند التحقيق في أخطاء الذاكرة.

لعزل الكود غير الآمن قدر الإمكان، من الأفضل إحاطة هذا الكود داخل تجريد آمن وتوفير واجهة برمجة تطبيقات آمنة (API)، والتي سنناقشها لاحقًا في الفصل عندما نفحص الدوال والطرق غير الآمنة. أجزاء من المكتبة القياسية مطبقة كتجريدات آمنة على كود غير آمن تم تدقيقه. تغليف الكود غير الآمن في تجريد آمن يمنع استخدامات `unsafe` من التسرب إلى جميع الأماكن التي قد ترغب أنت أو مستخدموك في استخدام الوظيفة المطبقة بكود `unsafe`، لأن استخدام تجريد آمن آمن.

لنلقِ نظرة على كل من القوى الخارقة غير الآمنة الخمس بدورها. سننظر أيضًا إلى بعض التجريدات التي توفر واجهة آمنة للكود غير الآمن.

### إلغاء مرجعية مؤشر خام

في الفصل 4، في قسم ["المراجع المتدلية"][dangling-references]<!-- ignore -->، ذكرنا أن المصرِّف يضمن أن المراجع صحيحة دائمًا. Rust غير الآمن لديه نوعان جديدان يسميان _raw pointers_ (مؤشرات خام) يشبهان المراجع. كما هو الحال مع المراجع، يمكن أن تكون المؤشرات الخام غير قابلة للتغيير أو قابلة للتغيير وتُكتب كـ `*const T` و `*mut T`، على التوالي. العلامة النجمية ليست معامل إلغاء المرجعية؛ إنها جزء من اسم النوع. في سياق المؤشرات الخام، _غير قابل للتغيير_ يعني أنه لا يمكن تعيين المؤشر مباشرة بعد إلغاء مرجعيته.

تختلف المؤشرات الخام عن المراجع والمؤشرات الذكية في أنها:

- يُسمح لها بتجاهل قواعد الاستعارة من خلال وجود مؤشرات غير قابلة للتغيير وقابلة للتغيير أو مؤشرات قابلة للتغيير متعددة إلى نفس الموقع
- لا يُضمن أن تشير إلى ذاكرة صحيحة
- يُسمح لها بأن تكون فارغة (null)
- لا تطبق أي تنظيف تلقائي

من خلال إلغاء الاشتراك في جعل Rust يفرض هذه الضمانات، يمكنك التخلي عن الأمان المضمون مقابل أداء أكبر أو القدرة على التواصل مع لغة أخرى أو أجهزة حيث لا تنطبق ضمانات Rust.

يُظهر القائمة 20-1 كيفية إنشاء مؤشر خام غير قابل للتغيير وقابل للتغيير.

<Listing number="20-1" caption="إنشاء مؤشرات خام باستخدام معاملات الاستعارة الخام">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-01/src/main.rs:here}}
```

</Listing>

لاحظ أننا لا نضمن الكلمة المفتاحية `unsafe` في هذا الكود. يمكننا إنشاء مؤشرات خام في كود آمن؛ لا يمكننا فقط إلغاء مرجعية المؤشرات الخام خارج كتلة غير آمنة، كما سترى بعد قليل.

لقد أنشأنا مؤشرات خام باستخدام معاملات الاستعارة الخام: `&raw const num` ينشئ مؤشرًا خامًا غير قابل للتغيير `*const i32`، و `&raw mut num` ينشئ مؤشرًا خامًا قابلًا للتغيير `*mut i32`. لأننا أنشأناها مباشرة من متغير محلي، نعلم أن هذه المؤشرات الخام بالذات صحيحة، ولكن لا يمكننا عمل هذا الافتراض حول أي مؤشر خام.

لإثبات ذلك، سنقوم بعد ذلك بإنشاء مؤشر خام لا يمكننا أن نكون واثقين من صحته، باستخدام الكلمة المفتاحية `as` لتحويل قيمة بدلاً من استخدام معامل الاستعارة الخام. توضح القائمة 20-2 كيفية إنشاء مؤشر خام إلى موقع عشوائي في الذاكرة. محاولة استخدام ذاكرة عشوائية غير محددة: قد تكون هناك بيانات في هذا العنوان أو قد لا تكون، قد يحسّن المصرِّف الكود بحيث لا يكون هناك وصول إلى الذاكرة، أو قد ينتهي البرنامج بخطأ تجزئة (segmentation fault). عادةً، لا يوجد سبب وجيه لكتابة كود مثل هذا، خاصة في الحالات التي يمكنك فيها استخدام معامل استعارة خام بدلاً من ذلك، ولكنه ممكن.

<Listing number="20-2" caption="إنشاء مؤشر خام إلى عنوان ذاكرة عشوائي">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-02/src/main.rs:here}}
```

</Listing>

تذكر أنه يمكننا إنشاء مؤشرات خام في كود آمن، ولكن لا يمكننا إلغاء مرجعية المؤشرات الخام وقراءة البيانات المُشار إليها. في القائمة 20-3، نستخدم معامل إلغاء المرجعية `*` على مؤشر خام يتطلب كتلة `unsafe`.

<Listing number="20-3" caption="إلغاء مرجعية المؤشرات الخام داخل كتلة `unsafe`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-03/src/main.rs:here}}
```

</Listing>

إنشاء مؤشر لا يسبب أي ضرر؛ فقط عندما نحاول الوصول إلى القيمة التي يشير إليها قد ننتهي بالتعامل مع قيمة غير صحيحة.

لاحظ أيضًا أننا في القوائم 20-1 و 20-3، أنشأنا مؤشرات خام `*const i32` و `*mut i32` كلاهما يشير إلى نفس موقع الذاكرة، حيث يتم تخزين `num`. إذا حاولنا بدلاً من ذلك إنشاء مرجع غير قابل للتغيير وقابل للتغيير إلى `num`، لن يتم ترجمة الكود لأن قواعد الملكية في Rust لا تسمح بمرجع قابل للتغيير في نفس الوقت مع أي مراجع غير قابلة للتغيير. مع المؤشرات الخام، يمكننا إنشاء مؤشر قابل للتغيير ومؤشر غير قابل للتغيير إلى نفس الموقع وتغيير البيانات من خلال المؤشر القابل للتغيير، مما قد يؤدي إلى سباق بيانات (data race). كن حذرًا!

مع كل هذه المخاطر، لماذا تستخدم المؤشرات الخام؟ حالة استخدام رئيسية واحدة هي عند التواصل مع كود C، كما سترى في القسم التالي. حالة أخرى هي عند بناء تجريدات آمنة لا يفهمها فاحص الاستعارة. سنقدم الدوال غير الآمنة ثم ننظر في مثال لتجريد آمن يستخدم كود غير آمن.

### استدعاء دالة أو طريقة غير آمنة

النوع الثاني من العمليات التي يمكنك إجراؤها في كتلة غير آمنة هو استدعاء الدوال غير الآمنة. تبدو الدوال والطرق غير الآمنة تمامًا مثل الدوال والطرق العادية، ولكن لديها كلمة `unsafe` إضافية قبل بقية التعريف. تشير الكلمة المفتاحية `unsafe` في هذا السياق إلى أن الدالة لديها متطلبات نحتاج إلى الحفاظ عليها عند استدعاء هذه الدالة، لأن Rust لا يمكنه ضمان أننا استوفينا هذه المتطلبات. من خلال استدعاء دالة غير آمنة داخل كتلة `unsafe`، نقول أننا قرأنا وثائق هذه الدالة ونتحمل مسؤولية الحفاظ على عقود الدالة.

إليك دالة غير آمنة تسمى `dangerous` لا تفعل شيئًا في جسمها:

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}
```

يجب أن نستدعي الدالة `dangerous` داخل كتلة `unsafe` منفصلة. إذا حاولنا استدعاء `dangerous` بدون كتلة `unsafe`، سنحصل على خطأ:

```console
{{#include ../listings/ch20-advanced-features/output-only-01-missing-unsafe/output.txt}}
```

مع كتلة `unsafe`، نؤكد لـ Rust أننا قرأنا وثائق الدالة، ونفهم كيفية استخدامها بشكل صحيح، وتحققنا من أننا نفي بعقد الدالة.

لتنفيذ عمليات غير آمنة في جسم دالة `unsafe`، لا تزال بحاجة إلى استخدام كتلة `unsafe`، تمامًا كما في دالة عادية، وسيحذرك المصرِّف إذا نسيت. هذا يساعدنا في الحفاظ على كتل `unsafe` صغيرة قدر الإمكان، حيث قد لا تكون هناك حاجة لعمليات غير آمنة عبر جسم الدالة بأكمله.

#### إنشاء تجريد آمن على كود غير آمن

مجرد كون دالة تحتوي على كود غير آمن لا يعني أننا بحاجة إلى وضع علامة على الدالة بأكملها على أنها غير آمنة. في الواقع، تغليف الكود غير الآمن في دالة آمنة هو تجريد شائع. كمثال، دعنا ندرس الدالة `split_at_mut` من المكتبة القياسية، والتي تتطلب بعض الكود غير الآمن. سنستكشف كيف يمكننا تطبيقها. هذه الطريقة الآمنة معرفة على الشرائح القابلة للتغيير: تأخذ شريحة واحدة وتجعلها اثنتين بتقسيم الشريحة عند الفهرس المعطى كوسيطة. توضح القائمة 20-4 كيفية استخدام `split_at_mut`.

<Listing number="20-4" caption="استخدام الدالة الآمنة `split_at_mut`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-04/src/main.rs:here}}
```

</Listing>

لا يمكننا تطبيق هذه الدالة باستخدام Rust الآمن فقط. قد تبدو المحاولة كالقائمة 20-5، والتي لن تُترجم. للبساطة، سنطبق `split_at_mut` كدالة بدلاً من طريقة وفقط للشرائح من قيم `i32` بدلاً من نوع عمومي `T`.

<Listing number="20-5" caption="محاولة تطبيق `split_at_mut` باستخدام Rust الآمن فقط">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-05/src/main.rs:here}}
```

</Listing>

تحصل هذه الدالة أولاً على الطول الإجمالي للشريحة. ثم تؤكد أن الفهرس المعطى كمعامل ضمن الشريحة من خلال التحقق مما إذا كان أقل من أو يساوي الطول. يعني التأكيد أنه إذا مررنا فهرسًا أكبر من الطول لتقسيم الشريحة عنده، ستصاب الدالة بالذعر (panic) قبل محاولة استخدام هذا الفهرس.

ثم نعيد شريحتين قابلتين للتغيير في tuple: واحدة من بداية الشريحة الأصلية إلى فهرس `mid` وأخرى من `mid` إلى نهاية الشريحة.

عندما نحاول ترجمة الكود في القائمة 20-5، سنحصل على خطأ:

```console
{{#include ../listings/ch20-advanced-features/listing-20-05/output.txt}}
```

فاحص الاستعارة في Rust لا يستطيع فهم أننا نستعير أجزاء مختلفة من الشريحة؛ يعلم فقط أننا نستعير من نفس الشريحة مرتين. استعارة أجزاء مختلفة من شريحة صحيح بشكل أساسي لأن الشريحتين لا تتداخلان، لكن Rust ليس ذكيًا بما يكفي لمعرفة ذلك. عندما نعلم أن الكود صحيح، لكن Rust لا يعلم، حان الوقت للوصول إلى الكود غير الآمن.

توضح القائمة 20-6 كيفية استخدام كتلة `unsafe`، ومؤشر خام، وبعض الاستدعاءات للدوال غير الآمنة لجعل تطبيق `split_at_mut` يعمل.

<Listing number="20-6" caption="استخدام كود غير آمن في تطبيق الدالة `split_at_mut`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-06/src/main.rs:here}}
```

</Listing>

تذكر من قسم ["نوع الشريحة"][the-slice-type]<!-- ignore --> في الفصل 4 أن الشريحة هي مؤشر إلى بعض البيانات وطول الشريحة. نستخدم طريقة `len` للحصول على طول الشريحة وطريقة `as_mut_ptr` للوصول إلى المؤشر الخام للشريحة. في هذه الحالة، لأن لدينا شريحة قابلة للتغيير من قيم `i32`، تعيد `as_mut_ptr` مؤشرًا خامًا بنوع `*mut i32`، والذي قمنا بتخزينه في المتغير `ptr`.

نحتفظ بالتأكيد على أن فهرس `mid` ضمن الشريحة. ثم نصل إلى الكود غير الآمن: تأخذ الدالة `slice::from_raw_parts_mut` مؤشرًا خامًا وطولًا، وتنشئ شريحة. نستخدم هذه الدالة لإنشاء شريحة تبدأ من `ptr` وبطول `mid` عنصرًا. ثم نستدعي طريقة `add` على `ptr` مع `mid` كوسيطة للحصول على مؤشر خام يبدأ عند `mid`، وننشئ شريحة باستخدام ذلك المؤشر وعدد العناصر المتبقية بعد `mid` كالطول.

الدالة `slice::from_raw_parts_mut` غير آمنة لأنها تأخذ مؤشرًا خامًا ويجب أن تثق في أن هذا المؤشر صحيح. طريقة `add` على المؤشرات الخام غير آمنة أيضًا لأنها يجب أن تثق في أن موقع الإزاحة هو أيضًا مؤشر صحيح. لذلك، كان علينا وضع كتلة `unsafe` حول استدعاءاتنا لـ `slice::from_raw_parts_mut` و `add` حتى نتمكن من استدعائها. من خلال النظر إلى الكود ومن خلال إضافة التأكيد على أن `mid` يجب أن يكون أقل من أو يساوي `len`، يمكننا أن نقول أن جميع المؤشرات الخام المستخدمة داخل كتلة `unsafe` ستكون مؤشرات صحيحة للبيانات داخل الشريحة. هذا استخدام مقبول ومناسب لـ `unsafe`.

لاحظ أننا لسنا بحاجة إلى وضع علامة على دالة `split_at_mut` الناتجة بـ `unsafe`، ويمكننا استدعاء هذه الدالة من Rust الآمن. لقد أنشأنا تجريدًا آمنًا للكود غير الآمن مع تطبيق للدالة يستخدم كود `unsafe` بطريقة آمنة، لأنه ينشئ فقط مؤشرات صحيحة من البيانات التي لدى هذه الدالة وصول إليها.

في المقابل، من المحتمل أن يتعطل استخدام `slice::from_raw_parts_mut` في القائمة 20-7 عند استخدام الشريحة. يأخذ هذا الكود موقع ذاكرة عشوائي وينشئ شريحة بطول 10,000 عنصر.

<Listing number="20-7" caption="إنشاء شريحة من موقع ذاكرة عشوائي">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-07/src/main.rs:here}}
```

</Listing>

نحن لا نمتلك الذاكرة في هذا الموقع العشوائي، ولا يوجد ضمان بأن الشريحة التي ينشئها هذا الكود تحتوي على قيم `i32` صحيحة. محاولة استخدام `values` كما لو كانت شريحة صحيحة تؤدي إلى سلوك غير محدد.

#### استخدام دوال `extern` لاستدعاء كود خارجي

في بعض الأحيان، قد يحتاج كود Rust الخاص بك إلى التفاعل مع كود مكتوب بلغة أخرى. لذلك، لدى Rust الكلمة المفتاحية `extern` التي تسهل إنشاء واستخدام _واجهة دالة أجنبية_ (Foreign Function Interface أو FFI)، وهي طريقة للغة برمجة لتعريف الدوال وتمكين لغة برمجة مختلفة (أجنبية) من استدعاء تلك الدوال.

توضح القائمة 20-8 كيفية إعداد تكامل مع الدالة `abs` من مكتبة C القياسية. الدوال المعلنة داخل كتل `extern` غير آمنة للاستدعاء من كود Rust بشكل عام، لذلك يجب أن تكون كتل `extern` موسومة أيضًا بـ `unsafe`. السبب هو أن اللغات الأخرى لا تفرض قواعد وضمانات Rust، ولا يمكن لـ Rust فحصها، لذا تقع المسؤولية على المبرمج لضمان الأمان.

<Listing number="20-8" file-name="src/main.rs" caption="التصريح عن واستدعاء دالة `extern` معرفة في لغة أخرى">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-08/src/main.rs}}
```

</Listing>

داخل كتلة `unsafe extern "C"`، نسرد أسماء وتوقيعات الدوال الخارجية من لغة أخرى التي نريد استدعاءها. يحدد جزء `"C"` أي _واجهة ثنائية للتطبيق_ (application binary interface أو ABI) تستخدمها الدالة الخارجية: يحدد ABI كيفية استدعاء الدالة على مستوى الترجمة. ABI `"C"` هو الأكثر شيوعًا ويتبع ABI لغة البرمجة C. معلومات عن جميع ABIs التي يدعمها Rust متاحة في [مرجع Rust][ABI].

كل عنصر معلن داخل كتلة `unsafe extern` غير آمن ضمنيًا. ومع ذلك، بعض دوال FFI _آمنة_ للاستدعاء. على سبيل المثال، دالة `abs` من المكتبة القياسية لـ C ليس لديها أي اعتبارات لأمان الذاكرة، ونعلم أنه يمكن استدعاؤها مع أي `i32`. في حالات مثل هذه، يمكننا استخدام الكلمة المفتاحية `safe` للقول بأن هذه الدالة المحددة آمنة للاستدعاء حتى لو كانت في كتلة `unsafe extern`. بمجرد إجراء هذا التغيير، لم يعد استدعاؤها يتطلب كتلة `unsafe`، كما هو موضح في القائمة 20-9.

<Listing number="20-9" file-name="src/main.rs" caption="وضع علامة صريحة على دالة بـ `safe` داخل كتلة `unsafe extern` واستدعاءها بأمان">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-09/src/main.rs}}
```

</Listing>

وضع علامة على دالة بـ `safe` لا يجعلها آمنة بطبيعتها! بدلاً من ذلك، إنه مثل وعد تقطعه لـ Rust بأنها آمنة. لا يزال من مسؤوليتك التأكد من أن هذا الوعد يُحفظ!

#### استدعاء دوال Rust من لغات أخرى

يمكننا أيضًا استخدام `extern` لإنشاء واجهة تسمح للغات أخرى باستدعاء دوال Rust. بدلاً من إنشاء كتلة `extern` كاملة، نضيف الكلمة المفتاحية `extern` ونحدد ABI للاستخدام قبل الكلمة المفتاحية `fn` للدالة ذات الصلة. نحتاج أيضًا إلى إضافة تعليق توضيحي `#[unsafe(no_mangle)]` لإخبار مصرِّف Rust بعدم تشويش اسم هذه الدالة. _التشويش_ (Mangling) هو عندما يغير المصرِّف الاسم الذي أعطيناه لدالة إلى اسم مختلف يحتوي على مزيد من المعلومات لأجزاء أخرى من عملية الترجمة لاستهلاكها ولكنه أقل قابلية للقراءة من قبل البشر. كل مصرِّف لغة برمجة يشوش الأسماء بشكل مختلف قليلاً، لذلك لكي يمكن لدالة Rust أن تكون قابلة للتسمية من قبل اللغات الأخرى، يجب علينا تعطيل تشويش اسم مصرِّف Rust. هذا غير آمن لأنه قد تكون هناك تضاربات في الأسماء عبر المكتبات بدون التشويش المدمج، لذلك من مسؤوليتنا التأكد من أن الاسم الذي نختاره آمن للتصدير دون تشويش.

في المثال التالي، نجعل دالة `call_from_c` قابلة للوصول من كود C، بعد ترجمتها إلى مكتبة مشتركة وربطها من C:

```
#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

هذا الاستخدام لـ `extern` يتطلب `unsafe` فقط في السمة، وليس على كتلة `extern`.

### الوصول إلى متغير ثابت قابل للتغيير أو تعديله

في هذا الكتاب، لم نتحدث بعد عن المتغيرات العامة (global variables)، والتي يدعمها Rust ولكنها يمكن أن تكون إشكالية مع قواعد الملكية في Rust. إذا كان هناك خيطان (threads) يصلان إلى نفس المتغير العام القابل للتغيير، يمكن أن يتسبب ذلك في سباق بيانات.

في Rust، تُسمى المتغيرات العامة _static_ (متغيرات ثابتة). توضح القائمة 20-10 مثالاً على التصريح عن واستخدام متغير ثابت مع شريحة سلسلة كقيمة.

<Listing number="20-10" file-name="src/main.rs" caption="تعريف واستخدام متغير ثابت غير قابل للتغيير">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-10/src/main.rs}}
```

</Listing>

المتغيرات الثابتة مشابهة للثوابت، والتي ناقشناها في قسم ["التصريح عن الثوابت"][constants]<!-- ignore --> في الفصل 3. أسماء المتغيرات الثابتة في `SCREAMING_SNAKE_CASE` بالاتفاق. يمكن للمتغيرات الثابتة تخزين مراجع فقط مع مدة الصلاحية `'static`، مما يعني أن مصرِّف Rust يمكنه معرفة مدة الصلاحية ولسنا مطالبين بالتعليق عليها صراحة. الوصول إلى متغير ثابت غير قابل للتغيير آمن.

الفرق الدقيق بين الثوابت والمتغيرات الثابتة غير القابلة للتغيير هو أن القيم في متغير ثابت لها عنوان ثابت في الذاكرة. استخدام القيمة سيصل دائمًا إلى نفس البيانات. من ناحية أخرى، يُسمح للثوابت بتكرار بياناتها كلما تم استخدامها. فرق آخر هو أن المتغيرات الثابتة يمكن أن تكون قابلة للتغيير. الوصول إلى وتعديل المتغيرات الثابتة القابلة للتغيير _غير آمن_. توضح القائمة 20-11 كيفية التصريح عن والوصول إلى وتعديل متغير ثابت قابل للتغيير يُسمى `COUNTER`.

<Listing number="20-11" file-name="src/main.rs" caption="القراءة من أو الكتابة إلى متغير ثابت قابل للتغيير غير آمنة.">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-11/src/main.rs}}
```

</Listing>

كما هو الحال مع المتغيرات العادية، نحدد القابلية للتغيير باستخدام الكلمة المفتاحية `mut`. يجب أن يكون أي كود يقرأ من أو يكتب إلى `COUNTER` داخل كتلة `unsafe`. يُترجم الكود في القائمة 20-11 ويطبع `COUNTER: 3` كما نتوقع لأنه أحادي الخيط. وجود خيوط متعددة تصل إلى `COUNTER` من المحتمل أن يؤدي إلى سباقات بيانات، لذلك هو سلوك غير محدد. لذلك، نحتاج إلى وضع علامة على الدالة بأكملها بـ `unsafe` وتوثيق قيد الأمان حتى يعرف أي شخص يستدعي الدالة ما يُسمح وما لا يُسمح به القيام به بأمان.

كلما كتبنا دالة غير آمنة، من المعتاد كتابة تعليق يبدأ بـ `SAFETY` ويشرح ما يحتاج المتصل إلى فعله لاستدعاء الدالة بأمان. بالمثل، كلما نفذنا عملية غير آمنة، من المعتاد كتابة تعليق يبدأ بـ `SAFETY` لشرح كيف يتم الحفاظ على قواعد الأمان.

بالإضافة إلى ذلك، سيرفض المصرِّف افتراضيًا أي محاولة لإنشاء مراجع لمتغير ثابت قابل للتغيير من خلال فحص المصرِّف (lint). يجب عليك إما إلغاء الاشتراك صراحة من حمايات ذلك الفحص بإضافة تعليق توضيحي `#[allow(static_mut_refs)]` أو الوصول إلى المتغير الثابت القابل للتغيير عبر مؤشر خام تم إنشاؤه باستخدام أحد معاملات الاستعارة الخام. يتضمن ذلك الحالات التي يتم فيها إنشاء المرجع بشكل غير مرئي، كما هو الحال عند استخدامه في `println!` في هذه القائمة. يساعد طلب إنشاء مراجع لمتغيرات ثابتة قابلة للتغيير عبر مؤشرات خام في جعل متطلبات الأمان لاستخدامها أكثر وضوحًا.

مع البيانات القابلة للتغيير التي يمكن الوصول إليها عالميًا، من الصعب ضمان عدم وجود سباقات بيانات، وهذا هو السبب في أن Rust يعتبر المتغيرات الثابتة القابلة للتغيير غير آمنة. حيثما أمكن، من الأفضل استخدام تقنيات التزامن والمؤشرات الذكية الآمنة للخيوط التي ناقشناها في الفصل 16 بحيث يفحص المصرِّف أن الوصول إلى البيانات من خيوط مختلفة يتم بشكل آمن.

### تطبيق سِمَة غير آمنة

يمكننا استخدام `unsafe` لتطبيق سِمَة غير آمنة. السِمَة غير آمنة عندما يكون لدى واحدة على الأقل من طرقها بعض الثوابت التي لا يستطيع المصرِّف التحقق منها. نعلن أن السِمَة `unsafe` بإضافة الكلمة المفتاحية `unsafe` قبل `trait` ووضع علامة على تطبيق السِمَة بـ `unsafe` أيضًا، كما هو موضح في القائمة 20-12.

<Listing number="20-12" caption="تعريف وتطبيق سِمَة غير آمنة">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-12/src/main.rs:here}}
```

</Listing>

باستخدام `unsafe impl`، نعد بأننا سنحافظ على الثوابت التي لا يستطيع المصرِّف التحقق منها.

كمثال، تذكر سِمَتي التعليم `Send` و `Sync` اللتين ناقشناهما في قسم ["التزامن القابل للتوسيع مع `Send` و `Sync`"][send-and-sync]<!-- ignore --> في الفصل 16: ينفذ المصرِّف هاتين السِمَتين تلقائيًا إذا كانت أنواعنا مكونة بالكامل من أنواع أخرى تنفذ `Send` و `Sync`. إذا نفذنا نوعًا يحتوي على نوع لا ينفذ `Send` أو `Sync`، مثل المؤشرات الخام، ونريد وضع علامة على هذا النوع بـ `Send` أو `Sync`، يجب علينا استخدام `unsafe`. لا يستطيع Rust التحقق من أن نوعنا يحافظ على الضمانات بأنه يمكن إرساله بأمان عبر الخيوط أو الوصول إليه من خيوط متعددة؛ لذلك، نحتاج إلى إجراء تلك الفحوصات يدويًا والإشارة إلى ذلك بـ `unsafe`.

### الوصول إلى حقول union

الإجراء النهائي الذي يعمل فقط مع `unsafe` هو الوصول إلى حقول union. _union_ مشابه لـ `struct`، ولكن يُستخدم حقل واحد فقط معلن في نسخة معينة في وقت واحد. تُستخدم الاتحادات بشكل أساسي للتواصل مع الاتحادات في كود C. الوصول إلى حقول الاتحاد غير آمن لأن Rust لا يمكنه ضمان نوع البيانات المخزنة حاليًا في نسخة الاتحاد. يمكنك معرفة المزيد عن الاتحادات في [مرجع Rust][unions].

### استخدام Miri للتحقق من الكود غير الآمن

عند كتابة كود غير آمن، قد ترغب في التحقق من أن ما كتبته آمن وصحيح فعلاً. إحدى أفضل الطرق للقيام بذلك هي استخدام Miri، وهي أداة Rust رسمية لاكتشاف السلوك غير المحدد. في حين أن فاحص الاستعارة هو أداة _ثابتة_ تعمل في وقت الترجمة، فإن Miri هي أداة _ديناميكية_ تعمل في وقت التشغيل. تفحص كودك من خلال تشغيل برنامجك، أو مجموعة الاختبارات الخاصة به، وتكتشف متى تنتهك القواعد التي تفهمها حول كيفية عمل Rust.

يتطلب استخدام Miri إصدارًا ليليًا (nightly) من Rust (الذي نتحدث عنه أكثر في [الملحق G: كيف يتم إنشاء Rust و"Nightly Rust"][nightly]<!-- ignore -->). يمكنك تثبيت كل من الإصدار الليلي من Rust وأداة Miri بكتابة `rustup +nightly component add miri`. هذا لا يغير إصدار Rust الذي يستخدمه مشروعك؛ بل يضيف الأداة فقط إلى نظامك حتى تتمكن من استخدامها عندما تريد. يمكنك تشغيل Miri على مشروع بكتابة `cargo +nightly miri run` أو `cargo +nightly miri test`.

لمثال على مدى فائدة ذلك، ضع في الاعتبار ما يحدث عندما نشغله على القائمة 20-7.

```console
{{#include ../listings/ch20-advanced-features/listing-20-07/output.txt}}
```

يحذرنا Miri بشكل صحيح من أننا نقوم بتحويل عدد صحيح إلى مؤشر، والذي قد يكون مشكلة، لكن Miri لا يمكنه تحديد ما إذا كانت هناك مشكلة لأنه لا يعرف كيف نشأ المؤشر. ثم يعيد Miri خطأً حيث تحتوي القائمة 20-7 على سلوك غير محدد لأن لدينا مؤشر متدلي (dangling pointer). بفضل Miri، نعلم الآن أن هناك خطرًا من السلوك غير المحدد، ويمكننا التفكير في كيفية جعل الكود آمنًا. في بعض الحالات، يمكن لـ Miri حتى تقديم توصيات حول كيفية إصلاح الأخطاء.

لا يلتقط Miri كل ما قد تخطئ فيه عند كتابة كود غير آمن. Miri هي أداة تحليل ديناميكي، لذلك تلتقط فقط المشاكل مع الكود الذي يتم تشغيله فعلاً. هذا يعني أنك ستحتاج إلى استخدامها مع تقنيات اختبار جيدة لزيادة ثقتك في الكود غير الآمن الذي كتبته. أيضًا لا يغطي Miri كل طريقة ممكنة لأن يكون كودك غير سليم.

بطريقة أخرى: إذا _اكتشف_ Miri مشكلة، فأنت تعلم أن هناك خطأ، ولكن لمجرد أن Miri _لم يكتشف_ خطأً لا يعني أنه لا توجد مشكلة. يمكنه اكتشاف الكثير، مع ذلك. حاول تشغيله على الأمثلة الأخرى للكود غير الآمن في هذا الفصل وانظر ما يقوله!

يمكنك معرفة المزيد عن Miri في [مستودع GitHub الخاص به][miri].

<!-- Old headings. Do not remove or links may break. -->

<a id="when-to-use-unsafe-code"></a>

### استخدام الكود غير الآمن بشكل صحيح

استخدام `unsafe` لاستخدام أحد القوى الخارقة الخمس المذكورة للتو ليس خطأ أو حتى مستهجنًا، ولكن من الأصعب الحصول على كود `unsafe` صحيح لأن المصرِّف لا يستطيع المساعدة في الحفاظ على أمان الذاكرة. عندما يكون لديك سبب لاستخدام كود `unsafe`، يمكنك القيام بذلك، ووجود تعليق توضيحي `unsafe` صريح يجعل من الأسهل تتبع مصدر المشاكل عند حدوثها. كلما كتبت كود غير آمن، يمكنك استخدام Miri لمساعدتك على أن تكون أكثر ثقة في أن الكود الذي كتبته يحافظ على قواعد Rust.

لاستكشاف أعمق بكثير لكيفية العمل بفعالية مع Rust غير الآمن، اقرأ دليل Rust الرسمي لـ `unsafe`، [The Rustonomicon][nomicon].

[dangling-references]: ch04-02-references-and-borrowing.html#dangling-references
[ABI]: ../reference/items/external-blocks.html#abi
[constants]: ch03-01-variables-and-mutability.html#declaring-constants
[send-and-sync]: ch16-04-extensible-concurrency-sync-and-send.html
[the-slice-type]: ch04-03-slices.html#the-slice-type
[unions]: ../reference/items/unions.html
[miri]: https://github.com/rust-lang/miri
[editions]: appendix-05-editions.html
[nightly]: appendix-07-nightly-rust.html
[nomicon]: https://doc.rust-lang.org/nomicon/
