## چگونه تست بنویسیم

تست‌ها توابعی در Rust هستند که بررسی می‌کنند کد غیرتستی به شکل مورد انتظار کار می‌کند. بدنه توابع تست معمولاً این سه عمل را انجام می‌دهد:

- تنظیم هر داده یا وضعیت مورد نیاز.
- اجرای کدی که می‌خواهید تست کنید.
- تأیید اینکه نتایج همان چیزی است که انتظار دارید.

بیایید به ویژگی‌هایی که Rust به طور خاص برای نوشتن تست‌هایی که این اقدامات را انجام می‌دهند فراهم کرده است نگاهی بیندازیم. این ویژگی‌ها شامل ویژگی `test`، چند ماکرو و ویژگی `should_panic` هستند.

### آناتومی یک تابع تست

در ساده‌ترین حالت، یک تست در Rust یک تابع است که با ویژگی `test` حاشیه‌نویسی شده است. ویژگی‌ها متاداده‌هایی درباره بخش‌های کد Rust هستند؛ یک مثال ویژگی `derive` است که در فصل ۵ با ساختارها استفاده کردیم. برای تغییر یک تابع به یک تابع تست، `#[test]` را به خط قبل از `fn` اضافه کنید. وقتی تست‌های خود را با فرمان `cargo test` اجرا می‌کنید، Rust یک باینری تست رانر ایجاد می‌کند که توابع حاشیه‌نویسی‌شده را اجرا می‌کند و گزارش می‌دهد که آیا هر تابع تست موفق یا ناموفق بوده است.

هر زمان که یک پروژه کتابخانه‌ای جدید با Cargo ایجاد می‌کنیم، یک ماژول تست با یک تابع تست در آن به صورت خودکار برای ما تولید می‌شود. این ماژول یک قالب برای نوشتن تست‌های شما فراهم می‌کند تا نیازی به جستجوی ساختار و نحو دقیق هر بار که یک پروژه جدید شروع می‌کنید نداشته باشید. می‌توانید هر تعداد تابع تست اضافی و هر تعداد ماژول تست اضافی که می‌خواهید اضافه کنید!

ما برخی از جنبه‌های نحوه عملکرد تست‌ها را با آزمایش قالب تست قبل از اینکه واقعاً کدی را تست کنیم بررسی خواهیم کرد. سپس تست‌هایی در دنیای واقعی می‌نویسیم که برخی کدهایی که نوشته‌ایم را فراخوانی می‌کنند و تأیید می‌کنند که رفتار آن صحیح است.

بیایید یک پروژه کتابخانه‌ای جدید به نام `adder` ایجاد کنیم که دو عدد را با هم جمع کند:

```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

محتویات فایل _src/lib.rs_ در کتابخانه `adder` شما باید شبیه به لیست ۱۱-۱ باشد.

<Listing number="11-1" file-name="src/lib.rs" caption="کدی که به طور خودکار توسط `cargo new` تولید می‌شود">

<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

</Listing>


این فایل با یک تابع نمونه به نام `add` شروع می‌شود تا چیزی برای تست کردن داشته باشیم.

فعلاً روی تابع `it_works` تمرکز می‌کنیم. به حاشیه‌نویسی `#[test]` توجه کنید: این ویژگی نشان می‌دهد که این یک تابع تست است، بنابراین تست رانر می‌داند که این تابع را به عنوان یک تست در نظر بگیرد. ممکن است توابع غیرتستی نیز در ماژول `tests` داشته باشیم که به تنظیم سناریوهای مشترک یا انجام عملیات‌های مشترک کمک می‌کنند، بنابراین همیشه باید مشخص کنیم کدام توابع تست هستند.

بدنه تابع نمونه از ماکرو `assert_eq!` استفاده می‌کند تا اطمینان حاصل کند که `result`، که حاوی نتیجه فراخوانی `add` با مقادیر ۲ و ۲ است، برابر با ۴ باشد. این اطمینان به عنوان یک مثال از فرمت یک تست معمولی عمل می‌کند. بیایید آن را اجرا کنیم تا ببینیم این تست پاس می‌شود.

فرمان `cargo test` تمام تست‌های پروژه ما را اجرا می‌کند، همانطور که در لیست ۱۱-۲ نشان داده شده است.

<Listing number="11-2" caption="خروجی اجرای تستی که به طور خودکار تولید شده است">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}
```

</Listing>

Cargo تست را کامپایل و اجرا کرد. خط `running 1 test` را می‌بینیم. خط بعدی نام تابع تست تولیدشده را نشان می‌دهد، که `tests::it_works` نام دارد، و نتیجه اجرای آن تست `ok` است. خلاصه کلی `test result: ok.` نشان می‌دهد که تمام تست‌ها پاس شده‌اند، و بخشی که `1 passed; 0 failed` را می‌خواند تعداد تست‌هایی که پاس شده‌اند یا ناموفق بوده‌اند را نشان می‌دهد.

امکان علامت‌گذاری یک تست به‌عنوان ignored وجود دارد تا در یک اجرای خاص اجرا نشود؛  
ما این موضوع را در بخش [“نادیده گرفتن برخی تست‌ها مگر در صورت درخواست خاص”][ignoring]<!-- ignore -->  
در ادامه‌ی این فصل بررسی خواهیم کرد.  
چون در اینجا این کار را انجام نداده‌ایم، خلاصه نشان‌دهنده‌ی `0 ignored` است.  
همچنین می‌توانیم آرگومانی به دستور `cargo test` بدهیم تا فقط تست‌هایی اجرا شوند که نامشان با رشته‌ای مطابقت دارد؛  
این کار _filtering_ نامیده می‌شود و در بخش [“اجرای زیرمجموعه‌ای از تست‌ها بر اساس نام”][subset]<!-- ignore --> بررسی خواهد شد.  
در اینجا تست‌ها فیلتر نشده‌اند، بنابراین انتهای خلاصه `0 filtered out` را نشان می‌دهد.

آمار `0 measured` برای تست‌های بنچمارک است که عملکرد را اندازه‌گیری می‌کنند. تست‌های بنچمارک، در زمان نوشتن این متن، فقط در نسخه شبانه Rust موجود هستند. برای اطلاعات بیشتر مستندات مربوط به [تست‌های بنچمارک][bench] را ببینید.

قسمت بعدی خروجی تست که از `Doc-tests adder` شروع می‌شود، مربوط به نتایج تست‌های مستندات است.
فعلاً تست مستنداتی نداریم، اما Rust می‌تواند هر نمونه کدی که در مستندات API ما آمده است را کامپایل کند.
این ویژگی به هماهنگ نگه‌داشتن مستندات و کد شما کمک می‌کند!
در بخش [“نظرات مستندات به‌عنوان تست”][doc-comments]<!-- ignore --> در فصل ۱۴، نحوه‌ی نوشتن تست‌های مستندات را بررسی خواهیم کرد.
فعلاً خروجی `Doc-tests` را نادیده می‌گیریم.

بیایید تست را مطابق نیازهای خود شخصی‌سازی کنیم. ابتدا نام تابع `it_works` را به یک نام دیگر، مانند `exploration` تغییر دهید، به این صورت:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}
```

سپس دوباره `cargo test` را اجرا کنید. خروجی اکنون به جای `it_works` نام `exploration` را نشان می‌دهد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}
```

حالا یک تست دیگر اضافه می‌کنیم، اما این بار تستی می‌نویسیم که شکست بخورد! تست‌ها زمانی شکست می‌خورند که چیزی در تابع تست باعث ایجاد panic شود. هر تست در یک نخ (thread) جدید اجرا می‌شود، و وقتی نخ اصلی می‌بیند که یک نخ تست متوقف شده است، تست به عنوان شکست‌خورده علامت‌گذاری می‌شود. در فصل ۹، درباره اینکه ساده‌ترین راه برای panic کردن فراخوانی ماکروی `panic!` است صحبت کردیم. تابع جدیدی به نام `another` وارد کنید تا فایل _src/lib.rs_ شما شبیه به لیست ۱۱-۳ شود.

<Listing number="11-3" file-name="src/lib.rs" caption="اضافه کردن یک تست دوم که به دلیل فراخوانی ماکروی `panic!` شکست می‌خورد">

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs}}
```

</Listing>

دوباره تست‌ها را با استفاده از `cargo test` اجرا کنید. خروجی باید شبیه به لیست ۱۱-۴ باشد، که نشان می‌دهد تست `exploration` موفق شده است و `another` شکست خورده است.

<Listing number="11-4" caption="نتایج تست زمانی که یک تست موفق می‌شود و یک تست شکست می‌خورد">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}
```

</Listing>

به جای `ok`، در خط `test tests::another` عبارت `FAILED` نمایش داده می‌شود.
دو بخش جدید بین نتایج فردی و خلاصه ظاهر می‌شوند:
اولی دلیل دقیق هر شکست تست را نمایش می‌دهد.
در این مورد، جزئیات نشان می‌دهد که `tests::another` شکست خورده زیرا در خط ۱۷ فایل *src/lib.rs*
با پیام `Make this test fail` دچار panic شده است.
بخش بعدی فقط نام تمام تست‌های شکست‌خورده را فهرست می‌کند،
که وقتی تعداد تست‌ها زیاد و خروجی شکست تست‌ها مفصل است، مفید است.
می‌توانیم از نام تست شکست‌خورده استفاده کنیم تا فقط آن تست را اجرا کنیم و راحت‌تر آن را اشکال‌زدایی کنیم؛
در بخش [“کنترل نحوه‌ی اجرای تست‌ها”][controlling-how-tests-are-run]<!-- ignore --> بیشتر درباره‌ی روش‌های اجرای تست صحبت خواهیم کرد.

حالا که دیدید نتایج تست در سناریوهای مختلف چگونه به نظر می‌رسند، بیایید به برخی از ماکروهای دیگر به جز `panic!` که در تست‌ها مفید هستند نگاهی بیندازیم.

### بررسی نتایج با ماکروی `assert!`

ماکروی `assert!` که توسط کتابخانه استاندارد ارائه شده است، زمانی مفید است که بخواهید اطمینان حاصل کنید که یک شرط در یک تست به `true` ارزیابی می‌شود. ماکروی `assert!` یک آرگومان می‌گیرد که به یک مقدار بولی ارزیابی می‌شود. اگر مقدار `true` باشد، هیچ اتفاقی نمی‌افتد و تست پاس می‌شود. اگر مقدار `false` باشد، ماکروی `assert!` فراخوانی `panic!` را انجام می‌دهد تا باعث شکست تست شود. استفاده از ماکروی `assert!` به ما کمک می‌کند تا بررسی کنیم که کد ما همانطور که قصد داریم عمل می‌کند.

در فصل ۵، لیست ۵-۱۵، از یک ساختار `Rectangle` و یک متد `can_hold` استفاده کردیم، که در لیست ۱۱-۵ دوباره تکرار شده است. این کد را در فایل _src/lib.rs_ قرار دهید، سپس با استفاده از ماکروی `assert!` چند تست برای آن بنویسید.

<Listing number="11-5" file-name="src/lib.rs" caption="ساختار `Rectangle` و متد `can_hold` آن از فصل ۵">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs}}
```

</Listing>

متد `can_hold` یک مقدار بولی بازمی‌گرداند، که به این معنی است که یک مورد استفاده عالی برای ماکروی `assert!` است. در لیست ۱۱-۶، ما تستی می‌نویسیم که متد `can_hold` را با ایجاد یک نمونه از `Rectangle` که عرض ۸ و ارتفاع ۷ دارد آزمایش می‌کند و تأیید می‌کند که می‌تواند نمونه دیگری از `Rectangle` که عرض ۵ و ارتفاع ۱ دارد را در خود جای دهد.

<Listing number="11-6" file-name="src/lib.rs" caption="تستی برای `can_hold` که بررسی می‌کند آیا یک مستطیل بزرگ‌تر می‌تواند واقعاً یک مستطیل کوچک‌تر را در خود جای دهد">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}
```

</Listing>

به خط `use super::*;` در داخل ماژول `tests` توجه کنید. ماژول `tests` یک ماژول معمولی است که از قوانین دیدپذیری معمولی که در فصل ۷ در بخش [“مسیرها برای اشاره به یک مورد در درخت ماژول”][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore --> پوشش دادیم پیروی می‌کند. از آنجا که ماژول `tests` یک ماژول داخلی است، باید کدی که در ماژول خارجی است را به دامنه ماژول داخلی بیاوریم. در اینجا از یک glob استفاده می‌کنیم، بنابراین هر چیزی که در ماژول خارجی تعریف کنیم برای این ماژول `tests` در دسترس است.

تست خود را `larger_can_hold_smaller` نام‌گذاری کرده‌ایم، و دو نمونه `Rectangle` که نیاز داشتیم را ایجاد کرده‌ایم. سپس ماکروی `assert!` را فراخوانی کردیم و نتیجه فراخوانی `larger.can_hold(&smaller)` را به آن پاس دادیم. این عبارت قرار است `true` بازگرداند، بنابراین تست ما باید پاس شود. بیایید ببینیم چه اتفاقی می‌افتد!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}
```

پاس شد! حالا یک تست دیگر اضافه کنیم، این بار تأیید می‌کنیم که یک مستطیل کوچک‌تر نمی‌تواند یک مستطیل بزرگ‌تر را در خود جای دهد:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}
```

از آنجا که نتیجه صحیح تابع `can_hold` در این مورد `false` است، باید آن نتیجه را قبل از پاس دادن به ماکروی `assert!` منفی کنیم. به این ترتیب، تست ما زمانی پاس می‌شود که `can_hold` مقدار `false` را بازگرداند:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}
```

دو تست که پاس می‌شوند! حالا بیایید ببینیم وقتی باگی به کد خود وارد می‌کنیم چه اتفاقی برای نتایج تست ما می‌افتد. پیاده‌سازی متد `can_hold` را با جایگزینی علامت بزرگتر (`>`) با علامت کوچکتر (`<`) هنگام مقایسه عرض‌ها تغییر می‌دهیم:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}
```

اجرای تست‌ها اکنون خروجی زیر را تولید می‌کند:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}
```

تست‌های ما باگ را پیدا کردند! از آنجا که `larger.width` مقدار `8` و `smaller.width` مقدار `5` دارد، مقایسه عرض‌ها در `can_hold` اکنون `false` بازمی‌گرداند: ۸ کمتر از ۵ نیست.

### تست برابری با ماکروهای `assert_eq!` و `assert_ne!`

یک روش معمول برای بررسی عملکرد، تست برابری بین نتیجه کد تحت تست و مقدار مورد انتظار است. می‌توانید این کار را با استفاده از ماکروی `assert!` و پاس دادن یک عبارت با استفاده از عملگر `==` انجام دهید. با این حال، این یک تست بسیار معمول است که کتابخانه استاندارد یک جفت ماکرو—`assert_eq!` و `assert_ne!`—برای انجام این تست به صورت راحت‌تر فراهم کرده است. این ماکروها به ترتیب دو آرگومان را برای برابری یا نابرابری مقایسه می‌کنند. اگر ادعا شکست بخورد، این ماکروها دو مقدار را نیز چاپ می‌کنند، که مشاهده دلیل شکست تست را آسان‌تر می‌کند. در مقابل، ماکروی `assert!` فقط نشان می‌دهد که یک مقدار `false` برای عبارت `==` دریافت کرده است، بدون چاپ مقادیری که منجر به مقدار `false` شده‌اند.

در لیست ۱۱-۷، تابعی به نام `add_two` می‌نویسیم که `۲` را به پارامتر خود اضافه می‌کند، سپس این تابع را با استفاده از ماکروی `assert_eq!` تست می‌کنیم.

<Listing number="11-7" file-name="src/lib.rs" caption="تست تابع `add_two` با استفاده از ماکروی `assert_eq!`">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}
```

</Listing>

بیایید بررسی کنیم که آیا پاس می‌شود!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}
```

ما متغیری به نام `result` ایجاد می‌کنیم که نتیجه‌ی فراخوانی `add_two(2)` را نگه می‌دارد.
سپس `result` و عدد `4` را به‌عنوان آرگومان به ماکروی `assert_eq!` می‌دهیم.
خط خروجی این تست به شکل `test tests::it_adds_two ... ok` است،
و متن `ok` نشان می‌دهد که تست ما با موفقیت گذشت!

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}
```

تست‌ها را دوباره اجرا کنید:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}
```

تست ما باگ را پیدا کرد! تست `tests::it_adds_two` شکست خورد،
و پیام نشان می‌دهد که ادعای ناموفق `left == right` بوده است و مقدارهای `left` و `right` چیستند.
این پیام به ما کمک می‌کند تا فرآیند اشکال‌زدایی را شروع کنیم:
آرگومان `left` که نتیجه‌ی فراخوانی `add_two(2)` بود، مقدار `5` داشت،
اما آرگومان `right` مقدار `4` بود.
می‌توانید تصور کنید که این موضوع زمانی که تعداد زیادی تست اجرا می‌شود، چقدر مفید است.

توجه کنید که در برخی زبان‌ها و فریم‌ورک‌های تست، پارامترهای تابع ادعای برابری (assertion)
به نام‌های `expected` و `actual` شناخته می‌شوند و ترتیب آرگومان‌ها اهمیت دارد.
اما در Rust، این پارامترها `left` و `right` نامیده می‌شوند و ترتیب مقدار مورد انتظار و مقدار تولید شده توسط کد اهمیت ندارد.
می‌توانیم ادعای این تست را به صورت `assert_eq!(4, result)` نیز بنویسیم،
که نتیجه‌ی همان پیام شکست با عنوان `` assertion `left == right` failed`` را خواهد داشت.

ماکروی `assert_ne!` زمانی پاس می‌شود که دو مقداری که به آن می‌دهیم برابر نباشند و شکست می‌خورد اگر برابر باشند. این ماکرو برای مواردی مفید است که مطمئن نیستیم یک مقدار _چه خواهد بود_، اما می‌دانیم که مقدار به طور قطع _چه نباید باشد_. برای مثال، اگر تابعی را تست می‌کنیم که تضمین شده است ورودی خود را به نوعی تغییر دهد، اما نحوه تغییر ورودی به روز هفته‌ای که تست‌های خود را اجرا می‌کنیم بستگی دارد، بهترین چیزی که می‌توانیم تأیید کنیم این است که خروجی تابع برابر با ورودی نیست.

در پس‌زمینه، ماکروهای `assert_eq!` و `assert_ne!` به ترتیب از عملگرهای `==` و `!=` استفاده می‌کنند. وقتی ادعا شکست می‌خورد، این ماکروها آرگومان‌های خود را با استفاده از قالب‌بندی دیباگ چاپ می‌کنند، که به این معنی است که مقادیر مقایسه‌شده باید ویژگی‌های `PartialEq` و `Debug` را پیاده‌سازی کنند. تمام نوع‌های اولیه و بیشتر نوع‌های کتابخانه استاندارد این ویژگی‌ها را پیاده‌سازی می‌کنند. برای ساختارها و انوم‌هایی که خودتان تعریف می‌کنید، باید `PartialEq` را برای تأیید برابری این نوع‌ها پیاده‌سازی کنید. همچنین باید `Debug` را برای چاپ مقادیر زمانی که ادعا شکست می‌خورد پیاده‌سازی کنید. از آنجا که هر دو ویژگی قابل اشتقاق هستند، همانطور که در لیست ۵-۱۲ فصل ۵ اشاره شد، این معمولاً به سادگی افزودن حاشیه‌نویسی `#[derive(PartialEq, Debug)]` به تعریف ساختار یا انوم شما است. برای جزئیات بیشتر در مورد این ویژگی‌ها و سایر ویژگی‌های قابل اشتقاق، به ضمیمه ج، [“ویژگی‌های قابل اشتقاق”][derivable-traits]<!-- ignore --> مراجعه کنید.

### افزودن پیام‌های شکست سفارشی

شما همچنین می‌توانید یک پیام سفارشی را به‌عنوان آرگومان‌های اختیاری به ماکروهای `assert!`، `assert_eq!` و `assert_ne!` اضافه کنید تا همراه با پیام شکست چاپ شود.
هر آرگومانی که پس از آرگومان‌های ضروری وارد شود، به ماکرو `format!` (که در بخش [“ادغام با عملگر `+` یا ماکرو `format!`”][concatenation-with-the--operator-or-the-format-macro]<!-- ignore --> در فصل ۸ توضیح داده شده) ارسال می‌شود،
پس می‌توانید یک رشته‌ی قالب (format string) حاوی جای‌نگهدارهای `{}` و مقادیری برای جای‌گذاری در آن‌ها ارسال کنید.
پیام‌های سفارشی برای مستندسازی معنای یک assertion مفید هستند؛
وقتی تست شکست می‌خورد، درک بهتری از مشکل کد خواهید داشت.

برای مثال، فرض کنید تابعی داریم که افراد را با نامشان خوشامد می‌گوید و می‌خواهیم تست کنیم که نامی که به تابع پاس می‌دهیم در خروجی ظاهر می‌شود:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}
```

نیازمندی‌های این برنامه هنوز مورد توافق قرار نگرفته‌اند، و ما تقریباً مطمئن هستیم که متن `Hello` در ابتدای پیام خوشامد تغییر خواهد کرد. تصمیم گرفتیم که نمی‌خواهیم وقتی نیازمندی‌ها تغییر می‌کنند، تست را به‌روزرسانی کنیم، بنابراین به جای بررسی برابری دقیق با مقدار بازگشتی از تابع `greeting`، فقط تأیید می‌کنیم که خروجی شامل متن پارامتر ورودی است.

حالا بیایید یک باگ به این کد وارد کنیم با تغییر `greeting` به‌طوری که `name` را شامل نشود تا ببینیم پیام شکست تست پیش‌فرض چگونه است:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}
```

اجرای این تست خروجی زیر را تولید می‌کند:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}
```

این نتیجه فقط نشان می‌دهد که ادعا شکست خورده است و خطی که ادعا در آن قرار دارد کدام است. یک پیام شکست مفیدتر مقدار بازگشتی از تابع `greeting` را چاپ می‌کرد. بیایید یک پیام شکست سفارشی اضافه کنیم که از یک رشته قالب با یک نگهدارنده که با مقدار واقعی بازگشتی از تابع `greeting` پر شده است، تشکیل شده باشد:

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}
```

حالا وقتی تست را اجرا می‌کنیم، یک پیام خطای اطلاع‌رسان‌تر دریافت خواهیم کرد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}
```

ما می‌توانیم مقدار واقعی‌ای که در خروجی تست دریافت کردیم را ببینیم، که به ما کمک می‌کند تا اشکال‌زدایی کنیم که چه اتفاقی افتاد به جای آنچه که انتظار داشتیم اتفاق بیفتد.

### بررسی پانیک با `should_panic`

علاوه بر بررسی مقادیر بازگشتی، مهم است که بررسی کنیم کد ما شرایط خطا را همانطور که انتظار داریم مدیریت می‌کند. برای مثال، نوع `Guess` را که در فصل ۹، لیست ۹-۱۳ ایجاد کردیم در نظر بگیرید. سایر کدهایی که از `Guess` استفاده می‌کنند به این تضمین وابسته هستند که نمونه‌های `Guess` فقط مقادیر بین ۱ و ۱۰۰ را شامل می‌شوند. می‌توانیم تستی بنویسیم که اطمینان حاصل کند که تلاش برای ایجاد یک نمونه `Guess` با مقداری خارج از این بازه منجر به پانیک می‌شود.

این کار را با افزودن ویژگی `should_panic` به تابع تست خود انجام می‌دهیم. اگر کد داخل تابع پانیک کند، تست پاس می‌شود؛ اگر کد داخل تابع پانیک نکند، تست شکست می‌خورد.

لیست ۱۱-۸ یک تست را نشان می‌دهد که بررسی می‌کند شرایط خطای `Guess::new` زمانی که انتظار داریم رخ می‌دهند.

<Listing number="11-8" file-name="src/lib.rs" caption="تست کردن اینکه آیا یک شرط باعث یک `panic!` می‌شود">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}
```

</Listing>

ما ویژگی `#[should_panic]` را بعد از ویژگی `#[test]` و قبل از تابع تستی که به آن اعمال می‌شود قرار می‌دهیم. بیایید به نتیجه‌ای که وقتی این تست پاس می‌شود نگاه کنیم:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}
```

به نظر خوب می‌آید! حالا بیایید یک باگ در کد خود وارد کنیم با حذف شرطی که تابع `new` را مجبور می‌کند اگر مقدار بیشتر از ۱۰۰ باشد پانیک کند:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}
```

وقتی تست در لیست ۱۱-۸ را اجرا می‌کنیم، شکست می‌خورد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}
```

در این مورد پیام خیلی مفیدی دریافت نمی‌کنیم، اما وقتی به تابع تست نگاه می‌کنیم، می‌بینیم که با `#[should_panic]` حاشیه‌نویسی شده است. شکست به این معناست که کدی که در تابع تست قرار دارد باعث یک پانیک نشده است.

تست‌هایی که از `should_panic` استفاده می‌کنند می‌توانند دقیق نباشند. یک تست `should_panic` حتی اگر تست برای دلیلی غیر از آنچه انتظار داشتیم پانیک کند، پاس می‌شود. برای دقیق‌تر کردن تست‌های `should_panic`، می‌توانیم یک پارامتر اختیاری `expected` به ویژگی `should_panic` اضافه کنیم. تست رانر اطمینان حاصل می‌کند که پیام شکست شامل متن ارائه‌شده است. برای مثال، کد تغییر داده‌شده برای `Guess` در لیست ۱۱-۹ را در نظر بگیرید که تابع `new` با پیام‌های مختلف بسته به اینکه مقدار خیلی کوچک یا خیلی بزرگ باشد پانیک می‌کند.

<Listing number="11-9" file-name="src/lib.rs" caption="تست کردن یک `panic!` با یک پیام پانیک که حاوی یک زیررشته مشخص است">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}
```

</Listing>

این تست پاس می‌شود زیرا مقداری که در پارامتر `expected` ویژگی `should_panic` قرار داده‌ایم یک زیررشته از پیامی است که تابع `Guess::new` با آن پانیک می‌کند. می‌توانستیم کل پیام پانیکی که انتظار داریم را مشخص کنیم، که در این مورد می‌شد `Guess value must be less than or equal to 100, got 200`. آنچه انتخاب می‌کنید بستگی به این دارد که چه مقدار از پیام پانیک منحصر به فرد یا پویا است و چقدر می‌خواهید تست شما دقیق باشد. در این مورد، یک زیررشته از پیام پانیک کافی است تا اطمینان حاصل شود که کد در تابع تست مورد `else if value > 100` را اجرا می‌کند.

برای دیدن اینکه وقتی یک تست `should_panic` با یک پیام `expected` شکست می‌خورد چه اتفاقی می‌افتد، بیایید دوباره یک باگ به کد خود وارد کنیم با جابه‌جا کردن بدنه‌های بلوک‌های `if value < 1` و `else if value > 100`:

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}
```

این بار وقتی تست `should_panic` را اجرا می‌کنیم، شکست خواهد خورد:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}
```

پیام شکست نشان می‌دهد که این تست همانطور که انتظار داشتیم پانیک کرد، اما پیام پانیک شامل رشته مورد انتظار `less than or equal to 100` نبود. پیام پانیکی که در این مورد دریافت کردیم `Guess value must be greater than or equal to 1, got 200.` بود. حالا می‌توانیم شروع به پیدا کردن محل باگ کنیم!

### استفاده از `Result<T, E>` در تست‌ها

تست‌های ما تا اینجا همه زمانی که شکست می‌خورند پانیک می‌کنند. همچنین می‌توانیم تست‌هایی بنویسیم که از `Result<T, E>` استفاده کنند! در اینجا تست لیست ۱۱-۱ را بازنویسی کرده‌ایم تا از `Result<T, E>` استفاده کند و به جای پانیک کردن، یک `Err` بازگرداند:

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs:here}}
```

تابع `it_works` اکنون نوع بازگشتی `Result<(), String>` دارد. در بدنه تابع، به جای فراخوانی ماکروی `assert_eq!`، وقتی تست پاس می‌شود `Ok(())` و وقتی تست شکست می‌خورد یک `Err` با یک `String` داخل آن بازمی‌گردانیم.

نوشتن تست‌هایی که یک `Result<T, E>` بازمی‌گردانند به شما اجازه می‌دهد از عملگر سوالی `?` در بدنه تست‌ها استفاده کنید، که می‌تواند راهی راحت برای نوشتن تست‌هایی باشد که اگر هر عملیاتی در آن‌ها یک واریانت `Err` بازگرداند، شکست بخورند.

شما نمی‌توانید از حاشیه‌نویسی `#[should_panic]` در تست‌هایی که از `Result<T, E>` استفاده می‌کنند استفاده کنید. برای تأیید اینکه یک عملیات یک واریانت `Err` بازمی‌گرداند، _از_ عملگر سوالی روی مقدار `Result<T, E>` استفاده نکنید. در عوض، از `assert!(value.is_err())` استفاده کنید.

حالا که چندین روش برای نوشتن تست‌ها را یاد گرفتید، بیایید نگاهی به آنچه هنگام اجرای تست‌ها اتفاق می‌افتد بیندازیم و گزینه‌های مختلفی را که می‌توانیم با `cargo test` استفاده کنیم بررسی کنیم.

[concatenation-with-the--operator-or-the-format-macro]: ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro  
[bench]: ../unstable-book/library-features/test.html  
[ignoring]: ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested  
[subset]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name  
[controlling-how-tests-are-run]: ch11-02-running-tests.html#controlling-how-tests-are-run  
[derivable-traits]: appendix-03-derivable-traits.html  
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests  
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
