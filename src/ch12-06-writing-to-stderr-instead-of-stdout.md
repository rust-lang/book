<!-- Old headings. Do not remove or links may break. -->

<a id="writing-error-messages-to-standard-error-instead-of-standard-output"></a>

## إعادة توجيه الأخطاء إلى الخطأ القياسي

في الوقت الحالي، نكتب كل إخراجنا إلى الطرفية باستخدام ماكرو `println!`. في
معظم الطرفيات، يوجد نوعان من الإخراج: _الإخراج القياسي_ (`stdout`) للمعلومات
العامة و_الخطأ القياسي_ (`stderr`) لرسائل الخطأ. يتيح هذا التمييز للمستخدمين
اختيار توجيه الإخراج الناجح لبرنامج إلى ملف لكن لا يزال بإمكانهم طباعة رسائل
الخطأ على الشاشة.

ماكرو `println!` قادر فقط على الطباعة إلى الإخراج القياسي، لذا علينا استخدام
شيء آخر للطباعة إلى الخطأ القياسي.

### التحقق من مكان كتابة الأخطاء

أولاً، لنلاحظ كيف يتم حاليًا كتابة المحتوى الذي يطبعه `minigrep` إلى الإخراج
القياسي، بما في ذلك أي رسائل خطأ نريد كتابتها إلى الخطأ القياسي بدلاً من ذلك.
سنفعل ذلك عن طريق إعادة توجيه تدفق الإخراج القياسي إلى ملف مع التسبب عمدًا في
خطأ. لن نعيد توجيه تدفق الخطأ القياسي، لذا سيستمر عرض أي محتوى يتم إرساله إلى
الخطأ القياسي على الشاشة.

من المتوقع أن ترسل برامج سطر الأوامر رسائل الخطأ إلى تدفق الخطأ القياسي حتى
نتمكن من رؤية رسائل الخطأ على الشاشة حتى لو قمنا بإعادة توجيه تدفق الإخراج
القياسي إلى ملف. برنامجنا حاليًا لا يتصرف بشكل جيد: نحن على وشك أن نرى أنه يحفظ
إخراج رسالة الخطأ في ملف بدلاً من ذلك!

لإثبات هذا السلوك، سنشغل البرنامج مع `>` ومسار الملف، _output.txt_، الذي نريد
إعادة توجيه تدفق الإخراج القياسي إليه. لن نمرر أي معاملات، مما يجب أن يتسبب في
خطأ:

```console
$ cargo run > output.txt
```

بناء جملة `>` يخبر shell بكتابة محتويات الإخراج القياسي إلى _output.txt_ بدلاً
من الشاشة. لم نرَ رسالة الخطأ التي كنا نتوقع طباعتها على الشاشة، لذا يعني ذلك
أنها انتهت في الملف. هذا ما يحتويه _output.txt_:

```text
Problem parsing arguments: not enough arguments
```

نعم، رسالة الخطأ الخاصة بنا تُطبع إلى الإخراج القياسي. من الأكثر فائدة بكثير
طباعة رسائل الخطأ مثل هذه إلى الخطأ القياسي بحيث تنتهي فقط البيانات من تشغيل
ناجح في الملف. سنغير ذلك.

### طباعة الأخطاء إلى الخطأ القياسي

سنستخدم الكود في القائمة 12-24 لتغيير كيفية طباعة رسائل الخطأ. بسبب إعادة
الهيكلة التي قمنا بها في وقت سابق من هذا الفصل، كل الكود الذي يطبع رسائل الخطأ
موجود في دالة واحدة، `main`. توفر المكتبة القياسية ماكرو `eprintln!` الذي يطبع
إلى تدفق الخطأ القياسي، لذا لنغير المكانين اللذين كنا نستدعي فيهما `println!`
لطباعة الأخطاء لاستخدام `eprintln!` بدلاً من ذلك.

<Listing number="12-24" file-name="src/main.rs" caption="كتابة رسائل الخطأ إلى الخطأ القياسي بدلاً من الإخراج القياسي باستخدام `eprintln!`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}
```

</Listing>

لنشغل البرنامج الآن مرة أخرى بنفس الطريقة، بدون أي معاملات وإعادة توجيه الإخراج
القياسي بـ `>`:

```console
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

الآن نرى الخطأ على الشاشة و_output.txt_ لا يحتوي على شيء، وهو السلوك الذي
نتوقعه من برامج سطر الأوامر.

لنشغل البرنامج مرة أخرى بمعاملات لا تتسبب في خطأ ولكن لا تزال تعيد توجيه
الإخراج القياسي إلى ملف، مثل:

```console
$ cargo run -- to poem.txt > output.txt
```

لن نرى أي إخراج إلى الطرفية، و_output.txt_ سيحتوي على نتائجنا:

<span class="filename">اسم الملف: output.txt</span>

```text
Are you nobody, too?
How dreary to be somebody!
```

يوضح هذا أننا نستخدم الآن الإخراج القياسي للإخراج الناجح والخطأ القياسي لإخراج
الخطأ بشكل مناسب.

## ملخص

لقد راجع هذا الفصل بعض المفاهيم الرئيسية التي تعلمتها حتى الآن وغطى كيفية
إجراء عمليات إدخال/إخراج شائعة في Rust. باستخدام معاملات سطر الأوامر،
والملفات، ومتغيرات البيئة، وماكرو `eprintln!` لطباعة الأخطاء، أنت الآن مستعد
لكتابة تطبيقات سطر الأوامر. بالإضافة إلى المفاهيم في الفصول السابقة، سيكون
كودك منظمًا بشكل جيد، وسيخزن البيانات بفعالية في بنى البيانات المناسبة، وسيتعامل
مع الأخطاء بشكل جيد، وسيكون مختبرًا بشكل جيد.

بعد ذلك، سنستكشف بعض ميزات Rust التي تأثرت باللغات الوظيفية: الإغلاقات
والمُكرِّرات.
