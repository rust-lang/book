## ما هي الملكية؟

_الملكية (Ownership)_ هي مجموعة من القواعد (rules) التي تحكم كيفية إدارة برنامج Rust للذاكرة (memory).
جميع البرامج يجب أن تدير الطريقة التي تستخدم بها ذاكرة الكمبيوتر أثناء التشغيل (runtime).
بعض اللغات تحتوي على جامع قمامة (garbage collector) يبحث بانتظام عن الذاكرة (memory) التي لم تعد مستخدمة
أثناء تشغيل البرنامج؛ في لغات أخرى، يجب على المبرمج تخصيص (allocate) وتحرير (free) الذاكرة (memory) بشكل صريح.
تستخدم Rust نهجاً ثالثاً: تتم إدارة الذاكرة من خلال نظام ملكية (ownership system) مع مجموعة من القواعد (rules)
التي يفحصها المصرِّف (compiler). إذا تم انتهاك أي من القواعد، فلن يتم ترجمة (compile) البرنامج. لا تؤدي
أي من ميزات الملكية (ownership) إلى إبطاء برنامجك أثناء تشغيله.

نظراً لأن الملكية مفهوم جديد للعديد من المبرمجين، فإنها تستغرق بعض الوقت
للتعود عليها. الخبر السار هو أنه كلما أصبحت أكثر خبرة مع Rust
وقواعد نظام الملكية، كلما وجدت أنه من الأسهل تطوير كود
آمن وفعال بشكل طبيعي. استمر في ذلك!

عندما تفهم الملكية (ownership)، سيكون لديك أساس قوي لفهم
الميزات (features) التي تجعل Rust فريدة. في هذا الفصل، ستتعلم الملكية (ownership) من خلال
العمل عبر بعض الأمثلة التي تركز على بنية بيانات (data structure) شائعة جداً:
السلاسل النصية (strings).

> ### المكدس (Stack) والكومة (Heap)
>
> العديد من لغات البرمجة لا تتطلب منك التفكير في المكدس (stack) والكومة (heap)
> كثيراً. لكن في لغة برمجة أنظمة (systems programming language) مثل Rust، سواء كانت
> قيمة (value) على المكدس (stack) أو الكومة (heap) تؤثر على كيفية تصرف اللغة ولماذا
> يجب عليك اتخاذ قرارات معينة. ستتم وصف أجزاء من الملكية (ownership) في
> علاقتها بالمكدس (stack) والكومة (heap) لاحقاً في هذا الفصل، لذا إليك شرح موجز
> استعداداً لذلك.
>
> كل من المكدس (stack) والكومة (heap) أجزاء من الذاكرة (memory) المتاحة لكودك لاستخدامها
> في وقت التشغيل (runtime)، لكنهما منظمان بطرق مختلفة. يخزن المكدس (stack)
> القيم (values) بالترتيب الذي يحصل عليها ويزيل القيم بالترتيب
> المعاكس. يُشار إلى هذا باسم _الأخير يدخل، الأول يخرج (last in, first out - LIFO)_. فكر في كومة من
> الأطباق: عندما تضيف المزيد من الأطباق، تضعها في أعلى الكومة، وعندما
> تحتاج إلى طبق، تأخذ واحداً من الأعلى. إضافة أو إزالة الأطباق من
> المنتصف أو الأسفل لن تعمل بشكل جيد! إضافة البيانات تسمى _الدفع
> إلى المكدس (pushing onto the stack)_، وإزالة البيانات تسمى _السحب من المكدس (popping off the stack)_. جميع
> البيانات المخزنة على المكدس (stack) يجب أن يكون لها حجم معروف وثابت (known, fixed size). البيانات ذات الحجم
> غير المعروف في وقت الترجمة (compile time) أو الحجم الذي قد يتغير يجب أن تُخزن على الكومة (heap)
> بدلاً من ذلك.
>
> الكومة (heap) أقل تنظيماً: عندما تضع بيانات على الكومة (heap)، تطلب
> كمية معينة من المساحة. يجد مخصص الذاكرة (memory allocator) مكاناً فارغاً في الكومة (heap)
> كبير بما يكفي، يحدده على أنه قيد الاستخدام، ويعيد _مؤشراً (pointer)_، وهو
> عنوان (address) ذلك الموقع. تسمى هذه العملية _التخصيص على
> الكومة (allocating on the heap)_ وأحياناً يتم اختصارها إلى _التخصيص (allocating)_ فقط (دفع القيم على
> المكدس (stack) لا يُعتبر تخصيصاً (allocating)). نظراً لأن المؤشر (pointer) إلى الكومة (heap) له
> حجم معروف وثابت (known, fixed size)، يمكنك تخزين المؤشر (pointer) على المكدس (stack)، ولكن عندما تريد
> البيانات الفعلية (actual data)، يجب عليك اتباع المؤشر (follow the pointer). فكر في الجلوس في
> مطعم. عندما تدخل، تذكر عدد الأشخاص في مجموعتك، و
> المضيف يجد طاولة فارغة تتسع للجميع ويقودك إلى هناك. إذا
> جاء شخص من مجموعتك متأخراً، يمكنه أن يسأل أين تم إجلاسكم
> ليجدك.
>
> الدفع إلى المكدس أسرع من التخصيص على الكومة لأن
> المخصص لا يحتاج أبداً إلى البحث عن مكان لتخزين بيانات جديدة؛ هذا الموقع
> دائماً في أعلى المكدس. بالمقارنة، يتطلب تخصيص مساحة على الكومة
> المزيد من العمل لأن المخصص يجب أولاً أن يجد مساحة كبيرة بما يكفي
> لحمل البيانات ثم يقوم بإجراء المحاسبة للتحضير للتخصيص
> التالي.
>
> الوصول إلى البيانات في الكومة بشكل عام أبطأ من الوصول إلى البيانات على
> المكدس لأنه يجب عليك اتباع مؤشر للوصول إلى هناك. المعالجات
> المعاصرة أسرع إذا قفزت حولها أقل في الذاكرة. متابعة
> التشبيه، ضع في اعتبارك نادلاً في مطعم يأخذ طلبات من طاولات عديدة.
> إنه الأكثر كفاءة في الحصول على جميع الطلبات في طاولة واحدة قبل الانتقال إلى
> الطاولة التالية. أخذ طلب من الطاولة A، ثم طلب من الطاولة B،
> ثم واحد من A مرة أخرى، ثم واحد من B مرة أخرى سيكون عملية أبطأ بكثير.
> بنفس الطريقة، يمكن للمعالج عادة القيام بعمله بشكل أفضل إذا
> كان يعمل على بيانات قريبة من بيانات أخرى (كما هو الحال على المكدس) بدلاً من
> بعيدة (كما يمكن أن تكون على الكومة).
>
> عندما يستدعي كودك دالة، القيم الممررة إلى الدالة
> (بما في ذلك، محتملاً، مؤشرات إلى بيانات على الكومة) والمتغيرات
> المحلية للدالة تُدفع إلى المكدس. عندما تنتهي الدالة، تلك
> القيم تُسحب من المكدس.
>
> تتبع أي أجزاء من الكود تستخدم أي بيانات على الكومة،
> وتقليل كمية البيانات المكررة على الكومة، وتنظيف البيانات
> غير المستخدمة على الكومة حتى لا تنفد المساحة كلها مشاكل
> تعالجها الملكية. بمجرد فهمك للملكية، لن تحتاج إلى التفكير
> في المكدس والكومة كثيراً. لكن معرفة أن الغرض الرئيسي من
> الملكية هو إدارة بيانات الكومة يمكن أن يساعد في تفسير سبب عملها بالطريقة
> التي تعمل بها.

### قواعد الملكية

أولاً، دعنا نلقي نظرة على قواعد الملكية. ضع هذه القواعد في ذهنك بينما
نعمل عبر الأمثلة التي توضحها:

- كل قيمة في Rust لها _مالك_.
- يمكن أن يكون هناك مالك واحد فقط في كل مرة.
- عندما يخرج المالك من النطاق، سيتم إسقاط القيمة.

### نطاق المتغيرات

الآن بعد أن تجاوزنا بناء جملة Rust الأساسي، لن نُضمّن كل كود `fn main() {`
في الأمثلة، لذا إذا كنت تتابع، تأكد من وضع
الأمثلة التالية داخل دالة `main` يدوياً. ونتيجة لذلك، ستكون أمثلتنا
أكثر إيجازاً قليلاً، مما يتيح لنا التركيز على التفاصيل الفعلية بدلاً من
الكود النموذجي.

كمثال أول على الملكية، سننظر إلى نطاق بعض المتغيرات.
_النطاق_ هو المدى داخل برنامج حيث يكون العنصر صالحاً. خذ
المتغير التالي:

```rust
let s = "hello";
```

يشير المتغير `s` إلى حرف نصي، حيث قيمة السلسلة النصية
مشفرة بشكل ثابت في نص برنامجنا. المتغير صالح من النقطة التي
يُعلن فيها حتى نهاية النطاق الحالي. يُظهر القائمة 4-1
برنامجاً مع تعليقات توضح أين سيكون المتغير `s` صالحاً.

<Listing number="4-1" caption="متغير والنطاق الذي يكون فيه صالحاً">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

</Listing>

بعبارة أخرى، هناك نقطتان زمنيتان مهمتان هنا:

- عندما يدخل `s` _إلى_ النطاق، يكون صالحاً.
- يظل صالحاً حتى يخرج _من_ النطاق.

في هذه المرحلة، العلاقة بين النطاقات ومتى تكون المتغيرات صالحة
مشابهة لتلك في لغات البرمجة الأخرى. الآن سنبني على هذا
الفهم بتقديم نوع `String`.

### نوع `String`

لتوضيح قواعد الملكية، نحتاج إلى نوع بيانات أكثر تعقيداً
من تلك التي غطيناها في قسم [â€œأنواع البياناتâ€][data-types]<!-- ignore -->
من الفصل 3. الأنواع التي تم تغطيتها سابقاً لها حجم معروف، يمكن تخزينها
على المكدس وسحبها من المكدس عندما ينتهي نطاقها، ويمكن
نسخها بسرعة وبشكل تافه لإنشاء نسخة جديدة ومستقلة إذا كان جزء آخر
من الكود يحتاج إلى استخدام نفس القيمة في نطاق مختلف. لكننا نريد
النظر إلى البيانات المخزنة على الكومة واستكشاف كيف تعرف Rust متى
تنظف تلك البيانات، ونوع `String` مثال رائع.

سنركز على أجزاء `String` المتعلقة بالملكية. هذه
الجوانب تنطبق أيضاً على أنواع البيانات المعقدة الأخرى، سواء كانت مقدمة من
المكتبة القياسية أو أنشأتها أنت. سنناقش جوانب `String` غير المتعلقة بالملكية
في [الفصل 8][ch8]<!-- ignore -->.

لقد رأينا بالفعل النصوص الحرفية، حيث تكون قيمة السلسلة النصية مشفرة بشكل ثابت في
برنامجنا. النصوص الحرفية مريحة، لكنها ليست مناسبة لكل
حالة قد نرغب فيها في استخدام النص. أحد الأسباب هو أنها
غير قابلة للتغيير. سبب آخر هو أنه ليس كل قيمة نصية يمكن معرفتها عندما نكتب
كودنا: على سبيل المثال، ماذا لو أردنا أخذ إدخال المستخدم وتخزينه؟ إنه
لهذه الحالات أن لدى Rust نوع `String`. يدير هذا النوع
البيانات المخصصة على الكومة وبالتالي قادر على تخزين كمية من النص
غير معروفة لنا في وقت الترجمة. يمكنك إنشاء `String` من نص
حرفي باستخدام دالة `from`، مثل هذا:

```rust
let s = String::from("hello");
```

يسمح لنا عامل القولون المزدوج `::` بوضع هذه الدالة `from` المحددة
تحت نوع `String` بدلاً من استخدام نوع من الاسم مثل
`string_from`. سنناقش هذا البناء أكثر في قسم [â€œبناء جملة الدوالâ€][methods]<!-- ignore -->
من الفصل 5، وعندما نتحدث عن استخدام الفضاءات الاسمية مع الوحدات في [â€œالمسارات للإشارة إلى عنصر في شجرة الوحدةâ€][paths-module-tree]<!-- ignore -->
في الفصل 7.

يمكن تحويل هذا النوع من السلاسل النصية:

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() يضيف حرفاً نصياً إلى String

println!("{s}"); // سيطبع `hello, world!`
```

إذن، ما الفرق هنا؟ لماذا يمكن تحويل `String` ولا يمكن تحويل الحروف النصية؟
الفرق هو كيفية تعامل هذين النوعين مع الذاكرة.

### الذاكرة والتخصيص

في حالة النص الحرفي، نعرف المحتويات في وقت الترجمة، لذلك يتم
تشفير النص بشكل ثابت مباشرة في الملف التنفيذي النهائي. هذا هو السبب في أن النصوص الحرفية
سريعة وفعالة. لكن هذه الخصائص تأتي فقط من عدم قابلية النص الحرفي للتغيير.
للأسف، لا يمكننا وضع كتلة من الذاكرة في الملف الثنائي لكل قطعة من النص
حجمها غير معروف في وقت الترجمة وقد يتغير حجمها أثناء تشغيل
البرنامج.

مع نوع `String`، من أجل دعم قطعة من النص قابلة للتغيير والنمو، نحتاج إلى
تخصيص كمية من الذاكرة على الكومة، غير معروفة في وقت الترجمة، لحمل
المحتويات. هذا يعني:

- يجب طلب الذاكرة من مخصص الذاكرة في وقت التشغيل.
- نحتاج إلى طريقة لإعادة هذه الذاكرة إلى المخصص عندما ننتهي من
  `String` الخاص بنا.

هذا الجزء الأول يتم من قبلنا: عندما نستدعي `String::from`، يطلب تنفيذها
الذاكرة التي يحتاجها. هذا عالمي إلى حد ما في لغات البرمجة.

ومع ذلك، الجزء الثاني مختلف. في اللغات مع _جامع قمامة (GC)_،
يتتبع GC وينظف الذاكرة التي لم تعد مستخدمة، ولا نحتاج
للتفكير فيها. في معظم اللغات بدون GC، من مسؤوليتنا تحديد متى
لم تعد الذاكرة مستخدمة واستدعاء كود لإعادتها بشكل صريح، تماماً كما فعلنا
لطلبها. القيام بذلك بشكل صحيح كان تاريخياً مشكلة برمجية صعبة. إذا نسينا، سنضيع
الذاكرة. إذا فعلنا ذلك مبكراً جداً، سيكون لدينا متغير غير صالح. إذا فعلنا ذلك مرتين، هذا
أيضاً خطأ. نحتاج إلى إقران بالضبط `allocate` واحد مع `free` واحد بالضبط.

تتخذ Rust مساراً مختلفاً: يتم إعادة الذاكرة تلقائياً بمجرد خروج المتغير
الذي يملكها من النطاق. هنا نسخة من مثال نطاقنا من القائمة 4-1 باستخدام
`String` بدلاً من نص حرفي:

```rust
{
    let s = String::from("hello"); // s صالح من هذه النقطة فصاعداً

    // افعل أشياء مع s
}                                  // هذا النطاق انتهى الآن، و s لم يعد
                                   // صالحاً
```

هناك نقطة طبيعية يمكننا فيها إعادة الذاكرة التي يحتاجها `String`
إلى المخصص: عندما يخرج `s` من النطاق. عندما يخرج متغير من النطاق، تستدعي Rust
دالة خاصة لنا. تسمى هذه الدالة [`drop`][drop]، وهي حيث يمكن لكاتب
`String` وضع الكود لإعادة الذاكرة. تستدعي Rust `drop` تلقائياً عند القوس
المغلق.

> ملاحظة: في C++، نمط إلغاء تخصيص الموارد في نهاية عمر عنصر
> يُسمى أحياناً _اكتساب الموارد هو التهيئة (RAII)_. دالة `drop` في Rust
> ستكون مألوفة لك إذا كنت قد استخدمت أنماط RAII.

هذا النمط له تأثير عميق على طريقة كتابة كود Rust. قد يبدو بسيطاً الآن،
لكن سلوك الكود يمكن أن يكون غير متوقع في حالات أكثر تعقيداً عندما
نريد أن تكون لدينا متغيرات متعددة تستخدم البيانات التي خصصناها على الكومة. دعنا
نستكشف بعض تلك الحالات الآن.

<!-- Old headings. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-move"></a>

#### المتغيرات والبيانات تتفاعل مع النقل

يمكن أن تتفاعل متغيرات متعددة مع نفس البيانات بطرق مختلفة في Rust. دعنا
ننظر إلى مثال باستخدام عدد صحيح في القائمة 4-2.

<Listing number="4-2" caption="إسناد قيمة العدد الصحيح للمتغير x إلى y">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

</Listing>

يمكننا على الأرجح تخمين ما يفعله هذا: "اربط القيمة `5` بـ `x`؛ ثم اصنع نسخة من
القيمة في `x` واربطها بـ `y`." لدينا الآن متغيران، `x` و `y`، وكلاهما
يساوي `5`. هذا بالفعل ما يحدث، لأن الأعداد الصحيحة قيم بسيطة ذات حجم
معروف وثابت، وهاتان القيمتان `5` تُدفعان على المكدس.

الآن دعنا ننظر إلى نسخة `String`:

```rust
let s1 = String::from("hello");
let s2 = s1;
```

يبدو هذا مشابهاً جداً، لذا قد نفترض أن طريقة عمله ستكون
نفسها: أي أن السطر الثاني سيصنع نسخة من القيمة في `s1` ويربطها بـ `s2`.
لكن هذا ليس ما يحدث تماماً.

انظر إلى الشكل 4-1 لترى ما يحدث لـ `String` تحت الغطاء. `String`
يتكون من ثلاثة أجزاء، موضحة على اليسار: مؤشر إلى الذاكرة التي
تحمل محتويات السلسلة النصية، والطول، والسعة. هذه المجموعة من البيانات
مخزنة على المكدس. على اليمين توجد الذاكرة على الكومة التي تحمل
المحتويات.

<img alt="جدولان: الأول يمثل البيانات المخزنة على المكدس لـ s1، و
يحتوي على طول (5)، والسعة (5)، ومؤشر إلى القيمة الأولى في
جدول البيانات الثاني. الجدول الثاني يمثل البيانات المخزنة على الكومة،
التي تحتوي فقط على قيم السلسلة النصية، في هذه الحالة الحروف الخمسة من h وe وl وl و
o." src="img/trpl04-01.svg" class="center" style="width: 50%;" />

<span class="caption">الشكل 4-1: تمثيل في الذاكرة لـ `String`
يحمل القيمة `"hello"` مربوطة بـ `s1`</span>

الطول هو كمية الذاكرة، بالبايتات، التي يستخدمها محتوى `String`
حالياً. السعة هي الكمية الإجمالية للذاكرة، بالبايتات، التي تلقاها
`String` من المخصص. الفرق بين الطول والسعة مهم، لكن
ليس في هذا السياق، لذا في الوقت الحالي، لا بأس من تجاهل السعة.

عندما نسند `s1` إلى `s2`، يتم نسخ بيانات `String`. نحن ننسخ المؤشر،
والطول، والسعة التي على المكدس. نحن لا ننسخ البيانات على الكومة التي
يشير إليها المؤشر. بعبارة أخرى، تمثيل البيانات في الذاكرة يبدو مثل
الشكل 4-2.

<img alt="ثلاثة جداول: الجداول s1 و s2 تمثل تلك السلاسل النصية على
المكدس، على التوالي، وكلاهما يشير إلى نفس بيانات السلسلة النصية على الكومة."
src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">الشكل 4-2: تمثيل في الذاكرة للمتغير `s2`
الذي لديه نسخة من المؤشر والطول والسعة لـ `s1`</span>

التمثيل _لا_ يبدو مثل الشكل 4-3، وهو كيف ستبدو الذاكرة إذا كانت Rust
بدلاً من ذلك نسخت أيضاً بيانات الكومة. إذا فعلت Rust ذلك، فإن العملية `s2 = s1`
يمكن أن تكون مكلفة جداً من حيث الأداء في وقت التشغيل إذا كانت البيانات على الكومة
كبيرة.

<img alt="أربعة جداول: جدولان يمثلان بيانات المكدس لـ s1 و s2،
وكل منهما يشير إلى نسخته الخاصة من بيانات السلسلة النصية على الكومة."
src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">الشكل 4-3: احتمالية أخرى لما قد يفعله `s2 = s1`
إذا كانت Rust تنسخ بيانات الكومة أيضاً</span>

في وقت سابق، قلنا أنه عندما يخرج متغير من النطاق، تستدعي Rust تلقائياً
دالة `drop` وتنظف ذاكرة الكومة لذلك المتغير. لكن الشكل 4-2 يُظهر
كلا مؤشري البيانات يشيران إلى نفس الموقع. هذه مشكلة: عندما يخرج `s2` و `s1` من
النطاق، سيحاولان كلاهما تحرير نفس الذاكرة. هذا يُعرف باسم خطأ _التحرير
المزدوج_ وهو أحد أخطاء أمان الذاكرة التي ذكرناها سابقاً. تحرير الذاكرة
مرتين يمكن أن يؤدي إلى تلف الذاكرة، مما قد يؤدي إلى ثغرات أمنية.

لضمان أمان الذاكرة، بعد السطر `let s2 = s1;`، تعتبر Rust `s1` على أنه
لم يعد صالحاً. لذلك، لا تحتاج Rust إلى تحرير أي شيء عندما يخرج `s1` من
النطاق. تحقق من ما يحدث عندما تحاول استخدام `s1` بعد إنشاء `s2`؛ لن
يعمل:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-move-invalidates/src/main.rs:here}}
```

ستحصل على خطأ مثل هذا لأن Rust تمنعك من استخدام المرجع الملغى:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-01-move-invalidates/output.txt}}
```

إذا سمعت المصطلحين _نسخة ضحلة_ و _نسخة عميقة_ أثناء العمل مع لغات
أخرى، فإن مفهوم نسخ المؤشر والطول والسعة دون نسخ البيانات
ربما يبدو مثل عمل نسخة ضحلة. لكن نظراً لأن Rust تبطل أيضاً المتغير
الأول، بدلاً من تسميته نسخة ضحلة، يُعرف باسم _نقل_. في هذا المثال،
سنقول أن `s1` تم _نقله_ إلى `s2`. إذن ما يحدث فعلياً موضح في
الشكل 4-4.

<img alt="ثلاثة جداول: الجداول s1 و s2 تمثل تلك السلاسل النصية على
المكدس، على التوالي، وكلاهما يشير إلى نفس بيانات السلسلة النصية على الكومة.
الجدول s1 رمادي لأن s1 لم يعد صالحاً بعد؛ فقط s2 يمكن استخدامه للوصول إلى
بيانات الكومة." src="img/trpl04-04.svg" class="center" style="width:
50%;" />

<span class="caption">الشكل 4-4: تمثيل في الذاكرة بعد إبطال
`s1`</span>

هذا يحل مشكلتنا! مع فقط `s2` صالح، عندما يخرج من النطاق، هو
وحده سيحرر الذاكرة، وانتهينا.

بالإضافة إلى ذلك، هناك اختيار تصميم ضمني في ذلك: لن تقوم Rust أبداً تلقائياً بإنشاء
نسخ "عميقة" من بياناتك. لذلك، يمكن افتراض أي نسخ _تلقائي_ يكون
غير مكلف من حيث الأداء في وقت التشغيل.

#### النطاق والإسناد

عكس هذا صحيح أيضاً للعلاقة بين النطاق، والملكية، و
تحرير الذاكرة عبر دالة `drop` أيضاً. عندما تسند قيمة جديدة تماماً
إلى متغير موجود، ستستدعي Rust `drop` وتحرر ذاكرة القيمة
الأصلية على الفور. ضع في اعتبارك هذا الكود، على سبيل المثال:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04b-replacement-drop/src/main.rs:here}}
```

في البداية نعلن متغير `s` ونربطه بـ `String` بالقيمة
`"hello"`. ثم، ننشئ على الفور `String` جديد بالقيمة `"ahoy"`
ونسنده إلى `s`. في هذه المرحلة، لا شيء يشير إلى القيمة الأصلية
على الكومة على الإطلاق. يوضح الشكل 4-5 بيانات المكدس والكومة الآن:

<img alt="جدول واحد يمثل قيمة السلسلة النصية على المكدس، يشير إلى
القطعة الثانية من بيانات السلسلة النصية (ahoy) على الكومة، مع بيانات السلسلة النصية الأصلية
(hello) مظللة باللون الرمادي لأنه لا يمكن الوصول إليها بعد الآن."
src="img/trpl04-05.svg" class="center" style="width: 50%;" />

<span class="caption">الشكل 4-5: التمثيل في الذاكرة بعد استبدال القيمة
الأولية بالكامل</span>

وبالتالي تخرج السلسلة النصية الأصلية على الفور من النطاق. ستشغل Rust دالة `drop`
عليها وسيتم تحرير ذاكرتها على الفور. عندما نطبع القيمة
في النهاية، ستكون `"ahoy, world!"`.

<!-- Old headings. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-clone"></a>

#### المتغيرات والبيانات تتفاعل مع الاستنساخ

إذا أردنا _فعلاً_ نسخ بيانات الكومة لـ `String` بعمق، وليس فقط
بيانات المكدس، يمكننا استخدام دالة شائعة تسمى `clone`. سنناقش بناء جملة الدوال
في الفصل 5، لكن نظراً لأن الدوال ميزة شائعة في العديد من
لغات البرمجة، فمن المحتمل أنك رأيتها من قبل.

هنا مثال على دالة `clone` أثناء العمل:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

هذا يعمل بشكل جيد ويُنتج صراحة السلوك الموضح في الشكل 4-3،
حيث _يتم_ نسخ بيانات الكومة.

عندما ترى استدعاءً لـ `clone`، تعرف أن بعض الكود التعسفي يتم
تنفيذه وأن هذا الكود قد يكون مكلفاً. إنه مؤشر بصري على أن شيئاً
مختلفاً يحدث.

#### بيانات المكدس فقط: النسخ

هناك تجعيدة أخرى لم نتحدث عنها بعد. هذا الكود باستخدام
الأعداد الصحيحة—جزء منه تم عرضه في القائمة 4-2—يعمل وصالح:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

لكن هذا الكود يبدو أنه يتعارض مع ما تعلمناه للتو: ليس لدينا استدعاء لـ
`clone`، لكن `x` لا يزال صالحاً ولم يُنقل إلى `y`.

السبب هو أن الأنواع مثل الأعداد الصحيحة التي لها حجم معروف في وقت الترجمة
مخزنة بالكامل على المكدس، لذا فإن نسخ القيم الفعلية سريعة
لصنعها. هذا يعني أنه لا يوجد سبب نرغب في منع `x` من أن يكون
صالحاً بعد إنشاء المتغير `y`. بعبارة أخرى، لا يوجد فرق
بين النسخ العميق والنسخ الضحل هنا، لذا فإن استدعاء `clone` لن يفعل أي شيء
مختلف عن النسخ الضحل المعتاد، ويمكننا تركه.

لدى Rust تعليق توضيحي خاص يسمى سمة `Copy` يمكننا وضعها على
الأنواع المخزنة على المكدس، كما هو الحال مع الأعداد الصحيحة (سنتحدث أكثر عن
السمات في [الفصل 10][traits]<!-- ignore -->). إذا نفذ نوع سمة `Copy`،
فإن المتغيرات التي تستخدمه لا تنتقل، بل يتم نسخها بشكل تافه،
مما يجعلها لا تزال صالحة بعد الإسناد إلى متغير آخر.

لن تسمح لنا Rust بتعليق نوع بـ `Copy` إذا كان النوع، أو أي من أجزائه،
قد نفذ سمة `Drop`. إذا كان النوع يحتاج إلى شيء خاص يحدث
عندما تخرج القيمة من النطاق ونضيف التعليق التوضيحي `Copy` إلى ذلك النوع،
سنحصل على خطأ في وقت الترجمة. لمعرفة كيفية إضافة التعليق التوضيحي `Copy`
إلى نوعك لتنفيذ السمة، راجع [â€œالسمات القابلة للاشتقاقâ€][derivable-traits]<!-- ignore --> في الملحق C.

إذن، ما هي الأنواع التي تنفذ سمة `Copy`؟ يمكنك التحقق من الوثائق لـ
النوع المعطى للتأكد، لكن كقاعدة عامة، يمكن لأي مجموعة من القيم العددية البسيطة
تنفيذ `Copy`, ولا شيء يتطلب تخصيصاً أو هو شكل
من أشكال الموارد يمكن أن ينفذ `Copy`. هنا بعض الأنواع التي
تنفذ `Copy`:

- جميع أنواع الأعداد الصحيحة، مثل `u32`.
- النوع المنطقي، `bool`، بالقيم `true` و `false`.
- جميع أنواع الأعداد العشرية، مثل `f64`.
- نوع الحرف، `char`.
- المجموعات، إذا كانت تحتوي فقط على أنواع تنفذ أيضاً `Copy`. على سبيل المثال،
  `(i32, i32)` ينفذ `Copy`، لكن `(i32, String)` لا.

### الملكية والدوال

آليات تمرير قيمة إلى دالة مشابهة لتلك عند
إسناد قيمة إلى متغير. سيؤدي تمرير متغير إلى دالة إلى النقل أو
النسخ، تماماً كما يفعل الإسناد. القائمة 4-3 لديها مثال مع بعض التعليقات التوضيحية
التي توضح أين تدخل المتغيرات وتخرج من النطاق.

<Listing number="4-3" file-name="src/main.rs" caption="دوال مع الملكية والنطاق موضحة">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

</Listing>

إذا حاولنا استخدام `s` بعد الاستدعاء لـ `takes_ownership`، ستطرح Rust
خطأ في وقت الترجمة. هذه الفحوصات الثابتة تحمينا من الأخطاء. حاول إضافة
كود إلى `main` يستخدم `s` و `x` لترى أين يمكنك استخدامها وأين
قواعد الملكية تمنعك من القيام بذلك.

### القيم المُرجعة والنطاق

إرجاع القيم يمكن أن ينقل الملكية أيضاً. القائمة 4-4 توضح مثالاً لـ
دالة ترجع بعض القيمة، مع تعليقات توضيحية مماثلة لتلك في القائمة
4-3.

<Listing number="4-4" file-name="src/main.rs" caption="نقل ملكية القيم المُرجعة">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

</Listing>

ملكية المتغير تتبع نفس النمط في كل مرة: إسناد
قيمة إلى متغير آخر ينقلها. عندما يخرج متغير يتضمن بيانات على
الكومة من النطاق، سيتم تنظيف القيمة بواسطة `drop` ما لم تكن ملكية
البيانات قد نُقلت إلى متغير آخر.

بينما هذا يعمل، فإن أخذ الملكية ثم إعادة الملكية مع كل
دالة مملة قليلاً. ماذا لو أردنا السماح لدالة باستخدام قيمة لكن
دون أخذ الملكية؟ إنه مزعج جداً أن أي شيء نمرره يحتاج أيضاً
إلى أن يتم تمريره مرة أخرى إذا أردنا استخدامه مرة أخرى، بالإضافة إلى أي بيانات ناتجة
من جسم الدالة قد نرغب في إعادتها أيضاً.

تسمح لنا Rust بإرجاع قيم متعددة باستخدام مجموعة، كما هو موضح في القائمة 4-5.

<Listing number="4-5" file-name="src/main.rs" caption="إعادة ملكية المعاملات">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

</Listing>

لكن هذا الكثير من الاحتفالات والكثير من العمل لمفهوم يجب أن يكون
شائعاً. لحسن الحظ بالنسبة لنا، لدى Rust ميزة لاستخدام قيمة دون
نقل الملكية: المراجع.

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[methods]: ch05-03-method-syntax.html#methods
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
