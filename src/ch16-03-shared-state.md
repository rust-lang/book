## تزامن الحالة المشتركة

تمرير الرسائل هو طريقة جيدة للتعامل مع التزامن، لكنها ليست الطريقة الوحيدة. هناك طريقة أخرى وهي أن تصل خيوط متعددة إلى نفس البيانات المشتركة. فكر في هذا الجزء من شعار توثيق لغة Go مرة أخرى: "لا تتواصل بمشاركة الذاكرة."

كيف سيبدو التواصل بمشاركة الذاكرة؟ بالإضافة إلى ذلك، لماذا يحذر عشاق تمرير الرسائل من عدم استخدام مشاركة الذاكرة؟

بطريقة ما، القنوات في أي لغة برمجة مشابهة للملكية الفردية لأنه بمجرد نقل قيمة أسفل قناة، يجب ألا تستخدم تلك القيمة بعد الآن. تزامن الذاكرة المشتركة يشبه الملكية المتعددة: يمكن لخيوط متعددة الوصول إلى نفس موقع الذاكرة في نفس الوقت. كما رأيت في الفصل 15، حيث جعلت المؤشرات الذكية الملكية المتعددة ممكنة، يمكن أن تضيف الملكية المتعددة تعقيداً لأن هؤلاء المالكين المختلفين يحتاجون إلى إدارة. يساعد نظام الأنواع وقواعد الملكية في Rust بشكل كبير في الحصول على هذه الإدارة بشكل صحيح. للحصول على مثال، دعونا ننظر إلى الأقفال المتبادلة (Mutexes)، وهي واحدة من أكثر الأوليات التزامنية شيوعاً للذاكرة المشتركة.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"></a>

### التحكم في الوصول باستخدام Mutexes

Mutex هو اختصار للاستبعاد المتبادل (Mutual exclusion)، كما في أن mutex يسمح فقط لخيط واحد بالوصول إلى بعض البيانات في أي وقت معين. للوصول إلى البيانات في mutex، يجب على الخيط أولاً أن يشير إلى أنه يريد الوصول عن طريق طلب الحصول على قفل (Lock) الـ mutex. القفل هو بنية بيانات تعد جزءاً من الـ mutex تتتبع من لديه حالياً وصول حصري إلى البيانات. لذلك، يوصف الـ mutex بأنه يحرس (Guarding) البيانات التي يحملها عبر نظام القفل.

الأقفال المتبادلة لها سمعة بأنها صعبة الاستخدام لأنه عليك أن تتذكر قاعدتين:

1. يجب عليك محاولة الحصول على القفل قبل استخدام البيانات.
2. عندما تنتهي من البيانات التي يحرسها الـ mutex، يجب عليك فتح القفل للبيانات بحيث يمكن للخيوط الأخرى الحصول على القفل.

للحصول على استعارة من العالم الحقيقي للـ mutex، تخيل مناقشة جماعية في مؤتمر بميكروفون واحد فقط. قبل أن يتمكن أحد المتحدثين من التحدث، عليهم أن يطلبوا أو يشيروا إلى أنهم يريدون استخدام الميكروفون. عندما يحصلون على الميكروفون، يمكنهم التحدث طالما يريدون ثم يسلمون الميكروفون إلى المتحدث التالي الذي يطلب التحدث. إذا نسي أحد المتحدثين تسليم الميكروفون عندما ينتهون منه، فلن يتمكن أي شخص آخر من التحدث. إذا سارت إدارة الميكروفون المشترك بشكل خاطئ، فلن تعمل المناقشة كما هو مخطط لها!

يمكن أن تكون إدارة الأقفال المتبادلة معقدة بشكل لا يصدق لفعلها بشكل صحيح، وهذا هو السبب في أن الكثير من الناس متحمسون للقنوات. ومع ذلك، بفضل نظام الأنواع وقواعد الملكية في Rust، لا يمكنك الحصول على القفل والفتح بشكل خاطئ.

#### واجهة برمجة تطبيقات `Mutex<T>`

كمثال على كيفية استخدام mutex، دعونا نبدأ باستخدام mutex في سياق خيط واحد، كما هو موضح في القائمة 16-12.

<Listing number="16-12" file-name="src/main.rs" caption="استكشاف واجهة برمجة تطبيقات `Mutex<T>` في سياق خيط واحد من أجل البساطة">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-12/src/main.rs}}
```

</Listing>

كما هو الحال مع العديد من الأنواع، نُنشئ `Mutex<T>` باستخدام الدالة المرتبطة `new`. للوصول إلى البيانات داخل الـ mutex، نستخدم دالة `lock` للحصول على القفل. سيحجب هذا الاستدعاء الخيط الحالي حتى لا يتمكن من القيام بأي عمل حتى يحين دورنا للحصول على القفل.

سيفشل الاستدعاء إلى `lock` إذا ذعر خيط آخر يحمل القفل. في هذه الحالة، لن يتمكن أحد من الحصول على القفل، لذلك اخترنا `unwrap` وجعل هذا الخيط يذعر إذا كنا في هذا الوضع.

بعد أن حصلنا على القفل، يمكننا التعامل مع قيمة الإرجاع، المسماة `num` في هذه الحالة، كمرجع قابل للتغيير إلى البيانات الداخلية. يضمن نظام الأنواع أننا نحصل على قفل قبل استخدام القيمة في `m`. نوع `m` هو `Mutex<i32>`، وليس `i32`، لذلك يجب علينا استدعاء `lock` لنتمكن من استخدام قيمة `i32`. لا يمكننا أن ننسى؛ لن يسمح لنا نظام الأنواع بالوصول إلى `i32` الداخلية بطريقة أخرى.

يُرجع الاستدعاء إلى `lock` نوعاً يسمى `MutexGuard`، ملفوفاً في `LockResult` الذي تعاملنا معه بالاستدعاء إلى `unwrap`. ينفذ نوع `MutexGuard` السِمة `Deref` للإشارة إلى بياناتنا الداخلية؛ كما أن النوع لديه تنفيذ `Drop` يُطلق القفل تلقائياً عندما يخرج `MutexGuard` من النطاق، وهو ما يحدث في نهاية النطاق الداخلي. نتيجة لذلك، لا نخاطر بنسيان إطلاق القفل وحجب الـ mutex من الاستخدام بواسطة خيوط أخرى لأن إطلاق القفل يحدث تلقائياً.

بعد إسقاط القفل، يمكننا طباعة قيمة الـ mutex ورؤية أننا تمكنا من تغيير `i32` الداخلية إلى `6`.

<!-- Old headings. Do not remove or links may break. -->

<a id="sharing-a-mutext-between-multiple-threads"></a>

#### الوصول المشترك إلى `Mutex<T>`

الآن دعونا نحاول مشاركة قيمة بين خيوط متعددة باستخدام `Mutex<T>`. سنقوم بإطلاق 10 خيوط ونجعل كل منها يزيد قيمة عداد بمقدار 1، بحيث ينتقل العداد من 0 إلى 10. سيكون للمثال في القائمة 16-13 خطأ في المصرِّف، وسنستخدم هذا الخطأ لمعرفة المزيد عن استخدام `Mutex<T>` وكيف تساعدنا Rust في استخدامه بشكل صحيح.

<Listing number="16-13" file-name="src/main.rs" caption="عشرة خيوط، كل منها يزيد عداداً محروساً بواسطة `Mutex<T>`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-13/src/main.rs}}
```

</Listing>

نُنشئ متغير `counter` لاحتواء `i32` داخل `Mutex<T>`، كما فعلنا في القائمة 16-12. بعد ذلك، نُنشئ 10 خيوط عن طريق التكرار على نطاق من الأرقام. نستخدم `thread::spawn` ونعطي جميع الخيوط نفس الإغلاق: واحد ينقل العداد إلى الخيط، ويحصل على قفل على `Mutex<T>` عن طريق استدعاء دالة `lock`، ثم يضيف 1 إلى القيمة في الـ mutex. عندما ينتهي خيط من تشغيل إغلاقه، سيخرج `num` من النطاق ويطلق القفل بحيث يمكن لخيط آخر الحصول عليه.

في الخيط الرئيسي، نجمع جميع معالجات الانضمام. ثم، كما فعلنا في القائمة 16-2، نستدعي `join` على كل معالج للتأكد من أن جميع الخيوط تنتهي. في تلك النقطة، سيحصل الخيط الرئيسي على القفل ويطبع نتيجة هذا البرنامج.

لمحنا إلى أن هذا المثال لن يترجم. الآن دعونا نكتشف السبب!

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-13/output.txt}}
```

تشير رسالة الخطأ إلى أن قيمة `counter` تم نقلها في التكرار السابق للحلقة. تخبرنا Rust أننا لا نستطيع نقل ملكية القفل `counter` إلى خيوط متعددة. دعونا نصلح خطأ المصرِّف بطريقة الملكية المتعددة التي ناقشناها في الفصل 15.

#### الملكية المتعددة مع خيوط متعددة

في الفصل 15، أعطينا قيمة لمالكين متعددين باستخدام المؤشر الذكي `Rc<T>` لإنشاء قيمة معدودة المراجع. دعونا نفعل نفس الشيء هنا ونرى ماذا يحدث. سنلف `Mutex<T>` في `Rc<T>` في القائمة 16-14 ونستنسخ `Rc<T>` قبل نقل الملكية إلى الخيط.

<Listing number="16-14" file-name="src/main.rs" caption="محاولة استخدام `Rc<T>` للسماح لخيوط متعددة بامتلاك `Mutex<T>`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-14/src/main.rs}}
```

</Listing>

مرة أخرى، نقوم بالترجمة ونحصل على... أخطاء مختلفة! المصرِّف يعلمنا الكثير:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-14/output.txt}}
```

واو، رسالة الخطأ هذه طويلة جداً! إليك الجزء المهم الذي يجب التركيز عليه: `` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. يخبرنا المصرِّف أيضاً بالسبب: `` the trait `Send` is not implemented for `Rc<Mutex<i32>>` ``. سنتحدث عن `Send` في القسم التالي: إنها واحدة من السِمات التي تضمن أن الأنواع التي نستخدمها مع الخيوط مخصصة للاستخدام في المواقف المتزامنة.

لسوء الحظ، `Rc<T>` ليس آمناً للمشاركة عبر الخيوط. عندما تدير `Rc<T>` عدد المراجع، فإنها تضيف إلى العدد لكل استدعاء لـ `clone` وتطرح من العدد عندما يتم إسقاط كل استنساخ. لكنها لا تستخدم أي أوليات تزامن للتأكد من أن التغييرات في العدد لا يمكن مقاطعتها بواسطة خيط آخر. قد يؤدي هذا إلى عدد خاطئ - أخطاء دقيقة يمكن أن تؤدي بدورها إلى تسريبات في الذاكرة أو إسقاط قيمة قبل أن ننتهي منها. ما نحتاجه هو نوع مثل تماماً `Rc<T>`، لكنه يجري تغييرات على عدد المراجع بطريقة آمنة للخيوط.

#### العد الذري للمراجع مع `Arc<T>`

لحسن الحظ، `Arc<T>` هو نوع مثل `Rc<T>` آمن للاستخدام في المواقف المتزامنة. الحرف a يرمز إلى ذري (Atomic)، مما يعني أنه نوع معدود المراجع ذرياً (Atomically reference-counted). الذريات هي نوع إضافي من أوليات التزامن لن نغطيها بالتفصيل هنا: راجع توثيق المكتبة القياسية لـ [`std::sync::atomic`][atomic]<!-- ignore --> لمزيد من التفاصيل. في هذه المرحلة، تحتاج فقط إلى معرفة أن الذريات تعمل مثل الأنواع الأولية ولكنها آمنة للمشاركة عبر الخيوط.

قد تتساءل بعد ذلك لماذا جميع الأنواع الأولية ليست ذرية ولماذا أنواع المكتبة القياسية لا يتم تنفيذها لاستخدام `Arc<T>` بشكل افتراضي. السبب هو أن أمان الخيوط يأتي مع عقوبة أداء تريد دفعها فقط عندما تحتاج إليها حقاً. إذا كنت تقوم فقط بإجراء عمليات على القيم داخل خيط واحد، فيمكن لكودك أن يعمل بشكل أسرع إذا لم يكن عليه فرض الضمانات التي توفرها الذريات.

دعونا نعود إلى مثالنا: `Arc<T>` و `Rc<T>` لهما نفس واجهة برمجة التطبيقات، لذا نصلح برنامجنا بتغيير سطر `use` واستدعاء `new` واستدعاء `clone`. سيترجم الكود في القائمة 16-15 ويعمل أخيراً.

<Listing number="16-15" file-name="src/main.rs" caption="استخدام `Arc<T>` لتغليف `Mutex<T>` لتتمكن من مشاركة الملكية عبر خيوط متعددة">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-15/src/main.rs}}
```

</Listing>

سيطبع هذا الكود ما يلي:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Result: 10
```

لقد فعلناها! عددنا من 0 إلى 10، وهو ما قد لا يبدو مثيراً للإعجاب، لكنه علمنا الكثير عن `Mutex<T>` وأمان الخيوط. يمكنك أيضاً استخدام بنية هذا البرنامج للقيام بعمليات أكثر تعقيداً من مجرد زيادة عداد. باستخدام هذه الاستراتيجية، يمكنك تقسيم حساب إلى أجزاء مستقلة، وتقسيم تلك الأجزاء عبر الخيوط، ثم استخدام `Mutex<T>` لجعل كل خيط يحدث النتيجة النهائية بجزءه.

لاحظ أنه إذا كنت تقوم بعمليات رقمية بسيطة، فهناك أنواع أبسط من أنواع `Mutex<T>` توفرها وحدة [`std::sync::atomic` من المكتبة القياسية][atomic]<!-- ignore -->. توفر هذه الأنواع وصولاً آمناً ومتزامناً وذرياً إلى الأنواع الأولية. اخترنا استخدام `Mutex<T>` مع نوع أولي لهذا المثال حتى نتمكن من التركيز على كيفية عمل `Mutex<T>`.

<!-- Old headings. Do not remove or links may break. -->

<a id="similarities-between-refcelltrct-and-mutextarct"></a>

### مقارنة `RefCell<T>`/`Rc<T>` و `Mutex<T>`/`Arc<T>`

قد تكون لاحظت أن `counter` غير قابل للتغيير لكننا تمكنا من الحصول على مرجع قابل للتغيير إلى القيمة بداخله؛ هذا يعني أن `Mutex<T>` توفر قابلية التغيير الداخلية، كما تفعل عائلة `Cell`. بنفس الطريقة التي استخدمنا بها `RefCell<T>` في الفصل 15 للسماح لنا بتغيير المحتويات داخل `Rc<T>`، نستخدم `Mutex<T>` لتغيير المحتويات داخل `Arc<T>`.

تفصيل آخر يجب ملاحظته هو أن Rust لا يمكنها حمايتك من جميع أنواع الأخطاء المنطقية عند استخدام `Mutex<T>`. تذكر من الفصل 15 أن استخدام `Rc<T>` جاء مع خطر إنشاء دورات مرجعية، حيث تشير قيمتان `Rc<T>` إلى بعضهما البعض، مما يسبب تسريبات في الذاكرة. بالمثل، `Mutex<T>` يأتي مع خطر إنشاء جمود (Deadlocks). تحدث هذه عندما تحتاج عملية إلى قفل موردين واكتسب خيطان كل واحد منهما أحد الأقفال، مما يتسبب في انتظارهما لبعضهما البعض إلى الأبد. إذا كنت مهتماً بالجمود، فحاول إنشاء برنامج Rust به جمود؛ ثم ابحث عن استراتيجيات تخفيف الجمود للأقفال المتبادلة في أي لغة وحاول تنفيذها في Rust. توفر وثائق واجهة برمجة تطبيقات المكتبة القياسية لـ `Mutex<T>` و `MutexGuard` معلومات مفيدة.

سنختتم هذا الفصل بالحديث عن سِمات `Send` و `Sync` وكيف يمكننا استخدامها مع الأنواع المخصصة.

[atomic]: ../std/sync/atomic/index.html
