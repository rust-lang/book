<!-- Old headings. Do not remove or links may break. -->

<a id="developing-the-librarys-functionality-with-test-driven-development"></a>

## إضافة وظيفة باستخدام التطوير الموجه بالاختبار

الآن بعد أن أصبح لدينا منطق البحث في _src/lib.rs_ منفصلاً عن دالة `main`، أصبح
من الأسهل بكثير كتابة اختبارات للوظيفة الأساسية لكودنا. يمكننا استدعاء الدوال
مباشرة بمعاملات مختلفة والتحقق من قيم الإرجاع دون الحاجة إلى استدعاء ملفنا
الثنائي من سطر الأوامر.

في هذا القسم، سنضيف منطق البحث إلى برنامج `minigrep` باستخدام عملية التطوير
الموجه بالاختبار (TDD) بالخطوات التالية:

1. اكتب اختبارًا يفشل وشغّله للتأكد من أنه يفشل للسبب الذي تتوقعه.
2. اكتب أو عدّل كودًا كافيًا فقط لجعل الاختبار الجديد ينجح.
3. أعد هيكلة الكود الذي أضفته أو غيرته للتو وتأكد من أن الاختبارات تستمر في
   النجاح.
4. كرر من الخطوة 1!

على الرغم من أنها مجرد واحدة من العديد من الطرق لكتابة البرامج، يمكن أن يساعد
TDD في دفع تصميم الكود. كتابة الاختبار قبل كتابة الكود الذي يجعل الاختبار ينجح
يساعد في الحفاظ على تغطية اختبار عالية طوال العملية.

سنقوم باختبار دفع تطبيق الوظيفة التي ستقوم فعليًا بالبحث عن نص الاستعلام في
محتويات الملف وإنتاج قائمة بالأسطر التي تطابق الاستعلام. سنضيف هذه الوظيفة في
دالة تُسمى `search`.

### كتابة اختبار فاشل

في _src/lib.rs_، سنضيف وحدة `tests` مع دالة اختبار، كما فعلنا في [الفصل
11][ch11-anatomy]<!-- ignore -->. تحدد دالة الاختبار السلوك الذي نريد أن تتمتع به
دالة `search`: ستأخذ استعلامًا والنص المراد البحث فيه، وستُرجع فقط الأسطر من
النص التي تحتوي على الاستعلام. توضح القائمة 12-15 هذا الاختبار.

<Listing number="12-15" file-name="src/lib.rs" caption="إنشاء اختبار فاشل لدالة `search` للوظيفة التي نتمنى أن نمتلكها">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

</Listing>

يبحث هذا الاختبار عن النص `"duct"`. النص الذي نبحث فيه هو ثلاثة أسطر، واحد فقط
منها يحتوي على `"duct"` (لاحظ أن الشرطة المائلة العكسية بعد علامة الاقتباس
المزدوجة الافتتاحية تخبر Rust بعدم وضع حرف سطر جديد في بداية محتويات هذا النص
الحرفي). نؤكد أن القيمة المُرجعة من دالة `search` تحتوي فقط على السطر الذي
نتوقعه.

إذا قمنا بتشغيل هذا الاختبار، فسيفشل حاليًا لأن ماكرو `unimplemented!` يسبب ذعرًا
برسالة "not implemented". وفقًا لمبادئ TDD، سنأخذ خطوة صغيرة بإضافة كود كافٍ فقط
لعدم حدوث ذعر للاختبار عند استدعاء الدالة من خلال تعريف دالة `search` لإرجاع
متجه فارغ دائمًا، كما هو موضح في القائمة 12-16. بعد ذلك، يجب أن يُصرّف الاختبار
ويفشل لأن المتجه الفارغ لا يطابق متجهًا يحتوي على السطر `"safe, fast,
productive."`.

<Listing number="12-16" file-name="src/lib.rs" caption="تعريف ما يكفي فقط من دالة `search` بحيث لا يتسبب استدعاؤها في ذعر">

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

</Listing>

الآن لنناقش لماذا نحتاج إلى تعريف مدة صلاحية صريحة `'a` في توقيع `search`
واستخدام تلك المدة مع معامل `contents` وقيمة الإرجاع. تذكر في [الفصل
10][ch10-lifetimes]<!-- ignore --> أن معاملات مدة الصلاحية تحدد أي معامل مدة
صلاحية متصل بمدة صلاحية قيمة الإرجاع. في هذه الحالة، نشير إلى أن المتجه المُرجع
يجب أن يحتوي على شرائح نصية تشير إلى شرائح من معامل `contents` (بدلاً من معامل
`query`).

بعبارة أخرى، نخبر Rust أن البيانات المُرجعة بواسطة دالة `search` ستعيش طالما
البيانات الممررة إلى دالة `search` في معامل `contents`. هذا مهم! البيانات
المشار إليها _بواسطة_ شريحة يجب أن تكون صالحة حتى يكون المَرجِع صالحًا؛ إذا
افترض المصرِّف أننا ننشئ شرائح نصية من `query` بدلاً من `contents`، فسيقوم
بفحص الأمان بشكل غير صحيح.

إذا نسينا توضيحات مدة الصلاحية وحاولنا تصريف هذه الدالة، فسنحصل على هذا الخطأ:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

لا يمكن لـ Rust معرفة أي من المعاملين نحتاجه للإخراج، لذا نحتاج إلى إخباره
صراحةً. لاحظ أن نص المساعدة يقترح تحديد نفس معامل مدة الصلاحية لجميع المعاملات
ونوع الإخراج، وهذا غير صحيح! لأن `contents` هو المعامل الذي يحتوي على كل نصنا
ونريد إرجاع أجزاء من ذلك النص التي تطابق، نعلم أن `contents` هو المعامل الوحيد
الذي يجب أن يكون متصلاً بقيمة الإرجاع باستخدام بناء جملة مدة الصلاحية.

لا تتطلب منك لغات البرمجة الأخرى ربط المعاملات بقيم الإرجاع في التوقيع، لكن هذه
الممارسة ستصبح أسهل مع مرور الوقت. قد ترغب في مقارنة هذا المثال بالأمثلة في
قسم ["التحقق من المَراجِع باستخدام مُدد
الصلاحية"][validating-references-with-lifetimes]<!-- ignore --> في الفصل 10.

### كتابة كود لاجتياز الاختبار

حاليًا، يفشل اختبارنا لأننا نعيد دائمًا متجهًا فارغًا. لإصلاح ذلك وتطبيق
`search`، يحتاج برنامجنا إلى اتباع هذه الخطوات:

1. التكرار عبر كل سطر من المحتويات.
2. التحقق مما إذا كان السطر يحتوي على نص استعلامنا.
3. إذا كان كذلك، أضفه إلى قائمة القيم التي نعيدها.
4. إذا لم يكن كذلك، لا تفعل شيئًا.
5. أرجع قائمة النتائج التي تطابق.

لنعمل عبر كل خطوة، بدءًا من التكرار عبر الأسطر.

#### التكرار عبر الأسطر باستخدام تابع `lines`

لدى Rust تابع مفيد للتعامل مع التكرار سطرًا بسطر من النصوص، يُسمى بشكل مناسب
`lines`، والذي يعمل كما هو موضح في القائمة 12-17. لاحظ أن هذا لن يُصرّف بعد.

<Listing number="12-17" file-name="src/lib.rs" caption="التكرار عبر كل سطر في `contents`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

</Listing>

يُرجع تابع `lines` مُكرِّرًا. سنتحدث عن المُكرِّرات بعمق في [الفصل
13][ch13-iterators]<!-- ignore -->. لكن تذكر أنك رأيت هذه الطريقة لاستخدام
مُكرِّر في [القائمة 3-5][ch3-iter]<!-- ignore -->، حيث استخدمنا حلقة `for` مع
مُكرِّر لتشغيل بعض الكود على كل عنصر في مجموعة.

#### البحث في كل سطر عن الاستعلام

بعد ذلك، سنتحقق مما إذا كان السطر الحالي يحتوي على نص استعلامنا. لحسن الحظ،
لدى النصوص تابع مفيد يُسمى `contains` يفعل ذلك لنا! أضف استدعاءً لتابع
`contains` في دالة `search`، كما هو موضح في القائمة 12-18. لاحظ أن هذا لن يُصرّف
بعد.

<Listing number="12-18" file-name="src/lib.rs" caption="إضافة وظيفة لمعرفة ما إذا كان السطر يحتوي على النص في `query`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

</Listing>

في الوقت الحالي، نقوم ببناء الوظيفة. للحصول على الكود للتصريف، نحتاج إلى إرجاع
قيمة من الجسم كما أشرنا إليه في توقيع الدالة.

#### تخزين الأسطر المطابقة

لإنهاء هذه الدالة، نحتاج إلى طريقة لتخزين الأسطر المطابقة التي نريد إرجاعها.
لذلك، يمكننا إنشاء متجه قابل للتغيير قبل حلقة `for` واستدعاء تابع `push` لتخزين
`line` في المتجه. بعد حلقة `for`، نعيد المتجه، كما هو موضح في القائمة 12-19.

<Listing number="12-19" file-name="src/lib.rs" caption="تخزين الأسطر التي تطابق حتى نتمكن من إرجاعها">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

</Listing>

الآن يجب أن تُرجع دالة `search` فقط الأسطر التي تحتوي على `query`، ويجب أن ينجح
اختبارنا. لنقم بتشغيل الاختبار:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

نجح اختبارنا، إذن نحن نعلم أنه يعمل!

في هذه المرحلة، يمكننا أن ننظر في فرص لإعادة هيكلة تطبيق دالة البحث مع الحفاظ
على نجاح الاختبارات للحفاظ على نفس الوظيفة. الكود في دالة البحث ليس سيئًا جدًا،
لكنه لا يستفيد من بعض الميزات المفيدة للمُكرِّرات. سنعود إلى هذا المثال في
[الفصل 13][ch13-iterators]<!-- ignore -->، حيث سنستكشف المُكرِّرات بالتفصيل،
وننظر في كيفية تحسينه.

الآن يجب أن يعمل البرنامج بأكمله! لنجربه، أولاً بكلمة يجب أن تعيد سطرًا واحدًا
بالضبط من قصيدة إيميلي ديكنسون: _frog_.

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

رائع! الآن لنجرب كلمة ستطابق عدة أسطر، مثل _body_:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

وأخيرًا، لنتأكد من أننا لا نحصل على أي أسطر عندما نبحث عن كلمة غير موجودة في
القصيدة، مثل _monomorphization_:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

ممتاز! لقد بنينا نسختنا الصغيرة الخاصة من أداة كلاسيكية وتعلمنا الكثير عن كيفية
هيكلة التطبيقات. لقد تعلمنا أيضًا القليل عن إدخال وإخراج الملفات، ومُدد
الصلاحية، والاختبار، وتحليل سطر الأوامر.

لتكملة هذا المشروع، سنوضح بإيجاز كيفية العمل مع متغيرات البيئة وكيفية الطباعة
إلى الخطأ القياسي، وكلاهما مفيد عند كتابة برامج سطر الأوامر.

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
