## توسعه قابلیت‌های کتابخانه با توسعه آزمون‌محور (TDD) یا همان (Test-Driven Development)

اکنون که منطق جست‌وجو را در فایل *src/lib.rs* و جدا از تابع `main` داریم، نوشتن تست برای عملکرد اصلی کد بسیار آسان‌تر شده است.
می‌توانیم توابع را مستقیماً با آرگومان‌های مختلف فراخوانی کنیم و مقادیر بازگشتی را بررسی کنیم، بدون آن‌که نیاز باشد باینری خود را از طریق خط فرمان اجرا کنیم.

در این بخش، منطق جستجو را با استفاده از فرآیند توسعه آزمون‌محور (TDD) به برنامه `minigrep` اضافه خواهیم کرد. مراحل این فرآیند به شرح زیر است:

<ol dir="rtl">
  <li>نوشتن یک تست که شکست می‌خورد و اجرای آن برای اطمینان از اینکه به دلیلی که انتظار داشتید شکست می‌خورد.</li>
  <li>نوشتن یا تغییر کد به اندازه‌ای که تست جدید پاس شود.</li>
  <li>بازسازی کدی که به تازگی اضافه یا تغییر داده شده و اطمینان از اینکه تست‌ها همچنان پاس می‌شوند.</li>
  <li>تکرار از مرحله ۱!</li>
</ol>

TDD تنها یکی از روش‌های نوشتن نرم‌افزار است، اما می‌تواند به طراحی بهتر کد کمک کند. نوشتن تست قبل از نوشتن کدی که تست را پاس می‌کند، کمک می‌کند تا پوشش تست بالا در طول فرآیند حفظ شود.

ما با استفاده از TDD پیاده‌سازی قابلیت جستجوی رشته کوئری در محتوای فایل و تولید لیستی از خطوط مطابق با کوئری را توسعه خواهیم داد. این قابلیت را در تابعی به نام `search` اضافه خواهیم کرد.

### نوشتن یک تست که شکست می‌خورد

در فایل *src/lib.rs*، یک ماژول `tests` با یک تابع تست اضافه می‌کنیم، همان‌طور که در \[فصل ۱۱]\[ch11-anatomy]<!-- ignore --> انجام دادیم.
تابع تست، رفتاری را که از تابع `search` انتظار داریم مشخص می‌کند: این تابع یک `query` و متنی برای جست‌وجو دریافت می‌کند، و تنها خطوطی از متن را که شامل `query` هستند بازمی‌گرداند.
لیست ۱۲-۱۵ این تست را نشان می‌دهد.

<Listing number="12-15" file-name="src/lib.rs" caption="ایجاد یک تست شکست‌خورده برای تابع `search` به منظور پیاده‌سازی عملکرد مورد انتظار">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

</Listing>

این تست به دنبال رشته `"duct"` می‌گردد. متنی که در آن جستجو می‌کنیم شامل سه خط است که تنها یکی از آن‌ها شامل `"duct"` است (توجه داشته باشید که بک‌اسلش بعد از علامت نقل قول بازکننده به Rust می‌گوید که کاراکتر newline در ابتدای محتویات این literal رشته قرار ندهد). ما تأیید می‌کنیم که مقدار بازگردانده شده از تابع `search` تنها شامل خطی است که انتظار داریم.

هنوز قادر به اجرای این تست و مشاهده شکست آن نیستیم زیرا تست حتی کامپایل نمی‌شود: تابع `search` هنوز وجود ندارد! بر اساس اصول TDD، ما تنها به اندازه‌ای کد اضافه می‌کنیم که تست کامپایل و اجرا شود، با اضافه کردن یک تعریف از تابع `search` که همیشه یک بردار خالی بازمی‌گرداند، همانطور که در لیست ۱۲-۱۶ نشان داده شده است. سپس تست باید کامپایل و شکست بخورد زیرا یک بردار خالی با یک بردار شامل خط `"safe, fast, productive."` مطابقت ندارد.

<Listing number="12-16" file-name="src/lib.rs" caption="تعریف حداقل کد برای تابع `search` تا تست ما کامپایل شود">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

</Listing>

حال بیایید بررسی کنیم که چرا نیاز داریم یک lifetime صریح با نام `'a` در امضای تابع `search` تعریف کنیم و این lifetime را با آرگومان `contents` و مقدار بازگشتی استفاده کنیم.
به یاد بیاورید که در [فصل ۱۰][ch10-lifetimes]<!-- ignore -->، پارامترهای lifetime مشخص می‌کردند که lifetime کدام آرگومان با lifetime مقدار بازگشتی مرتبط است.
در این‌جا، مشخص می‌کنیم که بردار بازگشتی باید شامل برش‌هایی از رشته باشد که به بخش‌هایی از آرگومان `contents` رفرنس می‌دهند (نه آرگومان `query`).

متوجه می‌شوید که ما نیاز داریم یک طول عمر صریح `'a` در امضای تابع `search` تعریف کنیم و از آن طول عمر با آرگومان `contents` و مقدار بازگشتی استفاده کنیم. به یاد داشته باشید که در [فصل ۱۰][ch10-lifetimes] توضیح دادیم که پارامترهای طول عمر مشخص می‌کنند کدام طول عمر آرگومان به طول عمر مقدار بازگشتی متصل است. در این مورد، ما مشخص می‌کنیم که بردار بازگشتی باید شامل برش‌های رشته‌ای باشد که به برش‌های آرگومان `contents` اشاره دارند (نه آرگومان `query`).

به عبارت دیگر، به Rust می‌گوییم داده‌ای که توسط تابع `search` بازگردانده می‌شود به اندازه داده‌ای که به تابع `search` در آرگومان `contents` منتقل می‌شود زنده خواهد بود. این مهم است! داده‌ای که توسط یک برش مرجع داده می‌شود باید معتبر باشد تا مرجع نیز معتبر باشد؛ اگر کامپایلر فرض کند که ما در حال ساختن برش‌های رشته‌ای از `query` هستیم به جای `contents`، بررسی‌های ایمنی را به اشتباه انجام خواهد داد.

اگر طول عمرها را فراموش کنیم و سعی کنیم این تابع را کامپایل کنیم، این خطا را دریافت خواهیم کرد:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

کامپایلر Rust نمی‌تواند به‌صورت خودکار تشخیص دهد که کدام‌یک از دو پارامتر باید به مقدار بازگشتی مرتبط باشد، بنابراین باید این موضوع را به‌صراحت به آن اعلام کنیم.  
توجه داشته باشید که متن راهنمای خطا پیشنهاد می‌دهد که برای همه پارامترها و نوع بازگشتی، از یک پارامتر lifetime مشترک استفاده شود، که این پیشنهاد نادرست است!  
از آن‌جا که `contents` پارامتری است که تمام متن ما را در بر دارد و ما قصد داریم بخش‌هایی از آن متن را که با جستجو مطابقت دارند بازگردانیم، می‌دانیم که فقط `contents` باید با مقدار بازگشتی از طریق نگارش lifetime مرتبط شود.

دیگر زبان‌های برنامه‌نویسی نیازی ندارند آرگومان‌ها را به مقادیر بازگشتی در امضا متصل کنید، اما این تمرین با گذشت زمان آسان‌تر می‌شود. ممکن است بخواهید این مثال را با مثال‌های موجود در بخش [“اعتبارسنجی مراجع با طول عمر”][validating-references-with-lifetimes] از فصل ۱۰ مقایسه کنید.

### نوشتن کدی برای پاس کردن تست

در حال حاضر، تست ما به دلیل اینکه همیشه یک بردار خالی بازمی‌گرداند، شکست می‌خورد. برای رفع این مشکل و پیاده‌سازی `search`، برنامه ما باید این مراحل را دنبال کند:

<ol dir="rtl">
  <li>تکرار از طریق هر خط از محتوای فایل.</li>
  <li>بررسی اینکه آیا خط شامل رشته کوئری ما هست یا نه.</li>
  <li>اگر خط شامل کوئری بود، آن را به لیست مقادیر بازگشتی اضافه کنیم.</li>
  <li>اگر نبود، کاری انجام ندهیم.</li>
  <li>لیست نتایجی که مطابقت دارند را بازگردانیم.</li>
</ol>

بیایید هر مرحله را یکی‌یکی اجرا کنیم، با تکرار از طریق خطوط شروع می‌کنیم.

#### تکرار از طریق خطوط با متد `lines`

Rust یک متد مفید برای مدیریت تکرار خط به خط در رشته‌ها ارائه می‌دهد که به طور مناسبی `lines` نامیده شده است و همانطور که در لیست ۱۲-۱۷ نشان داده شده کار می‌کند. توجه داشته باشید که این کد هنوز کامپایل نخواهد شد.

<Listing number="12-17" file-name="src/lib.rs" caption="تکرار از طریق هر خط در `contents`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

</Listing>

متد `lines` یک iterator برمی‌گرداند. ما در [فصل ۱۳][ch13-iterators] عمیقاً در مورد iteratorها صحبت خواهیم کرد، اما به یاد داشته باشید که قبلاً این روش استفاده از یک iterator را در [لیست ۳-۵][ch3-iter] دیدید، جایی که از یک حلقه `for` با یک iterator برای اجرای کدی روی هر آیتم در یک مجموعه استفاده کردیم.

#### جستجو در هر خط برای کوئری

اکنون، بررسی خواهیم کرد که آیا خط فعلی شامل رشته کوئری ما هست یا نه. خوشبختانه، رشته‌ها یک متد مفید به نام `contains` دارند که این کار را برای ما انجام می‌دهد! یک فراخوانی به متد `contains` را در تابع `search` اضافه کنید، همانطور که در لیست ۱۲-۱۸ نشان داده شده است. توجه داشته باشید که این کد همچنان کامپایل نخواهد شد.

<Listing number="12-18" file-name="src/lib.rs" caption="اضافه کردن قابلیت بررسی اینکه آیا خط شامل رشته موجود در `query` هست یا نه">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

</Listing>

در حال حاضر، ما در حال ایجاد قابلیت‌های بیشتر هستیم. برای اینکه کد کامپایل شود، نیاز داریم مقداری را از بدنه تابع بازگردانیم همانطور که در امضای تابع اشاره کردیم.

#### ذخیره خطوط مطابق

برای تکمیل این تابع، نیاز داریم روشی برای ذخیره خطوط مطابق که می‌خواهیم بازگردانیم داشته باشیم. برای این کار، می‌توانیم یک بردار mutable قبل از حلقه `for` ایجاد کنیم و با استفاده از متد `push` یک خط را در بردار ذخیره کنیم. بعد از حلقه `for`، بردار را بازمی‌گردانیم، همانطور که در لیست ۱۲-۱۹ نشان داده شده است.

<Listing number="12-19" file-name="src/lib.rs" caption="ذخیره خطوط مطابق برای بازگرداندن آن‌ها">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

</Listing>

اکنون تابع `search` باید فقط خطوطی را که شامل `query` هستند بازگرداند، و تست ما باید پاس شود. بیایید تست را اجرا کنیم:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

تست ما پاس شد، بنابراین می‌دانیم که کار می‌کند!

در این مرحله، می‌توانیم فرصت‌هایی برای بازسازی پیاده‌سازی تابع جستجو در نظر بگیریم و در عین حال تست‌ها را پاس نگه داریم تا همان قابلیت را حفظ کنیم. کد در تابع جستجو چندان بد نیست، اما از برخی ویژگی‌های مفید iteratorها استفاده نمی‌کند. ما در [فصل ۱۳][ch13-iterators] به این مثال بازخواهیم گشت، جایی که iteratorها را با جزئیات بررسی می‌کنیم و به نحوه بهبود آن می‌پردازیم.

#### استفاده از تابع `search` در تابع `run`

اکنون که تابع `search` کار می‌کند و تست شده است، باید تابع `search` را از تابع `run` فراخوانی کنیم. ما باید مقدار `config.query` و `contents` که `run` از فایل می‌خواند را به تابع `search` بدهیم. سپس `run` هر خطی که از `search` برگردانده شده را چاپ خواهد کرد:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

ما هنوز از یک حلقه `for` برای بازگرداندن هر خط از `search` و چاپ آن استفاده می‌کنیم.

اکنون باید کل برنامه به‌درستی کار کند! بیایید آن را امتحان کنیم، ابتدا با واژه‌ای مانند *frog* که باید دقیقاً یک خط از شعر امیلی دیکینسون را بازگرداند.

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

عالی! حالا بیایید کلمه‌ای را امتحان کنیم که چندین خط را مطابقت دهد، مثل _body_:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

و در نهایت، مطمئن شویم که وقتی کلمه‌ای را جستجو می‌کنیم که در هیچ جای شعر وجود ندارد، مثل _monomorphization_، هیچ خطی دریافت نخواهیم کرد:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

عالی! ما نسخه کوچکی از یک ابزار کلاسیک ساختیم و چیزهای زیادی درباره نحوه ساختاردهی برنامه‌ها آموختیم. همچنین کمی درباره ورودی و خروجی فایل، طول عمر‌ها، تست کردن و تجزیه دستورات خط فرمان یاد گرفتیم.

برای تکمیل این پروژه، به طور مختصر نشان خواهیم داد که چگونه با متغیرهای محیطی کار کنیم و چگونه به خطای استاندارد (standard error) چاپ کنیم، که هر دو در هنگام نوشتن برنامه‌های خط فرمان مفید هستند.

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
