<!-- Old headings. Do not remove or links may break. -->

<a id="using-message-passing-to-transfer-data-between-threads"></a>

## نقل البيانات بين الخيوط (threads) باستخدام تمرير الرسائل (message passing)

أحد الأساليب الشائعة بشكل متزايد لضمان التزامن (concurrency) الآمن هو تمرير الرسائل (message passing)، حيث تتواصل الخيوط (threads) أو الفاعلون (actors) عن طريق إرسال رسائل تحتوي على بيانات لبعضهم البعض. إليك الفكرة في شعار من [توثيق لغة Go](https://golang.org/doc/effective_go.html#concurrency):
"لا تتواصل بمشاركة الذاكرة؛ بدلاً من ذلك، شارك الذاكرة بالتواصل."

لتحقيق تزامن إرسال الرسائل، توفر المكتبة القياسية لـ Rust تنفيذاً للقنوات (channels). القناة (channel) هي مفهوم برمجي عام يتم من خلاله إرسال البيانات من خيط (thread) إلى آخر.

يمكنك تخيل قناة في البرمجة على أنها قناة مائية اتجاهية، مثل جدول أو نهر. إذا وضعت شيئاً مثل بطة مطاطية في نهر، فسوف تسافر في اتجاه مجرى النهر إلى نهاية الممر المائي.

القناة لها نصفان: مُرسِل (Transmitter) ومُستقبِل (Receiver). النصف المُرسِل هو الموقع في أعلى النهر حيث تضع البطة المطاطية في النهر، والنصف المُستقبِل هو حيث تنتهي البطة المطاطية في أسفل النهر. يستدعي جزء واحد من كودك دوال على المُرسِل بالبيانات التي تريد إرسالها، ويتحقق جزء آخر من الطرف المُستقبِل للرسائل الواردة. يُقال إن القناة مغلقة (Closed) إذا تم إسقاط (Dropped) أي من النصف المُرسِل أو المُستقبِل.

هنا، سنعمل على برنامج يحتوي على خيط واحد لإنشاء قيم وإرسالها أسفل قناة، وخيط آخر سيستقبل القيم ويطبعها. سنرسل قيماً بسيطة بين الخيوط باستخدام قناة لتوضيح الميزة. بمجرد أن تصبح على دراية بالتقنية، يمكنك استخدام القنوات لأي خيوط تحتاج إلى التواصل مع بعضها البعض، مثل نظام محادثة أو نظام حيث تقوم العديد من الخيوط بأداء أجزاء من حساب وإرسال الأجزاء إلى خيط واحد يجمع النتائج.

أولاً، في القائمة 16-6، سننشئ قناة لكن لن نفعل أي شيء بها. لاحظ أن هذا لن يترجم بعد لأن Rust لا يمكنها معرفة نوع القيم التي نريد إرسالها عبر القناة.

<Listing number="16-6" file-name="src/main.rs" caption="إنشاء قناة وتعيين النصفين إلى `tx` و `rx`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-06/src/main.rs}}
```

</Listing>

ننشئ قناة جديدة باستخدام دالة `mpsc::channel`؛ `mpsc` يرمز إلى منتج متعدد، مستهلك واحد (Multiple producer, single consumer). باختصار، الطريقة التي تنفذ بها المكتبة القياسية لـ Rust القنوات تعني أن القناة يمكن أن يكون لها نهايات إرسال متعددة تنتج قيماً ولكن نهاية استقبال واحدة فقط تستهلك تلك القيم. تخيل جداول متعددة تتدفق معاً في نهر كبير واحد: كل شيء يتم إرساله أسفل أي من الجداول سينتهي في نهر واحد في النهاية. سنبدأ بمنتج واحد في الوقت الحالي، لكننا سنضيف منتجين متعددين عندما نجعل هذا المثال يعمل.

تُرجع دالة `mpsc::channel` صف (Tuple)، العنصر الأول منه هو نهاية الإرسال - المُرسِل - والعنصر الثاني هو نهاية الاستقبال - المُستقبِل. الاختصارات `tx` و `rx` تُستخدم تقليدياً في العديد من المجالات لـ "مُرسِل" (Transmitter) و "مُستقبِل" (Receiver) على التوالي، لذلك نسمي متغيراتنا على هذا النحو للإشارة إلى كل نهاية. نحن نستخدم بيان `let` مع نمط (Pattern) يفكك الصفوف؛ سنناقش استخدام الأنماط في بيانات `let` والتفكيك في الفصل 19. في الوقت الحالي، اعلم أن استخدام بيان `let` بهذه الطريقة هو نهج مريح لاستخراج أجزاء الصف المُرجع من `mpsc::channel`.

دعونا ننقل النهاية المُرسلة إلى خيط مُطلق ونجعله يرسل سلسلة نصية واحدة بحيث يتواصل الخيط المُطلق مع الخيط الرئيسي، كما هو موضح في القائمة 16-7. هذا مثل وضع بطة مطاطية في النهر في أعلى المجرى أو إرسال رسالة محادثة من خيط إلى آخر.

<Listing number="16-7" file-name="src/main.rs" caption='نقل `tx` إلى خيط مُطلق وإرسال `"hi"`'>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-07/src/main.rs}}
```

</Listing>

مرة أخرى، نحن نستخدم `thread::spawn` لإنشاء خيط جديد ثم نستخدم `move` لنقل `tx` إلى الإغلاق بحيث يمتلك الخيط المُطلق `tx`. يحتاج الخيط المُطلق إلى امتلاك المُرسِل ليتمكن من إرسال الرسائل عبر القناة.

المُرسِل لديه دالة `send` تأخذ القيمة التي نريد إرسالها. تُرجع دالة `send` نوع `Result<T, E>`، لذلك إذا تم إسقاط المُستقبِل بالفعل ولا يوجد مكان لإرسال قيمة، فستُرجع عملية الإرسال خطأً. في هذا المثال، نحن نستدعي `unwrap` للذعر في حالة حدوث خطأ. لكن في تطبيق حقيقي، سنتعامل معه بشكل صحيح: ارجع إلى الفصل 9 لمراجعة استراتيجيات المعالجة الصحيحة للأخطاء.

في القائمة 16-8، سنحصل على القيمة من المُستقبِل في الخيط الرئيسي. هذا مثل استرجاع البطة المطاطية من الماء في نهاية النهر أو استقبال رسالة محادثة.

<Listing number="16-8" file-name="src/main.rs" caption='استقبال القيمة `"hi"` في الخيط الرئيسي وطباعتها'>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-08/src/main.rs}}
```

</Listing>

المُستقبِل لديه دالتان مفيدتان: `recv` و `try_recv`. نحن نستخدم `recv`، اختصار لـ "استقبال" (Receive)، والتي ستحجب تنفيذ الخيط الرئيسي وتنتظر حتى يتم إرسال قيمة أسفل القناة. بمجرد إرسال قيمة، ستُرجع `recv` القيمة في `Result<T, E>`. عندما يغلق المُرسِل، ستُرجع `recv` خطأً للإشارة إلى أنه لن تأتي المزيد من القيم.

دالة `try_recv` لا تحجب، ولكن ستُرجع بدلاً من ذلك `Result<T, E>` على الفور: قيمة `Ok` تحتوي على رسالة إذا كانت واحدة متاحة وقيمة `Err` إذا لم تكن هناك أي رسائل هذه المرة. استخدام `try_recv` مفيد إذا كان لهذا الخيط عمل آخر يجب القيام به أثناء انتظار الرسائل: يمكننا كتابة حلقة تستدعي `try_recv` بين الحين والآخر، وتتعامل مع رسالة إذا كانت واحدة متاحة، وبخلاف ذلك تقوم بعمل آخر لفترة من الوقت قبل التحقق مرة أخرى.

استخدمنا `recv` في هذا المثال من أجل البساطة؛ ليس لدينا أي عمل آخر للخيط الرئيسي للقيام به بخلاف انتظار الرسائل، لذا فإن حجب الخيط الرئيسي مناسب.

عندما نقوم بتشغيل الكود في القائمة 16-8، سنرى القيمة مطبوعة من الخيط الرئيسي:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
```

ممتاز!

<!-- Old headings. Do not remove or links may break. -->

<a id="channels-and-ownership-transference"></a>

### نقل الملكية عبر القنوات

تلعب قواعد الملكية دوراً حيوياً في إرسال الرسائل لأنها تساعدك في كتابة كود آمن ومتزامن. منع الأخطاء في البرمجة المتزامنة هو ميزة التفكير في الملكية طوال برامج Rust الخاصة بك. دعونا نجري تجربة لإظهار كيف تعمل القنوات والملكية معاً لمنع المشاكل: سنحاول استخدام قيمة `val` في الخيط المُطلق بعد أن أرسلناها أسفل القناة. حاول ترجمة الكود في القائمة 16-9 لمعرفة سبب عدم السماح بهذا الكود.

<Listing number="16-9" file-name="src/main.rs" caption="محاولة استخدام `val` بعد أن أرسلناها أسفل القناة">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-09/src/main.rs}}
```

</Listing>

هنا، نحاول طباعة `val` بعد أن أرسلناها أسفل القناة عبر `tx.send`. السماح بهذا سيكون فكرة سيئة: بمجرد إرسال القيمة إلى خيط آخر، يمكن لهذا الخيط تعديلها أو إسقاطها قبل أن نحاول استخدام القيمة مرة أخرى. من المحتمل أن تتسبب تعديلات الخيط الآخر في حدوث أخطاء أو نتائج غير متوقعة بسبب البيانات غير المتسقة أو غير الموجودة. ومع ذلك، تعطينا Rust خطأً إذا حاولنا ترجمة الكود في القائمة 16-9:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-09/output.txt}}
```

تسبب خطأنا في التزامن في خطأ وقت الترجمة. تأخذ دالة `send` ملكية معاملها، وعندما يتم نقل القيمة، يأخذ المُستقبِل ملكيتها. هذا يمنعنا من استخدام القيمة عن طريق الخطأ مرة أخرى بعد إرسالها؛ يتحقق نظام الملكية من أن كل شيء على ما يرام.

<!-- Old headings. Do not remove or links may break. -->

<a id="sending-multiple-values-and-seeing-the-receiver-waiting"></a>

### إرسال قيم متعددة

تم ترجمة الكود في القائمة 16-8 وتشغيله، لكنه لم يُظهر لنا بوضوح أن خيطين منفصلين كانا يتحدثان إلى بعضهما البعض عبر القناة.

في القائمة 16-10، قمنا ببعض التعديلات التي ستثبت أن الكود في القائمة 16-8 يعمل بشكل متزامن: سيرسل الخيط المُطلق الآن رسائل متعددة ويتوقف لمدة ثانية واحدة بين كل رسالة.

<Listing number="16-10" file-name="src/main.rs" caption="إرسال رسائل متعددة والتوقف بين كل واحدة">

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-10/src/main.rs}}
```

</Listing>

هذه المرة، لدى الخيط المُطلق متجه من السلاسل النصية التي نريد إرسالها إلى الخيط الرئيسي. نكرر عليها، ونرسل كل واحدة على حدة، ونتوقف بينها بالاتصال بدالة `thread::sleep` بقيمة `Duration` لمدة ثانية واحدة.

في الخيط الرئيسي، لم نعد نستدعي دالة `recv` بشكل صريح: بدلاً من ذلك، نحن نعامل `rx` كمكرر (Iterator). لكل قيمة مستلمة، نقوم بطباعتها. عندما تُغلق القناة، سينتهي التكرار.

عند تشغيل الكود في القائمة 16-10، يجب أن ترى الناتج التالي مع توقف لمدة ثانية واحدة بين كل سطر:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: from
Got: the
Got: thread
```

لأننا ليس لدينا أي كود يتوقف أو يتأخر في حلقة `for` في الخيط الرئيسي، يمكننا معرفة أن الخيط الرئيسي ينتظر لاستقبال القيم من الخيط المُطلق.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-multiple-producers-by-cloning-the-transmitter"></a>

### إنشاء منتجين متعددين

ذكرنا سابقاً أن `mpsc` كانت اختصاراً لـ "منتج متعدد، مستهلك واحد" (Multiple producer, single consumer). دعونا نضع `mpsc` في الاستخدام ونوسع الكود في القائمة 16-10 لإنشاء خيوط متعددة تُرسل جميعها قيماً إلى نفس المُستقبِل. يمكننا القيام بذلك عن طريق استنساخ المُرسِل، كما هو موضح في القائمة 16-11.

<Listing number="16-11" file-name="src/main.rs" caption="إرسال رسائل متعددة من منتجين متعددين">

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-11/src/main.rs:here}}
```

</Listing>

هذه المرة، قبل أن ننشئ الخيط المُطلق الأول، نستدعي `clone` على المُرسِل. هذا سيعطينا مُرسِلاً جديداً يمكننا تمريره إلى الخيط المُطلق الأول. نمرر المُرسِل الأصلي إلى خيط مُطلق ثانٍ. هذا يعطينا خيطين، كل منهما يرسل رسائل مختلفة إلى مُستقبِل واحد.

عند تشغيل الكود، يجب أن يبدو الناتج الخاص بك كهذا:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```

قد ترى القيم بترتيب آخر، اعتماداً على نظامك. هذا ما يجعل التزامن مثيراً للاهتمام وكذلك صعباً. إذا قمت بالتجربة مع `thread::sleep`، وإعطائها قيماً مختلفة في خيوط مختلفة، فستكون كل عملية تشغيل أكثر غير حتمية وستخلق ناتجاً مختلفاً في كل مرة.

الآن بعد أن نظرنا إلى كيفية عمل القنوات، دعونا ننظر إلى طريقة مختلفة للتزامن.
