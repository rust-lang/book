## Hello, Cargo!

Cargo คือระบบ build และตัวจัดการแพ็กเกจของ Rust Rustaceans (ชื่อเรียกกลุ่มคนที่ใช้ Rust) ส่วนใหญ่ใช้เครื่องมือนี้เพื่อจัดการโปรเจกต์ Rust ของตนเอง เนื่องจาก Cargo จัดการงานหลายอย่างให้คุณ เช่น การ build โค้ด, การดาวน์โหลดไลบรารีที่โค้ดของคุณ εξαρτώμαι (depend on) และการ build ไลบรารีเหล่านั้น (เราเรียกไลบรารีที่โค้ดของคุณต้องการว่า _dependencies_ หรือการพึ่งพา)

โปรแกรม Rust ที่ง่ายที่สุด เช่น โปรแกรมที่เราเขียนไปก่อนหน้านี้ ไม่มีการพึ่งพาใดๆ หากเรา build โปรเจกต์ “Hello, world!” ด้วย Cargo มันจะใช้เฉพาะส่วนของ Cargo ที่จัดการการ build โค้ดของคุณเท่านั้น เมื่อคุณเขียนโปรแกรม Rust ที่ซับซ้อนมากขึ้น คุณจะเพิ่มการพึ่งพา และหากคุณเริ่มโปรเจกต์โดยใช้ Cargo การเพิ่มการพึ่งพาจะทำได้ง่ายขึ้นมาก

เนื่องจากโปรเจกต์ Rust ส่วนใหญ่ใช้ Cargo หนังสือเล่มนี้ที่เหลือจึงตั้งสมมติฐานว่าคุณกำลังใช้ Cargo ด้วยเช่นกัน Cargo จะถูกติดตั้งมาพร้อมกับ Rust หากคุณใช้ตัวติดตั้งอย่างเป็นทางการที่กล่าวถึงในส่วน [“การติดตั้ง”][installation]<!-- ignore --> หากคุณติดตั้ง Rust ด้วยวิธีอื่น ให้ตรวจสอบว่า Cargo ติดตั้งอยู่หรือไม่โดยป้อนคำสั่งต่อไปนี้ในเทอร์มินัลของคุณ:

```console
$ cargo --version
```

หากคุณเห็นหมายเลขเวอร์ชัน แสดงว่าคุณมีมันแล้ว! หากคุณเห็นข้อผิดพลาด เช่น `command not found` ให้ดูเอกสารประกอบสำหรับวิธีการติดตั้งของคุณเพื่อดูวิธีติดตั้ง Cargo แยกต่างหาก

### การสร้างโปรเจกต์ด้วย Cargo

มาสร้างโปรเจกต์ใหม่โดยใช้ Cargo และดูว่ามันแตกต่างจากโปรเจกต์ “Hello, world!” ดั้งเดิมของเราอย่างไร กลับไปที่ไดเรกทอรี _projects_ ของคุณ (หรือที่ใดก็ตามที่คุณตัดสินใจเก็บโค้ดของคุณ) จากนั้น บนระบบปฏิบัติการใดก็ได้ ให้รันคำสั่งต่อไปนี้:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

คำสั่งแรกสร้างไดเรกทอรีและโปรเจกต์ใหม่ชื่อ _hello_cargo_ เราตั้งชื่อโปรเจกต์ของเราว่า _hello_cargo_ และ Cargo จะสร้างไฟล์ต่างๆ ในไดเรกทอรีที่มีชื่อเดียวกัน

เข้าไปในไดเรกทอรี _hello_cargo_ และแสดงรายการไฟล์ คุณจะเห็นว่า Cargo ได้สร้างไฟล์สองไฟล์และหนึ่งไดเรกทอรีให้เรา: ไฟล์ _Cargo.toml_ และไดเรกทอรี _src_ ที่มีไฟล์ _main.rs_ อยู่ข้างใน

นอกจากนี้ยังได้เริ่มต้น Git repository ใหม่พร้อมกับไฟล์ _.gitignore_ ด้วย ไฟล์ Git จะไม่ถูกสร้างขึ้นหากคุณรัน `cargo new` ภายใน Git repository ที่มีอยู่แล้ว คุณสามารถแทนที่พฤติกรรมนี้ได้โดยใช้ `cargo new --vcs=git`

> หมายเหตุ: Git เป็นระบบควบคุมเวอร์ชันที่ใช้กันทั่วไป คุณสามารถเปลี่ยน `cargo new` ให้ใช้ระบบควบคุมเวอร์ชันอื่นหรือไม่ใช้ระบบควบคุมเวอร์ชันเลยก็ได้โดยใช้แฟล็ก `--vcs` รัน `cargo new --help` เพื่อดูตัวเลือกที่มี

เปิดไฟล์ _Cargo.toml_ ในโปรแกรมแก้ไขข้อความที่คุณเลือก มันควรจะมีลักษณะคล้ายกับโค้ดใน Listing 1-2

<Listing number="1-2" file-name="Cargo.toml" caption="เนื้อหาของไฟล์ *Cargo.toml* ที่สร้างโดย `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

</Listing>

ไฟล์นี้อยู่ในรูปแบบ [_TOML_][toml]<!-- ignore --> (_Tom’s Obvious, Minimal Language_) ซึ่งเป็นรูปแบบการกำหนดค่าของ Cargo

บรรทัดแรก `[package]` เป็นส่วนหัวของส่วนที่ระบุว่าคำสั่งต่อไปนี้เป็นการกำหนดค่าแพ็กเกจ เมื่อเราเพิ่มข้อมูลเพิ่มเติมลงในไฟล์นี้ เราจะเพิ่มส่วนอื่นๆ เข้าไป

สามบรรทัดถัดไปตั้งค่าข้อมูลการกำหนดค่าที่ Cargo ต้องการเพื่อคอมไพล์โปรแกรมของคุณ: ชื่อ, เวอร์ชัน และ edition ของ Rust ที่จะใช้ เราจะพูดถึงคีย์ `edition` ใน [ภาคผนวก E][appendix-e]<!-- ignore -->

บรรทัดสุดท้าย `[dependencies]` เป็นจุดเริ่มต้นของส่วนที่คุณจะระบุรายการการพึ่งพาใดๆ ของโปรเจกต์ของคุณ ใน Rust แพ็กเกจของโค้ดจะเรียกว่า _crates_ (เครท) เราจะไม่ต้องการ крейт อื่นๆ สำหรับโปรเจกต์นี้ แต่เราจะต้องการในโปรเจกต์แรกในบทที่ 2 ดังนั้นเราจะใช้ส่วนการพึ่งพานี้ในตอนนั้น

ตอนนี้เปิดไฟล์ _src/main.rs_ แล้วดู:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo ได้สร้างโปรแกรม “Hello, world!” ให้คุณ เช่นเดียวกับที่เราเขียนใน Listing 1-1! จนถึงตอนนี้ ความแตกต่างระหว่างโปรเจกต์ของเรากับโปรเจกต์ที่ Cargo สร้างขึ้นคือ Cargo วางโค้ดไว้ในไดเรกทอรี _src_ และเรามีไฟล์การกำหนดค่า _Cargo.toml_ ในไดเรกทอรีบนสุด

Cargo คาดหวังว่าไฟล์ซอร์สโค้ดของคุณจะอยู่ในไดเรกทอรี _src_ ไดเรกทอรีโปรเจกต์ระดับบนสุดมีไว้สำหรับไฟล์ README, ข้อมูลใบอนุญาต, ไฟล์การกำหนดค่า และสิ่งอื่นใดที่ไม่เกี่ยวข้องกับโค้ดของคุณ การใช้ Cargo ช่วยให้คุณจัดระเบียบโปรเจกต์ของคุณได้ มีที่สำหรับทุกสิ่ง และทุกสิ่งก็อยู่ในที่ของมัน

หากคุณเริ่มโปรเจกต์ที่ไม่ได้ใช้ Cargo เช่นเดียวกับที่เราทำกับโปรเจกต์ “Hello, world!” คุณสามารถแปลงมันเป็นโปรเจกต์ที่ใช้ Cargo ได้ ย้ายโค้ดโปรเจกต์เข้าไปในไดเรกทอรี _src_ และสร้างไฟล์ _Cargo.toml_ ที่เหมาะสม วิธีหนึ่งที่ง่ายในการรับไฟล์ _Cargo.toml_ นั้นคือการรัน `cargo init` ซึ่งจะสร้างให้คุณโดยอัตโนมัติ

### การ Build และรันโปรเจกต์ Cargo

ตอนนี้มาดูว่ามีอะไรแตกต่างออกไปเมื่อเรา build และรันโปรแกรม “Hello, world!” ด้วย Cargo! จากไดเรกทอรี _hello_cargo_ ของคุณ ให้ build โปรเจกต์ของคุณโดยป้อนคำสั่งต่อไปนี้:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

คำสั่งนี้สร้างไฟล์ εκτελέσιμο (executable) ใน _target/debug/hello_cargo_ (หรือ _target\debug\hello_cargo.exe_ บน Windows) แทนที่จะอยู่ในไดเรกทอรีปัจจุบันของคุณ เนื่องจากการ build เริ่มต้นเป็นการ build แบบดีบัก Cargo จึงใส่ไบนารีไว้ในไดเรกทอรีชื่อ _debug_ คุณสามารถรันไฟล์ εκτελέσιμο (executable) ด้วยคำสั่งนี้:

```console
$ ./target/debug/hello_cargo # หรือ .\target\debug\hello_cargo.exe บน Windows
Hello, world!
```

หากทุกอย่างเป็นไปด้วยดี `Hello, world!` ควรจะพิมพ์ออกทางเทอร์มินัล การรัน `cargo build` เป็นครั้งแรกยังทำให้ Cargo สร้างไฟล์ใหม่ที่ระดับบนสุดด้วย: _Cargo.lock_ ไฟล์นี้ติดตามเวอร์ชันที่แน่นอนของการพึ่งพาในโปรเจกต์ของคุณ โปรเจกต์นี้ไม่มีการพึ่งพา ดังนั้นไฟล์จึงค่อนข้างเบาบาง คุณจะไม่ต้องเปลี่ยนแปลงไฟล์นี้ด้วยตนเองเลย Cargo จะจัดการเนื้อหาให้คุณ

เราเพิ่ง build โปรเจกต์ด้วย `cargo build` และรันมันด้วย `./target/debug/hello_cargo` แต่เรายังสามารถใช้ `cargo run` เพื่อคอมไพล์โค้ดแล้วรันไฟล์ εκτελέσιμο (executable) ที่ได้ทั้งหมดในคำสั่งเดียว:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

การใช้ `cargo run` สะดวกกว่าการต้องจำว่าต้องรัน `cargo build` แล้วใช้พาธเต็มไปยังไบนารี ดังนั้นนักพัฒนาส่วนใหญ่จึงใช้ `cargo run`

สังเกตว่าครั้งนี้เราไม่เห็นผลลัพธ์ที่ระบุว่า Cargo กำลังคอมไพล์ `hello_cargo` Cargo ตรวจพบว่าไฟล์ไม่มีการเปลี่ยนแปลง ดังนั้นจึงไม่ได้ build ใหม่ แต่แค่รันไบนารีเท่านั้น หากคุณแก้ไขซอร์สโค้ดของคุณ Cargo จะ build โปรเจกต์ใหม่ก่อนที่จะรัน และคุณจะเห็นผลลัพธ์นี้:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo ยังมีคำสั่งที่เรียกว่า `cargo check` คำสั่งนี้จะตรวจสอบโค้ดของคุณอย่างรวดเร็วเพื่อให้แน่ใจว่ามันคอมไพล์ได้ แต่จะไม่สร้างไฟล์ εκτελέσιμο (executable):

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

ทำไมคุณถึงไม่ต้องการไฟล์ εκτελέσιμο (executable)? บ่อยครั้งที่ `cargo check` เร็วกว่า `cargo build` มาก เพราะมันข้ามขั้นตอนการสร้างไฟล์ εκτελέσιμο (executable) หากคุณตรวจสอบงานของคุณอย่างต่อเนื่องในขณะที่เขียนโค้ด การใช้ `cargo check` จะช่วยเร่งกระบวนการแจ้งให้คุณทราบว่าโปรเจกต์ของคุณยังคงคอมไพล์ได้หรือไม่! ด้วยเหตุนี้ Rustaceans จำนวนมากจึงรัน `cargo check` เป็นระยะๆ ขณะที่เขียนโปรแกรมเพื่อให้แน่ใจว่ามันคอมไพล์ได้ จากนั้นพวกเขาก็รัน `cargo build` เมื่อพร้อมที่จะใช้ไฟล์ εκτελέσιμο (executable)

มาสรุปสิ่งที่เราได้เรียนรู้เกี่ยวกับ Cargo จนถึงตอนนี้:

- เราสามารถสร้างโปรเจกต์โดยใช้ `cargo new`
- เราสามารถ build โปรเจกต์โดยใช้ `cargo build`
- เราสามารถ build และรันโปรเจกต์ในขั้นตอนเดียวโดยใช้ `cargo run`
- เราสามารถ build โปรเจกต์โดยไม่สร้างไบนารีเพื่อตรวจสอบข้อผิดพลาดโดยใช้ `cargo check`
- แทนที่จะบันทึกผลลัพธ์ของการ build ในไดเรกทอรีเดียวกับโค้ดของเรา Cargo จะเก็บไว้ในไดเรกทอรี _target/debug_

ข้อดีเพิ่มเติมของการใช้ Cargo คือคำสั่งต่างๆ จะเหมือนกันไม่ว่าคุณจะทำงานบนระบบปฏิบัติการใดก็ตาม ดังนั้น ณ จุดนี้ เราจะไม่ให้คำแนะนำเฉพาะสำหรับ Linux และ macOS เทียบกับ Windows อีกต่อไป

### การ Build สำหรับ Release

เมื่อโปรเจกต์ของคุณพร้อมสำหรับการเผยแพร่แล้ว คุณสามารถใช้ `cargo build --release` เพื่อคอมไพล์ด้วยการปรับให้เหมาะสม (optimizations) คำสั่งนี้จะสร้างไฟล์ εκτελέσιμο (executable) ใน _target/release_ แทน _target/debug_ การปรับให้เหมาะสมทำให้โค้ด Rust ของคุณทำงานเร็วขึ้น แต่การเปิดใช้งานจะทำให้โปรแกรมของคุณใช้เวลาคอมไพล์นานขึ้น นี่คือเหตุผลว่าทำไมจึงมีโปรไฟล์ที่แตกต่างกันสองแบบ: แบบหนึ่งสำหรับการพัฒนา เมื่อคุณต้องการ build ใหม่บ่อยๆ และรวดเร็ว และอีกแบบหนึ่งสำหรับการ build โปรแกรมสุดท้ายที่คุณจะมอบให้ผู้ใช้ ซึ่งจะไม่ถูก build ซ้ำๆ และจะทำงานให้เร็วที่สุดเท่าที่จะเป็นไปได้ หากคุณกำลังวัดประสิทธิภาพ (benchmarking) เวลาการทำงานของโค้ดของคุณ อย่าลืมรัน `cargo build --release` และวัดประสิทธิภาพด้วยไฟล์ εκτελέσιμο (executable) ใน _target/release_

### Cargo ในฐานะแบบแผนปฏิบัติ

สำหรับโปรเจกต์ง่ายๆ Cargo ไม่ได้ให้คุณค่ามากไปกว่าการใช้ `rustc` เพียงอย่างเดียว แต่มันจะพิสูจน์คุณค่าของมันเมื่อโปรแกรมของคุณมีความซับซ้อนมากขึ้น เมื่อโปรแกรมเติบโตจนมีหลายไฟล์หรือต้องการการพึ่งพา การให้ Cargo ประสานงานการ build จะง่ายกว่ามาก

แม้ว่าโปรเจกต์ `hello_cargo` จะเรียบง่าย แต่ตอนนี้มันใช้เครื่องมือจริงส่วนใหญ่ที่คุณจะใช้ในอาชีพ Rust ที่เหลือของคุณ ในความเป็นจริง ในการทำงานกับโปรเจกต์ที่มีอยู่ใดๆ คุณสามารถใช้คำสั่งต่อไปนี้เพื่อตรวจสอบโค้ดโดยใช้ Git เปลี่ยนไปยังไดเรกทอรีของโปรเจกต์นั้น และ build:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ Cargo โปรดดู [เอกสารประกอบ][cargo]

## สรุป

คุณเริ่มต้นการเดินทาง Rust ของคุณได้อย่างยอดเยี่ยมแล้ว! ในบทนี้ คุณได้เรียนรู้วิธี:

- ติดตั้ง Rust เวอร์ชันเสถียรล่าสุดโดยใช้ `rustup`
- อัปเดตเป็น Rust เวอร์ชันใหม่กว่า
- เปิดเอกสารประกอบที่ติดตั้งในเครื่อง
- เขียนและรันโปรแกรม “Hello, world!” โดยใช้ `rustc` โดยตรง
- สร้างและรันโปรเจกต์ใหม่โดยใช้แบบแผนปฏิบัติของ Cargo

นี่เป็นช่วงเวลาที่ดีในการสร้างโปรแกรมที่มีเนื้อหามากขึ้นเพื่อทำความคุ้นเคยกับการอ่านและเขียนโค้ด Rust ดังนั้น ในบทที่ 2 เราจะสร้างโปรแกรมเกมทายตัวเลข หากคุณต้องการเริ่มต้นด้วยการเรียนรู้ว่าแนวคิดการเขียนโปรแกรมทั่วไปทำงานอย่างไรใน Rust โปรดดูบทที่ 3 แล้วกลับมาที่บทที่ 2

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
