## مرحباً، Cargo!

Cargo هو نظام البناء ومدير الحزم الخاص بـ Rust. يستخدم معظم مطوري Rust هذه الأداة لإدارة مشاريع Rust الخاصة بهم لأن Cargo يتعامل مع الكثير من المهام نيابة عنك، مثل بناء الكود الخاص بك، وتنزيل المكتبات التي يعتمد عليها الكود الخاص بك، وبناء تلك المكتبات. (نسمي المكتبات التي يحتاجها الكود الخاص بك _dependencies_.)

برامج Rust الأبسط، مثل البرنامج الذي كتبناه حتى الآن، لا تحتوي على أي اعتماديات. لو قمنا ببناء مشروع "Hello, world!" باستخدام Cargo، فإنه سيستخدم فقط الجزء من Cargo الذي يتعامل مع بناء الكود الخاص بك. عندما تكتب برامج Rust أكثر تعقيداً، ستضيف اعتماديات، وإذا بدأت مشروعاً باستخدام Cargo، فإن إضافة الاعتماديات ستكون أسهل بكثير.

نظراً لأن الغالبية العظمى من مشاريع Rust تستخدم Cargo، فإن باقي هذا الكتاب يفترض أنك تستخدم Cargo أيضاً. يأتي Cargo مثبتاً مع Rust إذا كنت قد استخدمت برامج التثبيت الرسمية التي تمت مناقشتها في قسم ["التثبيت"][installation]<!-- ignore -->. إذا قمت بتثبيت Rust من خلال وسائل أخرى، تحقق مما إذا كان Cargo مثبتاً عن طريق إدخال ما يلي في الطرفية الخاصة بك:

```console
$ cargo --version
```

إذا رأيت رقم إصدار، فأنت تملكه! إذا رأيت خطأ، مثل `command not found`، فراجع التوثيق الخاص بطريقة التثبيت الخاصة بك لتحديد كيفية تثبيت Cargo بشكل منفصل.

### إنشاء مشروع باستخدام Cargo

لنقم بإنشاء مشروع جديد باستخدام Cargo ونلقِ نظرة على كيف يختلف عن مشروع "Hello, world!" الأصلي الخاص بنا. انتقل مرة أخرى إلى دليل _projects_ الخاص بك (أو أينما قررت تخزين الكود الخاص بك). ثم، على أي نظام تشغيل، قم بتشغيل ما يلي:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

الأمر الأول ينشئ دليلاً جديداً ومشروعاً يُسمى _hello_cargo_. لقد أطلقنا على مشروعنا اسم _hello_cargo_، و Cargo ينشئ ملفاته في دليل بنفس الاسم.

انتقل إلى دليل _hello_cargo_ واعرض قائمة الملفات. سترى أن Cargo قد أنشأ ملفين ودليلاً واحداً لنا: ملف _Cargo.toml_ ودليل _src_ مع ملف _main.rs_ بداخله.

كما قام أيضاً بتهيئة مستودع Git جديد مع ملف _.gitignore_. لن يتم إنشاء ملفات Git إذا قمت بتشغيل `cargo new` داخل مستودع Git موجود؛ يمكنك تجاوز هذا السلوك باستخدام `cargo new --vcs=git`.

> ملاحظة: Git هو نظام شائع للتحكم في الإصدارات. يمكنك تغيير `cargo new` لاستخدام نظام تحكم إصدارات مختلف أو عدم استخدام نظام تحكم إصدارات باستخدام علامة `--vcs`. قم بتشغيل `cargo new --help` لرؤية الخيارات المتاحة.

افتح _Cargo.toml_ في محرر النصوص المفضل لديك. يجب أن يبدو مشابهاً للكود في القائمة 1-2.

<Listing number="1-2" file-name="Cargo.toml" caption="محتويات *Cargo.toml* التي أنشأها `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

</Listing>

هذا الملف بتنسيق [_TOML_][toml]<!-- ignore --> (_Tom's Obvious, Minimal Language_)، وهو تنسيق التكوين الخاص بـ Cargo.

السطر الأول، `[package]`، هو عنوان قسم يشير إلى أن العبارات التالية تقوم بتكوين حزمة. عندما نضيف المزيد من المعلومات إلى هذا الملف، سنضيف أقساماً أخرى.

الأسطر الثلاثة التالية تحدد معلومات التكوين التي يحتاجها Cargo لتجميع برنامجك: الاسم والإصدار وإصدار Rust المستخدم. سنتحدث عن مفتاح `edition` في [الملحق E][appendix-e]<!-- ignore -->.

السطر الأخير، `[dependencies]`، هو بداية قسم لك لإدراج أي من اعتماديات مشروعك. في Rust، يُشار إلى حزم الكود باسم _crates_. لن نحتاج إلى أي صناديق أخرى لهذا المشروع، ولكننا سنحتاج في المشروع الأول في الفصل 2، لذلك سنستخدم قسم الاعتماديات هذا في ذلك الوقت.

الآن افتح _src/main.rs_ وألقِ نظرة:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

لقد أنشأ Cargo برنامج "Hello, world!" لك، تماماً مثل البرنامج الذي كتبناه في القائمة 1-1! حتى الآن، الاختلافات بين مشروعنا والمشروع الذي أنشأه Cargo هي أن Cargo وضع الكود في دليل _src_، ولدينا ملف تكوين _Cargo.toml_ في الدليل الأعلى.

يتوقع Cargo أن تكون ملفات المصدر الخاصة بك داخل دليل _src_. دليل المشروع الأعلى مخصص فقط لملفات README ومعلومات الترخيص وملفات التكوين وأي شيء آخر غير متعلق بالكود الخاص بك. استخدام Cargo يساعدك على تنظيم مشاريعك. هناك مكان لكل شيء، وكل شيء في مكانه.

إذا بدأت مشروعاً لا يستخدم Cargo، كما فعلنا مع مشروع "Hello, world!"، يمكنك تحويله إلى مشروع يستخدم Cargo. انقل كود المشروع إلى دليل _src_ وأنشئ ملف _Cargo.toml_ مناسب. إحدى الطرق السهلة للحصول على ملف _Cargo.toml_ هي تشغيل `cargo init`، والذي سينشئه لك تلقائياً.

### بناء وتشغيل مشروع Cargo

الآن دعنا ننظر إلى ما هو مختلف عندما نبني ونشغل برنامج "Hello, world!" باستخدام Cargo! من دليل _hello_cargo_ الخاص بك، قم ببناء مشروعك عن طريق إدخال الأمر التالي:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

ينشئ هذا الأمر ملفاً قابلاً للتنفيذ في _target/debug/hello_cargo_ (أو _target\debug\hello_cargo.exe_ على Windows) بدلاً من الدليل الحالي الخاص بك. نظراً لأن البناء الافتراضي هو بناء debug، يضع Cargo الملف الثنائي في دليل يُسمى _debug_. يمكنك تشغيل الملف القابل للتنفيذ بهذا الأمر:

```console
$ ./target/debug/hello_cargo # أو .\target\debug\hello_cargo.exe على Windows
Hello, world!
```

إذا سار كل شيء على ما يرام، يجب أن تُطبع `Hello, world!` على الطرفية. تشغيل `cargo build` للمرة الأولى يتسبب أيضاً في قيام Cargo بإنشاء ملف جديد في المستوى الأعلى: _Cargo.lock_. يتتبع هذا الملف الإصدارات الدقيقة من الاعتماديات في مشروعك. لا يحتوي هذا المشروع على اعتماديات، لذلك الملف يكون قليلاً نوعاً ما. لن تحتاج أبداً إلى تغيير هذا الملف يدوياً؛ يدير Cargo محتوياته نيابة عنك.

لقد قمنا للتو ببناء مشروع باستخدام `cargo build` وتشغيله باستخدام `./target/debug/hello_cargo`، ولكن يمكننا أيضاً استخدام `cargo run` لتجميع الكود ثم تشغيل الملف التنفيذي الناتج كله في أمر واحد:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

استخدام `cargo run` أكثر ملاءمة من الاضطرار إلى تذكر تشغيل `cargo build` ثم استخدام المسار الكامل للملف الثنائي، لذلك يستخدم معظم المطورين `cargo run`.

لاحظ أننا هذه المرة لم نرَ إخراجاً يشير إلى أن Cargo كان يجمع `hello_cargo`. اكتشف Cargo أن الملفات لم تتغير، لذلك لم يعد البناء بل قام فقط بتشغيل الملف الثنائي. إذا كنت قد عدّلت كود المصدر الخاص بك، كان Cargo سيعيد بناء المشروع قبل تشغيله، وكنت ستشاهد هذا الإخراج:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

يوفر Cargo أيضاً أمراً يُسمى `cargo check`. يتحقق هذا الأمر بسرعة من كودك للتأكد من أنه يُجمَّع ولكنه لا ينتج ملفاً قابلاً للتنفيذ:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

لماذا قد لا تريد ملفاً قابلاً للتنفيذ؟ غالباً، `cargo check` أسرع بكثير من `cargo build` لأنه يتخطى خطوة إنتاج ملف قابل للتنفيذ. إذا كنت تتحقق باستمرار من عملك أثناء كتابة الكود، فإن استخدام `cargo check` سيسرع عملية إعلامك إذا كان مشروعك لا يزال يُجمَّع! على هذا النحو، يقوم العديد من مطوري Rust بتشغيل `cargo check` بشكل دوري أثناء كتابة برنامجهم للتأكد من أنه يُجمَّع. ثم، يقومون بتشغيل `cargo build` عندما يكونون مستعدين لاستخدام الملف القابل للتنفيذ.

لنلخص ما تعلمناه حتى الآن عن Cargo:

- يمكننا إنشاء مشروع باستخدام `cargo new`.
- يمكننا بناء مشروع باستخدام `cargo build`.
- يمكننا بناء وتشغيل مشروع في خطوة واحدة باستخدام `cargo run`.
- يمكننا بناء مشروع دون إنتاج ملف ثنائي للتحقق من الأخطاء باستخدام `cargo check`.
- بدلاً من حفظ نتيجة البناء في نفس الدليل الذي يحتوي على كودنا، يخزنه Cargo في دليل _target/debug_.

ميزة إضافية لاستخدام Cargo هي أن الأوامر هي نفسها بغض النظر عن نظام التشغيل الذي تعمل عليه. لذلك، في هذه المرحلة، لن نقدم بعد الآن تعليمات محددة لـ Linux و macOS مقابل Windows.

### البناء للإصدار

عندما يكون مشروعك جاهزاً أخيراً للإصدار، يمكنك استخدام `cargo build --release` لتجميعه مع التحسينات. سينشئ هذا الأمر ملفاً قابلاً للتنفيذ في _target/release_ بدلاً من _target/debug_. التحسينات تجعل كود Rust الخاص بك يعمل بشكل أسرع، ولكن تشغيلها يطيل الوقت الذي يستغرقه برنامجك للتجميع. هذا هو السبب في وجود ملفين شخصيين مختلفين: واحد للتطوير، عندما تريد إعادة البناء بسرعة وبشكل متكرر، وآخر لبناء البرنامج النهائي الذي ستعطيه للمستخدم والذي لن يتم إعادة بنائه بشكل متكرر والذي سيعمل بأسرع ما يمكن. إذا كنت تقوم بقياس وقت تشغيل الكود الخاص بك، فتأكد من تشغيل `cargo build --release` والقياس باستخدام الملف القابل للتنفيذ في _target/release_.

<!-- Old headings. Do not remove or links may break. -->
<a id="cargo-as-convention"></a>

### الاستفادة من اصطلاحات Cargo

مع المشاريع البسيطة، لا يوفر Cargo الكثير من القيمة مقارنة باستخدام `rustc` فقط، ولكنه سيثبت قيمته مع تطور برامجك وأصبحت أكثر تعقيداً. بمجرد أن تنمو البرامج إلى ملفات متعددة أو تحتاج إلى اعتمادية، يكون من الأسهل بكثير ترك Cargo ينسق البناء.

على الرغم من أن مشروع `hello_cargo` بسيط، إلا أنه يستخدم الآن الكثير من الأدوات الحقيقية التي ستستخدمها في بقية مسيرتك المهنية في Rust. في الواقع، للعمل على أي مشاريع موجودة، يمكنك استخدام الأوامر التالية لسحب الكود باستخدام Git، والانتقال إلى دليل ذلك المشروع، والبناء:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

لمزيد من المعلومات حول Cargo، راجع [توثيقه][cargo].

## ملخص

أنت بالفعل في بداية رائعة في رحلتك مع Rust! في هذا الفصل، تعلمت كيفية:

- تثبيت أحدث إصدار مستقر من Rust باستخدام `rustup`.
- التحديث إلى إصدار Rust أحدث.
- فتح التوثيق المثبت محلياً.
- كتابة وتشغيل برنامج "Hello, world!" باستخدام `rustc` مباشرة.
- إنشاء وتشغيل مشروع جديد باستخدام اصطلاحات Cargo.

هذا وقت رائع لبناء برنامج أكثر أهمية للتعود على قراءة وكتابة كود Rust. لذا، في الفصل 2، سنبني برنامج لعبة التخمين. إذا كنت تفضل البدء بتعلم كيف تعمل مفاهيم البرمجة الشائعة في Rust، فراجع الفصل 3 ثم ارجع إلى الفصل 2.

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
