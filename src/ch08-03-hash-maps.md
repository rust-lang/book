## تخزين المفاتيح مع القيم المرتبطة في خرائط الهاش (Hash Maps)

آخر مجموعاتنا الشائعة هي خريطة الهاش (hash map). النوع `HashMap<K, V>` يخزن تعييناً للمفاتيح (keys) من النوع `K` إلى القيم (values) من النوع `V` باستخدام _دالة هاش_ (hash function)، والتي تحدد كيفية وضع هذه المفاتيح والقيم في الذاكرة. العديد من لغات البرمجة تدعم هذا النوع من هياكل البيانات، لكنها غالباً ما تستخدم اسماً مختلفاً، مثل _hash_، _map_، _object_، _hash table_، _dictionary_، أو _associative array_، على سبيل المثال لا الحصر.

خرائط الهاش مفيدة عندما تريد البحث عن البيانات ليس باستخدام فهرس (index)، كما يمكنك مع المتجهات (vectors)، ولكن باستخدام مفتاح (key) يمكن أن يكون من أي نوع. على سبيل المثال، في لعبة، يمكنك تتبع نقاط كل فريق في خريطة هاش حيث يكون كل مفتاح هو اسم الفريق والقيم هي نقاط كل فريق. بإعطاء اسم فريق، يمكنك استرجاع نقاطه.

سنستعرض واجهة برمجة التطبيقات الأساسية لخرائط الهاش في هذا القسم، لكن هناك الكثير من المزايا الإضافية مخفية في الدوال المعرفة على `HashMap<K, V>` من قبل المكتبة القياسية. كالعادة، راجع توثيق المكتبة القياسية لمزيد من المعلومات.

### إنشاء خريطة هاش جديدة

إحدى الطرق لإنشاء خريطة هاش فارغة هي استخدام `new` وإضافة العناصر (elements) باستخدام `insert`. في القائمة 8-20، نتتبع نقاط فريقين اسمهما _Blue_ و _Yellow_. يبدأ فريق Blue بـ 10 نقاط، ويبدأ فريق Yellow بـ 50.

<Listing number="8-20" caption="إنشاء خريطة هاش جديدة وإدراج (insert) بعض المفاتيح والقيم">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
```

</Listing>

لاحظ أننا بحاجة أولاً إلى `use` الـ `HashMap` من جزء المجموعات في المكتبة القياسية. من بين مجموعاتنا الثلاث الشائعة، هذه هي الأقل استخداماً، لذلك لا يتم تضمينها في الميزات التي يتم إحضارها إلى النطاق تلقائياً في prelude. خرائط الهاش أيضاً لديها دعم أقل من المكتبة القياسية؛ لا يوجد ماكرو مدمج لبنائها، على سبيل المثال.

تماماً مثل المتجهات، خرائط الهاش تخزن بياناتها على الكومة (heap). هذه الـ `HashMap` لديها مفاتيح من النوع `String` وقيم من النوع `i32`. مثل المتجهات، خرائط الهاش متجانسة: يجب أن تكون جميع المفاتيح من نفس النوع، ويجب أن تكون جميع القيم من نفس النوع.

### الوصول إلى القيم في خريطة الهاش

يمكننا الحصول على قيمة من خريطة الهاش من خلال توفير مفتاحها إلى الدالة `get`، كما هو موضح في القائمة 8-21.

<Listing number="8-21" caption="الوصول إلى نقاط فريق Blue المخزنة في خريطة الهاش">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
```

</Listing>

هنا، سيكون لـ `score` القيمة المرتبطة بفريق Blue، والنتيجة ستكون `10`. الدالة `get` تُرجع `Option<&V>`؛ إذا لم تكن هناك قيمة لهذا المفتاح في خريطة الهاش، ستُرجع `get` القيمة `None`. هذا البرنامج يتعامل مع `Option` من خلال استدعاء `copied` للحصول على `Option<i32>` بدلاً من `Option<&i32>`، ثم `unwrap_or` لتعيين `score` إلى صفر إذا لم يكن لدى `scores` إدخال للمفتاح.

يمكننا التكرار على كل زوج مفتاح-قيمة (key-value pair) في خريطة الهاش بطريقة مشابهة لما نفعله مع المتجهات، باستخدام حلقة `for`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
```

سيطبع هذا الكود كل زوج بترتيب عشوائي:

```text
Yellow: 50
Blue: 10
```

<!-- Old headings. Do not remove or links may break. -->

<a id="hash-maps-and-ownership"></a>

### إدارة الملكية في خرائط الهاش

بالنسبة للأنواع التي تنفذ خاصية `Copy`، مثل `i32`، يتم نسخ القيم إلى خريطة الهاش. بالنسبة للقيم المملوكة مثل `String`، سيتم نقل القيم وستكون خريطة الهاش هي مالكة تلك القيم، كما هو موضح في القائمة 8-22.

<Listing number="8-22" caption="توضيح أن المفاتيح والقيم مملوكة من قبل خريطة الهاش بمجرد إدراجها">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
```

</Listing>

لا يمكننا استخدام المتغيرات `field_name` و `field_value` بعد نقلها إلى خريطة الهاش من خلال استدعاء `insert`.

إذا أدرجنا مراجع للقيم في خريطة الهاش، فلن يتم نقل القيم إلى خريطة الهاش. القيم التي تشير إليها المراجع يجب أن تكون صالحة على الأقل طالما أن خريطة الهاش صالحة. سنتحدث أكثر عن هذه القضايا في [«التحقق من صحة المراجع مع الأعمار»][validating-references-with-lifetimes]<!-- ignore --> في الفصل 10.

### تحديث (update) خريطة الهاش

على الرغم من أن عدد أزواج المفاتيح والقيم قابل للنمو، إلا أن كل مفتاح فريد يمكن أن يكون له قيمة (value) واحدة فقط مرتبطة به في كل مرة (لكن ليس العكس: على سبيل المثال، يمكن أن يكون لكل من فريق Blue وفريق Yellow القيمة `10` مخزنة في خريطة الهاش `scores`).

عندما تريد تغيير البيانات في خريطة الهاش، عليك أن تقرر كيفية التعامل مع الحالة عندما يكون للمفتاح بالفعل قيمة معينة. يمكنك استبدال القيمة القديمة بالقيمة الجديدة، متجاهلاً القيمة القديمة تماماً. يمكنك الاحتفاظ بالقيمة القديمة وتجاهل القيمة الجديدة، بإضافة القيمة الجديدة فقط إذا كان المفتاح _لا_ يحتوي بالفعل على قيمة. أو يمكنك دمج القيمة القديمة والقيمة الجديدة. لنرى كيفية القيام بكل من هذه!

#### الكتابة فوق قيمة

إذا أدرجنا مفتاحاً وقيمة في خريطة هاش ثم أدرجنا نفس المفتاح بقيمة مختلفة، سيتم استبدال القيمة المرتبطة بهذا المفتاح. على الرغم من أن الكود في القائمة 8-23 يستدعي `insert` مرتين، ستحتوي خريطة الهاش على زوج مفتاح-قيمة واحد فقط لأننا ندرج القيمة لمفتاح فريق Blue في كلتا المرتين.

<Listing number="8-23" caption="استبدال قيمة مخزنة بمفتاح معين">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
```

</Listing>

سيطبع هذا الكود `{"Blue": 25}`. تم الكتابة فوق القيمة الأصلية `10`.

<!-- Old headings. Do not remove or links may break. -->

<a id="only-inserting-a-value-if-the-key-has-no-value"></a>

#### إضافة مفتاح وقيمة فقط إذا لم يكن المفتاح موجوداً

من الشائع التحقق مما إذا كان مفتاح معين موجوداً بالفعل في خريطة الهاش مع قيمة ثم اتخاذ الإجراءات التالية: إذا كان المفتاح موجوداً في خريطة الهاش، يجب أن تظل القيمة الموجودة كما هي؛ إذا لم يكن المفتاح موجوداً، أدرجه وقيمة له.

خرائط الهاش لديها واجهة برمجة تطبيقات خاصة لهذا تسمى `entry` تأخذ المفتاح الذي تريد التحقق منه كمعامل. قيمة الإرجاع للدالة `entry` هي enum تسمى `Entry` تمثل قيمة قد تكون موجودة أو غير موجودة. لنقل أننا نريد التحقق مما إذا كان المفتاح لفريق Yellow له قيمة مرتبطة به. إذا لم يكن كذلك، نريد إدراج القيمة `50`، وكذلك لفريق Blue. باستخدام واجهة برمجة التطبيقات `entry`، يبدو الكود كما في القائمة 8-24.

<Listing number="8-24" caption="استخدام الدالة `entry` للإدراج فقط إذا لم يكن للمفتاح قيمة بالفعل">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
```

</Listing>

الدالة `or_insert` على `Entry` معرفة لإرجاع مرجع قابل للتغيير إلى القيمة للمفتاح `Entry` المقابل إذا كان هذا المفتاح موجوداً، وإذا لم يكن كذلك، تُدرج المعامل كقيمة جديدة لهذا المفتاح وتُرجع مرجعاً قابلاً للتغيير إلى القيمة الجديدة. هذه التقنية أنظف بكثير من كتابة المنطق بأنفسنا وبالإضافة إلى ذلك، تعمل بشكل أفضل مع مدقق الاستعارة.

تشغيل الكود في القائمة 8-24 سيطبع `{"Yellow": 50, "Blue": 10}`. الاستدعاء الأول لـ `entry` سيُدرج المفتاح لفريق Yellow بالقيمة `50` لأن فريق Yellow ليس لديه قيمة بالفعل. الاستدعاء الثاني لـ `entry` لن يُغير خريطة الهاش، لأن فريق Blue لديه بالفعل القيمة `10`.

#### تحديث قيمة بناءً على القيمة القديمة

حالة استخدام شائعة أخرى لخرائط الهاش هي البحث عن قيمة مفتاح ثم تحديثها بناءً على القيمة القديمة. على سبيل المثال، تُظهر القائمة 8-25 كوداً يعد عدد مرات ظهور كل كلمة في بعض النصوص. نستخدم خريطة هاش مع الكلمات كمفاتيح ونزيد القيمة لتتبع عدد مرات رؤيتنا لتلك الكلمة. إذا كانت هذه هي المرة الأولى التي نرى فيها كلمة، سنُدرج أولاً القيمة `0`.

<Listing number="8-25" caption="عد تكرارات الكلمات باستخدام خريطة هاش تخزن الكلمات والأعداد">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
```

</Listing>

سيطبع هذا الكود `{"world": 2, "hello": 1, "wonderful": 1}`. قد ترى نفس أزواج المفتاح-القيمة مطبوعة بترتيب مختلف: تذكر من [«الوصول إلى القيم في خريطة الهاش»][access]<!-- ignore --> أن التكرار على خريطة هاش يحدث بترتيب عشوائي.

الدالة `split_whitespace` تُرجع مكرراً على الشرائح الفرعية، مفصولة بمسافة بيضاء، للقيمة في `text`. الدالة `or_insert` تُرجع مرجعاً قابلاً للتغيير (`&mut V`) للقيمة للمفتاح المحدد. هنا، نخزن هذا المرجع القابل للتغيير في المتغير `count`، لذا من أجل التعيين إلى تلك القيمة، يجب علينا أولاً إلغاء مرجع `count` باستخدام النجمة (`*`). المرجع القابل للتغيير يخرج من النطاق في نهاية حلقة `for`، لذا فإن كل هذه التغييرات آمنة ومسموح بها من قبل قواعد الاستعارة.

### دوال الهاش

بشكل افتراضي، تستخدم `HashMap` دالة هاش تسمى _SipHash_ يمكن أن توفر مقاومة لهجمات رفض الخدمة (DoS) التي تتضمن جداول الهاش[^siphash]<!-- ignore -->. هذه ليست أسرع خوارزمية هاش متاحة، لكن المقايضة للأمان الأفضل الذي يأتي مع انخفاض الأداء تستحق ذلك. إذا قمت بتحليل كودك ووجدت أن دالة الهاش الافتراضية بطيئة جداً لأغراضك، يمكنك التبديل إلى دالة أخرى من خلال تحديد hasher مختلف. _hasher_ هو نوع ينفذ خاصية `BuildHasher`. سنتحدث عن الخصائص وكيفية تنفيذها في [الفصل 10][traits]<!-- ignore -->. ليس عليك بالضرورة تنفيذ hasher الخاص بك من الصفر؛ [crates.io](https://crates.io/)<!-- ignore --> لديها مكتبات مشتركة من قبل مستخدمي Rust الآخرين توفر hashers تنفذ العديد من خوارزميات الهاش الشائعة.

[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)

## الملخص

ستوفر المتجهات والسلاسل النصية وخرائط الهاش قدراً كبيراً من الوظائف الضرورية في البرامج عندما تحتاج إلى تخزين البيانات والوصول إليها وتعديلها. إليك بعض التمارين التي يجب أن تكون مجهزاً الآن لحلها:

1. بالنظر إلى قائمة من الأعداد الصحيحة، استخدم متجهاً وأرجع الوسيط (عند الفرز، القيمة في الموضع الأوسط) والمنوال (القيمة التي تحدث في أغلب الأحيان؛ ستكون خريطة هاش مفيدة هنا) للقائمة.
2. حوّل السلاسل النصية إلى Pig Latin. ينقل الحرف الساكن الأول من كل كلمة إلى نهاية الكلمة ويضاف _ay_، لذا تصبح _first_ تصبح _irst-fay_. الكلمات التي تبدأ بحرف علة يضاف إليها _hay_ في النهاية بدلاً من ذلك (_apple_ تصبح _apple-hay_). ضع في اعتبارك تفاصيل ترميز UTF-8!
3. باستخدام خريطة هاش ومتجهات، أنشئ واجهة نصية للسماح للمستخدم بإضافة أسماء الموظفين إلى قسم في شركة؛ على سبيل المثال، «أضف Sally إلى الهندسة» أو «أضف Amir إلى المبيعات». ثم، اسمح للمستخدم باسترجاع قائمة بجميع الأشخاص في قسم أو جميع الأشخاص في الشركة حسب القسم، مرتبة أبجدياً.

توثيق واجهة برمجة التطبيقات للمكتبة القياسية يصف الدوال التي تمتلكها المتجهات والسلاسل النصية وخرائط الهاش والتي ستكون مفيدة لهذه التمارين!

نحن ندخل في برامج أكثر تعقيداً حيث يمكن أن تفشل العمليات، لذا فهذا وقت مثالي لمناقشة معالجة الأخطاء. سنفعل ذلك بعد ذلك!

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[access]: #accessing-values-in-a-hash-map
[traits]: ch10-02-traits.html
