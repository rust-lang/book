## استخدام `Box<T>` للإشارة إلى البيانات على الكومة

المؤشر الذكي الأكثر وضوحًا هو الصندوق (box)، والذي يُكتب نوعه `Box<T>`. _الصناديق_ (Boxes) تسمح لك بتخزين البيانات على الكومة (heap) بدلاً من المكدس (stack). ما يبقى على المكدس هو المؤشر إلى بيانات الكومة. ارجع إلى الفصل 4 لمراجعة الفرق بين المكدس والكومة.

الصناديق ليس لها عبء أداء، بخلاف تخزين بياناتها على الكومة بدلاً من المكدس. لكن ليس لديها العديد من القدرات الإضافية أيضًا. ستستخدمها غالبًا في هذه المواقف:

- عندما يكون لديك نوع لا يمكن معرفة حجمه في وقت الترجمة، وتريد استخدام قيمة من هذا النوع في سياق يتطلب حجمًا دقيقًا
- عندما يكون لديك كمية كبيرة من البيانات، وتريد نقل الملكية ولكن تأكد من أن البيانات لن يتم نسخها عند القيام بذلك
- عندما تريد امتلاك قيمة، وتهتم فقط بأنها نوع ينفذ سِمة معينة بدلاً من أن تكون من نوع محدد

سنوضح الحالة الأولى في ["تمكين الأنواع التكرارية باستخدام الصناديق"](#enabling-recursive-types-with-boxes)<!-- ignore -->. في الحالة الثانية، يمكن أن يستغرق نقل ملكية كمية كبيرة من البيانات وقتًا طويلاً لأن البيانات يتم نسخها على المكدس. لتحسين الأداء في هذه الحالة، يمكننا تخزين الكمية الكبيرة من البيانات على الكومة في صندوق. بعد ذلك، يتم نسخ الكمية الصغيرة من بيانات المؤشر فقط على المكدس، بينما تظل البيانات التي يشير إليها في مكان واحد على الكومة. الحالة الثالثة تُعرف باسم _كائن السِمة_ (trait object)، و["استخدام كائنات السِمة للتجريد عن السلوك المشترك"][trait-objects]<!-- ignore --> في الفصل 18 مخصص لهذا الموضوع. لذا، ما تتعلمه هنا ستطبقه مرة أخرى في ذلك القسم!

<!-- Old headings. Do not remove or links may break. -->

<a id="using-boxt-to-store-data-on-the-heap"></a>

### تخزين البيانات على الكومة

قبل أن نناقش حالة استخدام تخزين الكومة لـ `Box<T>`، سنغطي الصيغة وكيفية التفاعل مع القيم المخزنة داخل `Box<T>`.

يوضح القائمة 15-1 كيفية استخدام صندوق لتخزين قيمة `i32` على الكومة.

<Listing number="15-1" file-name="src/main.rs" caption="تخزين قيمة `i32` على الكومة باستخدام صندوق">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}
```

</Listing>

نحدد المتغير `b` ليكون له قيمة `Box` التي تشير إلى القيمة `5`، والتي يتم تخصيصها على الكومة. سيطبع هذا البرنامج `b = 5`؛ في هذه الحالة، يمكننا الوصول إلى البيانات في الصندوق بشكل مشابه لكيفية الوصول إليها إذا كانت هذه البيانات على المكدس. تمامًا مثل أي قيمة مملوكة، عندما يخرج صندوق عن النطاق، كما يفعل `b` في نهاية `main`، سيتم إلغاء تخصيصه. يحدث إلغاء التخصيص لكل من الصندوق (المخزن على المكدس) والبيانات التي يشير إليها (المخزنة على الكومة).

وضع قيمة واحدة على الكومة ليس مفيدًا جدًا، لذلك لن تستخدم الصناديق بهذه الطريقة بمفردها في كثير من الأحيان. وجود قيم مثل `i32` واحد على المكدس، حيث يتم تخزينها بشكل افتراضي، أكثر ملاءمة في غالبية الحالات. دعنا ننظر في حالة تسمح لنا فيها الصناديق بتعريف أنواع لن يُسمح لنا بتعريفها إذا لم يكن لدينا صناديق.

### تمكين الأنواع التكرارية باستخدام الصناديق

قيمة _النوع التكراري_ (recursive type) يمكن أن يكون لها قيمة أخرى من نفس النوع كجزء منها. الأنواع التكرارية تشكل مشكلة لأن Rust يحتاج إلى معرفة كم من المساحة يشغلها النوع في وقت الترجمة. ومع ذلك، يمكن أن يستمر تداخل قيم الأنواع التكرارية نظريًا إلى ما لا نهاية، لذلك لا تستطيع Rust معرفة كم من المساحة تحتاج القيمة. نظرًا لأن الصناديق لها حجم معروف، يمكننا تمكين الأنواع التكرارية عن طريق إدراج صندوق في تعريف النوع التكراري.

كمثال على نوع تكراري، دعنا نستكشف قائمة cons. هذا نوع بيانات يُوجد عادةً في لغات البرمجة الوظيفية. نوع قائمة cons الذي سنحدده بسيط باستثناء التكرار؛ لذلك، ستكون المفاهيم في المثال الذي سنعمل عليه مفيدة في أي وقت تدخل فيه في مواقف أكثر تعقيدًا تتضمن أنواعًا تكرارية.

<!-- Old headings. Do not remove or links may break. -->

<a id="more-information-about-the-cons-list"></a>

#### فهم قائمة Cons

_قائمة cons_ هي هيكل بيانات يأتي من لغة البرمجة Lisp ولهجاتها، وتتكون من أزواج متداخلة، وهي نسخة Lisp من القائمة المرتبطة. يأتي اسمها من دالة `cons` (اختصار لـ _دالة البناء_ construct function) في Lisp التي تبني زوجًا جديدًا من معاملاتها. عن طريق استدعاء `cons` على زوج يتكون من قيمة وزوج آخر، يمكننا بناء قوائم cons مكونة من أزواج تكرارية.

على سبيل المثال، إليك تمثيل pseudocode لقائمة cons تحتوي على القائمة `1, 2, 3` مع كل زوج بين قوسين:

```text
(1, (2, (3, Nil)))
```

كل عنصر في قائمة cons يحتوي على عنصرين: قيمة العنصر الحالي وقيمة العنصر التالي. العنصر الأخير في القائمة يحتوي على قيمة فقط تسمى `Nil` بدون عنصر تالٍ. يتم إنتاج قائمة cons عن طريق استدعاء دالة `cons` بشكل تكراري. الاسم القانوني للإشارة إلى الحالة الأساسية للتكرار هو `Nil`. لاحظ أن هذا ليس نفس مفهوم "null" أو "nil" الذي تم مناقشته في الفصل 6، وهو قيمة غير صالحة أو غائبة.

قائمة cons ليست هيكل بيانات شائع الاستخدام في Rust. معظم الوقت عندما يكون لديك قائمة من العناصر في Rust، `Vec<T>` هو خيار أفضل للاستخدام. هياكل البيانات التكرارية الأخرى الأكثر تعقيدًا _مفيدة_ في مواقف مختلفة، لكن من خلال البدء بقائمة cons في هذا الفصل، يمكننا استكشاف كيف تتيح لنا الصناديق تعريف نوع بيانات تكراري دون الكثير من التشتيت.

تحتوي القائمة 15-2 على تعريف enum لقائمة cons. لاحظ أن هذا الكود لن يتم ترجمته بعد، لأن نوع `List` لا يمتلك حجمًا معروفًا، وهو ما سنوضحه.

<Listing number="15-2" file-name="src/main.rs" caption="المحاولة الأولى لتعريف enum لتمثيل هيكل بيانات قائمة cons من قيم `i32`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}
```

</Listing>

> ملاحظة: نحن ننفذ قائمة cons تحتفظ فقط بقيم `i32` لأغراض هذا المثال. كان يمكننا تنفيذها باستخدام الأنواع العمومية (generics)، كما ناقشنا في الفصل 10، لتعريف نوع قائمة cons يمكن أن يخزن قيمًا من أي نوع.

استخدام نوع `List` لتخزين القائمة `1, 2, 3` سيبدو مثل الكود في القائمة 15-3.

<Listing number="15-3" file-name="src/main.rs" caption="استخدام enum `List` لتخزين القائمة `1, 2, 3`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}
```

</Listing>

قيمة `Cons` الأولى تحتفظ بـ `1` وقيمة `List` أخرى. قيمة `List` هذه هي قيمة `Cons` أخرى تحتفظ بـ `2` وقيمة `List` أخرى. قيمة `List` هذه هي قيمة `Cons` واحدة أخرى تحتفظ بـ `3` وقيمة `List`، والتي هي أخيرًا `Nil`، المتغير غير التكراري الذي يشير إلى نهاية القائمة.

إذا حاولنا ترجمة الكود في القائمة 15-3، سنحصل على الخطأ الموضح في القائمة 15-4.

<Listing number="15-4" caption="الخطأ الذي نحصل عليه عند محاولة تعريف enum تكراري">

```console
{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
```

</Listing>

يوضح الخطأ أن هذا النوع "له حجم لا نهائي". السبب هو أننا عرّفنا `List` بمتغير تكراري: يحتفظ بقيمة أخرى من نفسه مباشرة. نتيجة لذلك، لا تستطيع Rust معرفة كم من المساحة يحتاج لتخزين قيمة `List`. دعنا نحلل سبب حصولنا على هذا الخطأ. أولاً، سننظر في كيفية قرار Rust لكمية المساحة التي يحتاجها لتخزين قيمة من نوع غير تكراري.

#### حساب حجم النوع غير التكراري

تذكر enum `Message` الذي عرفناه في القائمة 6-2 عندما ناقشنا تعريفات enum في الفصل 6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

لتحديد كم من المساحة لتخصيصها لقيمة `Message`، تمر Rust عبر كل من المتغيرات لمعرفة أي متغير يحتاج إلى أكبر مساحة. تجد Rust أن `Message::Quit` لا يحتاج إلى أي مساحة، `Message::Move` يحتاج إلى مساحة كافية لتخزين قيمتين `i32`، وهكذا. لأن متغيرًا واحدًا فقط سيتم استخدامه، فإن أكثر مساحة ستحتاجها قيمة `Message` هي المساحة التي ستستغرقها لتخزين الأكبر من متغيراتها.

قارن هذا مع ما يحدث عندما تحاول Rust تحديد كم من المساحة يحتاجها نوع تكراري مثل enum `List` في القائمة 15-2. يبدأ المصرِّف بالنظر إلى متغير `Cons`، الذي يحتفظ بقيمة من نوع `i32` وقيمة من نوع `List`. لذلك، يحتاج `Cons` إلى مقدار من المساحة يساوي حجم `i32` بالإضافة إلى حجم `List`. لمعرفة كم من الذاكرة يحتاجها نوع `List`، ينظر المصرِّف إلى المتغيرات، بدءًا من متغير `Cons`. يحتفظ متغير `Cons` بقيمة من نوع `i32` وقيمة من نوع `List`، وتستمر هذه العملية إلى ما لا نهاية، كما هو موضح في الشكل 15-1.

<img alt="An infinite Cons list: a rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Cons' and a smaller version of the outer 'Cons' rectangle. The 'Cons' rectangles continue to hold smaller and smaller versions of themselves until the smallest comfortably sized rectangle holds an infinity symbol, indicating that this repetition goes on forever." src="img/trpl15-01.svg" class="center" style="width: 50%;" />

<span class="caption">الشكل 15-1: `List` لا نهائية تتكون من متغيرات `Cons` لا نهائية</span>

<!-- Old headings. Do not remove or links may break. -->

<a id="using-boxt-to-get-a-recursive-type-with-a-known-size"></a>

#### الحصول على نوع تكراري بحجم معروف

نظرًا لأن Rust لا يمكنها معرفة كم من المساحة لتخصيصها للأنواع المعرّفة بشكل تكراري، يعطي المصرِّف خطأ مع هذا الاقتراح المفيد:

<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->

```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

في هذا الاقتراح، _التوجيه غير المباشر_ (indirection) يعني أنه بدلاً من تخزين قيمة مباشرة، يجب أن نغير هيكل البيانات لتخزين القيمة بشكل غير مباشر عن طريق تخزين مؤشر إلى القيمة بدلاً من ذلك.

لأن `Box<T>` هو مؤشر، تعرف Rust دائمًا كم من المساحة يحتاجها `Box<T>`: حجم المؤشر لا يتغير بناءً على كمية البيانات التي يشير إليها. هذا يعني أن بإمكاننا وضع `Box<T>` داخل متغير `Cons` بدلاً من قيمة `List` أخرى مباشرة. سيشير `Box<T>` إلى قيمة `List` التالية التي ستكون على الكومة بدلاً من داخل متغير `Cons`. من الناحية المفاهيمية، لا يزال لدينا قائمة، تم إنشاؤها بقوائم تحتفظ بقوائم أخرى، لكن هذا التنفيذ الآن أشبه بوضع العناصر بجانب بعضها البعض بدلاً من داخل بعضها البعض.

يمكننا تغيير تعريف enum `List` في القائمة 15-2 واستخدام `List` في القائمة 15-3 إلى الكود في القائمة 15-5، والذي سيتم ترجمته.

<Listing number="15-5" file-name="src/main.rs" caption="تعريف `List` الذي يستخدم `Box<T>` من أجل الحصول على حجم معروف">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
```

</Listing>

يحتاج متغير `Cons` إلى حجم `i32` بالإضافة إلى المساحة لتخزين بيانات مؤشر الصندوق. متغير `Nil` لا يخزن أي قيم، لذلك يحتاج إلى مساحة أقل على المكدس من متغير `Cons`. نعلم الآن أن أي قيمة `List` ستشغل حجم `i32` بالإضافة إلى حجم بيانات مؤشر الصندوق. باستخدام صندوق، كسرنا السلسلة اللا نهائية التكرارية، حتى يتمكن المصرِّف من معرفة الحجم الذي يحتاجه لتخزين قيمة `List`. يوضح الشكل 15-2 كيف يبدو متغير `Cons` الآن.

<img alt="A rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Box' with one inner rectangle that contains the label 'usize', representing the finite size of the box's pointer." src="img/trpl15-02.svg" class="center" />

<span class="caption">الشكل 15-2: `List` ذات حجم ليس لا نهائيًا، لأن `Cons` تحتفظ بـ `Box`</span>

توفر الصناديق التوجيه غير المباشر وتخصيص الكومة فقط؛ ليس لديها أي قدرات خاصة أخرى، مثل تلك التي سنراها مع أنواع المؤشرات الذكية الأخرى. كما أنها لا تحتوي على عبء الأداء الذي تتكبده هذه القدرات الخاصة، لذلك يمكن أن تكون مفيدة في حالات مثل قائمة cons حيث التوجيه غير المباشر هو الميزة الوحيدة التي نحتاجها. سننظر في المزيد من حالات الاستخدام للصناديق في الفصل 18.

نوع `Box<T>` هو مؤشر ذكي لأنه ينفذ سِمة `Deref`، والتي تسمح لقيم `Box<T>` بالتعامل معها كمراجع. عندما تخرج قيمة `Box<T>` عن النطاق، يتم تنظيف بيانات الكومة التي يشير إليها الصندوق أيضًا بسبب تنفيذ سِمة `Drop`. ستكون هاتان السمتان أكثر أهمية للوظائف التي توفرها أنواع المؤشرات الذكية الأخرى التي سنناقشها في بقية هذا الفصل. دعنا نستكشف هاتين السمتين بمزيد من التفصيل.

[trait-objects]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior
