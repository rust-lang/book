## بناء جملة الأنماط

في هذا القسم، نجمع كل بناء الجملة الصالح في الأنماط ونناقش لماذا ومتى قد ترغب في استخدام كل منها.

### مطابقة القيم الحرفية

كما رأيت في الفصل 6، يمكنك مطابقة الأنماط مباشرة مع القيم الحرفية. يعطي الكود التالي بعض الأمثلة:

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}
```

يطبع هذا الكود `one` لأن القيمة في `x` هي `1`. هذا البناء الجملي مفيد عندما تريد أن يتخذ كودك إجراءً إذا حصل على قيمة محددة ملموسة.

### مطابقة المتغيرات المسماة

المتغيرات المسماة هي أنماط غير قابلة للدحض تطابق أي قيمة، وقد استخدمناها عدة مرات في هذا الكتاب. ومع ذلك، هناك تعقيد عند استخدام المتغيرات المسماة في تعبيرات `match` أو `if let` أو `while let`. لأن كل نوع من هذه التعبيرات يبدأ نطاقًا جديدًا، فإن المتغيرات المعلنة كجزء من نمط داخل هذه التعبيرات ستحجب تلك التي لها نفس الاسم خارج البنى، كما هو الحال مع جميع المتغيرات. في القائمة 19-11، نعلن عن متغير يسمى `x` بالقيمة `Some(5)` ومتغير `y` بالقيمة `10`. ثم نُنشئ تعبير `match` على القيمة `x`. انظر إلى الأنماط في أذرع المطابقة و `println!` في النهاية، وحاول معرفة ما سيطبعه الكود قبل تشغيل هذا الكود أو قراءة المزيد.

<Listing number="19-11" file-name="src/main.rs" caption="تعبير `match` بذراع يُقدِّم متغيرًا جديدًا يحجب متغير `y` الموجود">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-11/src/main.rs:here}}
```

</Listing>

لنستعرض ما يحدث عندما يعمل تعبير `match`. لا يطابق النمط في ذراع المطابقة الأول القيمة المحددة لـ `x`، لذلك يستمر الكود.

يُقدِّم النمط في ذراع المطابقة الثاني متغيرًا جديدًا يسمى `y` سيطابق أي قيمة داخل قيمة `Some`. لأننا في نطاق جديد داخل تعبير `match`، هذا متغير `y` جديد، وليس `y` الذي أعلناه في البداية بالقيمة `10`. سيطابق ربط `y` الجديد هذا أي قيمة داخل `Some`, وهو ما لدينا في `x`. لذلك، يرتبط `y` الجديد هذا بالقيمة الداخلية لـ `Some` في `x`. تلك القيمة هي `5`، لذا ينفذ التعبير لذلك الذراع ويطبع `Matched, y = 5`.

إذا كانت `x` قيمة `None` بدلاً من `Some(5)`، فلن تكون الأنماط في أول ذراعين مطابقة، لذلك ستطابق القيمة الشرطة السفلية. لم نُقدِّم المتغير `x` في نمط ذراع الشرطة السفلية، لذلك `x` في التعبير لا يزال `x` الخارجي الذي لم يتم حجبه. في هذه الحالة الافتراضية، ستطبع `match` `Default case, x = None`.

عندما ينتهي تعبير `match`، ينتهي نطاقه، وكذلك نطاق `y` الداخلي. ينتج `println!` الأخير `at the end: x = Some(5), y = 10`.

لإنشاء تعبير `match` يقارن قيم `x` و `y` الخارجيين، بدلاً من تقديم متغير جديد يحجب متغير `y` الموجود، سنحتاج إلى استخدام شرط حارس المطابقة (match guard) بدلاً من ذلك. سنتحدث عن حراس المطابقة لاحقًا في قسم ["إضافة شروط مع حراس المطابقة"](#adding-conditionals-with-match-guards)<!-- ignore -->.

<!-- Old headings. Do not remove or links may break. -->
<a id="multiple-patterns"></a>

### مطابقة أنماط متعددة

في تعبيرات `match`، يمكنك مطابقة أنماط متعددة باستخدام بناء جملة `|`، وهو مشغل النمط _أو_ (or). على سبيل المثال، في الكود التالي، نطابق قيمة `x` مع أذرع المطابقة، الأول منها لديه خيار _أو_، مما يعني أنه إذا طابقت قيمة `x` أي من القيم في ذلك الذراع، فسيتم تشغيل كود ذلك الذراع:


```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}
```

يطبع هذا الكود `one or two`.

### مطابقة نطاقات القيم باستخدام `..=`

يسمح لنا بناء جملة `..=` بالمطابقة مع نطاق شامل من القيم. في الكود التالي، عندما يطابق نمط أيًا من القيم ضمن النطاق المحدد، سينفذ ذلك الذراع:

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}
```

إذا كان `x` هو `1` أو `2` أو `3` أو `4` أو `5`، فسيطابق الذراع الأول. هذا البناء الجملي أكثر ملاءمة لقيم المطابقة المتعددة من استخدام مشغل `|` للتعبير عن نفس الفكرة؛ إذا كنا سنستخدم `|`، فسيتعين علينا تحديد `1 | 2 | 3 | 4 | 5`. تحديد نطاق أقصر بكثير، خاصة إذا أردنا مطابقة، لنقل، أي رقم بين 1 و 1,000!

يتحقق المترجم من أن النطاق ليس فارغًا في وقت الترجمة، ولأن الأنواع الوحيدة التي يمكن لـ Rust معرفة ما إذا كان النطاق فارغًا أم لا هي `char` والقيم الرقمية، فإن النطاقات مسموحة فقط مع القيم الرقمية أو قيم `char`.

فيما يلي مثال باستخدام نطاقات قيم `char`:

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}
```

يمكن لـ Rust معرفة أن `'c'` ضمن نطاق النمط الأول ويطبع `early ASCII letter`.

### التفكيك لتفريق القيم

يمكننا أيضًا استخدام الأنماط لتفكيك الهياكل والتعدادات والصفوف لاستخدام أجزاء مختلفة من هذه القيم. لنستعرض كل قيمة.

<!-- Old headings. Do not remove or links may break. -->

<a id="destructuring-structs"></a>

#### الهياكل

توضح القائمة 19-12 هيكل `Point` بحقلين، `x` و `y`، يمكننا تفريقهما باستخدام نمط مع تعليمة `let`.

<Listing number="19-12" file-name="src/main.rs" caption="تفكيك حقول الهيكل إلى متغيرات منفصلة">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-12/src/main.rs}}
```

</Listing>

ينشئ هذا الكود المتغيرين `a` و `b` اللذين يطابقان قيم حقول `x` و `y` من الهيكل `p`. يوضح هذا المثال أن أسماء المتغيرات في النمط لا يجب أن تطابق أسماء حقول الهيكل. ومع ذلك، من الشائع مطابقة أسماء المتغيرات مع أسماء الحقول لتسهيل تذكر المتغيرات التي جاءت من أي حقول. بسبب هذا الاستخدام الشائع، ولأن كتابة `let Point { x: x, y: y } = p;` تحتوي على الكثير من التكرار، لدى Rust اختصار للأنماط التي تطابق حقول الهيكل: تحتاج فقط إلى سرد اسم حقل الهيكل، وستحصل المتغيرات المُنشأة من النمط على نفس الأسماء. تتصرف القائمة 19-13 بنفس الطريقة التي يتصرف بها الكود في القائمة 19-12، لكن المتغيرات المُنشأة في نمط `let` هي `x` و `y` بدلاً من `a` و `b`.

<Listing number="19-13" file-name="src/main.rs" caption="تفكيك حقول الهيكل باستخدام اختصار حقل الهيكل">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-13/src/main.rs}}
```

</Listing>

ينشئ هذا الكود المتغيرين `x` و `y` اللذين يطابقان حقول `x` و `y` من المتغير `p`. النتيجة هي أن المتغيرين `x` و `y` يحتويان على القيم من الهيكل `p`.

يمكننا أيضًا التفكيك بقيم حرفية كجزء من نمط الهيكل بدلاً من إنشاء متغيرات لجميع الحقول. يسمح لنا القيام بذلك باختبار بعض الحقول لقيم معينة أثناء إنشاء متغيرات لتفكيك الحقول الأخرى.

في القائمة 19-14، لدينا تعبير `match` يفصل قيم `Point` إلى ثلاث حالات: نقاط تقع مباشرة على محور `x` (وهو صحيح عندما `y = 0`)، على محور `y` (`x = 0`)، أو على أي محور آخر.

<Listing number="19-14" file-name="src/main.rs" caption="التفكيك ومطابقة القيم الحرفية في نمط واحد">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-14/src/main.rs:here}}
```

</Listing>

سيطابق الذراع الأول أي نقطة تقع على محور `x` عن طريق تحديد أن حقل `y` يطابق إذا كانت قيمته تطابق الحرف `0`. لا يزال النمط ينشئ متغير `x` يمكننا استخدامه في الكود لهذا الذراع.

وبالمثل، يطابق الذراع الثاني أي نقطة على محور `y` عن طريق تحديد أن حقل `x` يطابق إذا كانت قيمته `0` وينشئ متغير `y` لقيمة حقل `y`. لا يحدد الذراع الثالث أي حرفيات، لذلك يطابق أي `Point` آخر وينشئ متغيرات لكل من حقول `x` و `y`.

في هذا المثال، تطابق القيمة `p` الذراع الثاني بفضل احتواء `x` على `0`، لذا سيطبع هذا الكود `On the y axis at 7`.

تذكر أن تعبير `match` يتوقف عن فحص الأذرع بمجرد أن يجد أول نمط مطابق، لذا على الرغم من أن `Point { x: 0, y: 0}` على محور `x` ومحور `y`، فإن هذا الكود سيطبع فقط `On the x axis at 0`.

<!-- Old headings. Do not remove or links may break. -->

<a id="destructuring-enums"></a>

#### التعدادات

قمنا بتفكيك التعدادات في هذا الكتاب (على سبيل المثال، القائمة 6-5 في الفصل 6)، ولكننا لم نناقش بعد صراحة أن نمط تفكيك التعداد يتوافق مع الطريقة التي يتم بها تعريف البيانات المخزنة داخل التعداد. كمثال، في القائمة 19-15، نستخدم التعداد `Message` من القائمة 6-2 ونكتب `match` بأنماط ستفكك كل قيمة داخلية.

<Listing number="19-15" file-name="src/main.rs" caption="تفكيك متغيرات التعداد التي تحتوي على أنواع مختلفة من القيم">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-15/src/main.rs}}
```

</Listing>

سيطبع هذا الكود `Change color to red 0, green 160, and blue 255`. حاول تغيير قيمة `msg` لرؤية الكود من الأذرع الأخرى يعمل.

بالنسبة لمتغيرات التعداد بدون أي بيانات، مثل `Message::Quit`، لا يمكننا تفكيك القيمة أكثر من ذلك. يمكننا فقط المطابقة على القيمة الحرفية `Message::Quit`، ولا توجد متغيرات في ذلك النمط.

بالنسبة لمتغيرات التعداد الشبيهة بالهيكل، مثل `Message::Move`، يمكننا استخدام نمط مشابه للنمط الذي نحدده لمطابقة الهياكل. بعد اسم المتغير، نضع أقواسًا مجعدة ثم نسرد الحقول مع المتغيرات بحيث نفكك القطع لاستخدامها في الكود لهذا الذراع. هنا نستخدم النموذج المختصر كما فعلنا في القائمة 19-13.

بالنسبة لمتغيرات التعداد الشبيهة بالصف، مثل `Message::Write` الذي يحتوي على صف بعنصر واحد و `Message::ChangeColor` الذي يحتوي على صف بثلاثة عناصر، فإن النمط مشابه للنمط الذي نحدده لمطابقة الصفوف. يجب أن يطابق عدد المتغيرات في النمط عدد العناصر في المتغير الذي نطابقه.

<!-- Old headings. Do not remove or links may break. -->

<a id="destructuring-nested-structs-and-enums"></a>

#### الهياكل والتعدادات المتداخلة

حتى الآن، كانت جميع أمثلتنا تطابق الهياكل أو التعدادات بمستوى واحد فقط، لكن المطابقة يمكن أن تعمل على العناصر المتداخلة أيضًا! على سبيل المثال، يمكننا إعادة هيكلة الكود في القائمة 19-15 لدعم ألوان RGB و HSV في رسالة `ChangeColor`، كما هو موضح في القائمة 19-16.

<Listing number="19-16" caption="المطابقة على التعدادات المتداخلة">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-16/src/main.rs}}
```

</Listing>

يطابق نمط الذراع الأول في تعبير `match` متغير التعداد `Message::ChangeColor` الذي يحتوي على متغير `Color::Rgb`؛ ثم يرتبط النمط بقيم `i32` الداخلية الثلاث. يطابق نمط الذراع الثاني أيضًا متغير التعداد `Message::ChangeColor`، لكن التعداد الداخلي يطابق `Color::Hsv` بدلاً من ذلك. يمكننا تحديد هذه الشروط المعقدة في تعبير `match` واحد، حتى وإن كان هناك تعدادان متورطان.

<!-- Old headings. Do not remove or links may break. -->

<a id="destructuring-structs-and-tuples"></a>

#### الهياكل والصفوف

يمكننا مزج ومطابقة وتداخل أنماط التفكيك بطرق أكثر تعقيدًا. يوضح المثال التالي تفكيكًا معقدًا حيث نتداخل الهياكل والصفوف داخل صف ونفكك جميع القيم الأولية:

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}
```

يتيح لنا هذا الكود تقسيم الأنواع المعقدة إلى أجزائها المكونة بحيث يمكننا استخدام القيم التي نهتم بها بشكل منفصل.

التفكيك باستخدام الأنماط هو طريقة مريحة لاستخدام أجزاء من القيم، مثل القيمة من كل حقل في هيكل، بشكل منفصل عن بعضها البعض.

### تجاهل القيم في النمط

رأيت أنه من المفيد أحيانًا تجاهل القيم في نمط، مثل الذراع الأخير من `match`، للحصول على حالة شاملة لا تفعل أي شيء فعليًا ولكنها تحسب جميع القيم المحتملة المتبقية. هناك عدة طرق لتجاهل قيم كاملة أو أجزاء من القيم في نمط: استخدام نمط `_` (الذي رأيته)، استخدام نمط `_` داخل نمط آخر، استخدام اسم يبدأ بشرطة سفلية، أو استخدام `..` لتجاهل الأجزاء المتبقية من القيمة. لنستكشف كيف ولماذا نستخدم كل نمط من هذه الأنماط.

<!-- Old headings. Do not remove or links may break. -->

<a id="ignoring-an-entire-value-with-_"></a>

#### قيمة كاملة باستخدام `_`

استخدمنا الشرطة السفلية كنمط بدل سيطابق أي قيمة لكن لن يرتبط بالقيمة. هذا مفيد بشكل خاص كذراع أخير في تعبير `match`، لكن يمكننا أيضًا استخدامه في أي نمط، بما في ذلك معاملات الدوال، كما هو موضح في القائمة 19-17.

<Listing number="19-17" file-name="src/main.rs" caption="استخدام `_` في توقيع دالة">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-17/src/main.rs}}
```

</Listing>

سيتجاهل هذا الكود تمامًا القيمة `3` الممررة كأول وسيطة، وسيطبع `This code only uses the y parameter: 4`.

في معظم الحالات عندما لا تحتاج بعد الآن إلى معامل دالة معين، ستغير التوقيع بحيث لا يتضمن المعامل غير المستخدم. يمكن أن يكون تجاهل معامل دالة مفيدًا بشكل خاص في حالات، على سبيل المثال، عندما تقوم بتطبيق سمة عندما تحتاج إلى توقيع نوع معين ولكن نص الدالة في تطبيقك لا يحتاج إلى أحد المعاملات. ثم تتجنب الحصول على تحذير المترجم حول معاملات الدالة غير المستخدمة، كما لو كنت قد استخدمت اسمًا بدلاً من ذلك.

<!-- Old headings. Do not remove or links may break. -->

<a id="ignoring-parts-of-a-value-with-a-nested-_"></a>

#### أجزاء من قيمة مع `_` المتداخل

يمكننا أيضًا استخدام `_` داخل نمط آخر لتجاهل جزء فقط من القيمة، على سبيل المثال، عندما نريد اختبار جزء فقط من القيمة ولكن ليس لدينا استخدام للأجزاء الأخرى في الكود المقابل الذي نريد تشغيله. توضح القائمة 19-18 كودًا مسؤولاً عن إدارة قيمة إعداد. متطلبات العمل هي أنه لا ينبغي السماح للمستخدم بالكتابة فوق تخصيص موجود لإعداد ولكن يمكنه إلغاء تعيين الإعداد وإعطائه قيمة إذا كان غير معين حاليًا.

<Listing number="19-18" caption="استخدام شرطة سفلية داخل الأنماط التي تطابق متغيرات `Some` عندما لا نحتاج إلى استخدام القيمة داخل `Some`">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-18/src/main.rs:here}}
```

</Listing>

سيطبع هذا الكود `Can't overwrite an existing customized value` ثم `setting is Some(5)`. في ذراع المطابقة الأول، لا نحتاج إلى المطابقة على القيم داخل أي من متغيري `Some` أو استخدامها، لكننا نحتاج إلى اختبار الحالة عندما يكون `setting_value` و `new_setting_value` متغير `Some`. في تلك الحالة، نطبع سبب عدم تغيير `setting_value`، ولا يتم تغييره.

في جميع الحالات الأخرى (إذا كان إما `setting_value` أو `new_setting_value` هو `None`) المُعبَّر عنها بنمط `_` في الذراع الثاني، نريد السماح لـ `new_setting_value` بأن يصبح `setting_value`.

يمكننا أيضًا استخدام الشرطات السفلية في أماكن متعددة داخل نمط واحد لتجاهل قيم معينة. توضح القائمة 19-19 مثالاً على تجاهل القيمة الثانية والرابعة في صف من خمسة عناصر.

<Listing number="19-19" caption="تجاهل أجزاء متعددة من صف">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-19/src/main.rs:here}}
```

</Listing>

سيطبع هذا الكود `Some numbers: 2, 8, 32`، وسيتم تجاهل القيمتين `4` و `16`.

<!-- Old headings. Do not remove or links may break. -->

<a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a>

#### متغير غير مستخدم عن طريق بدء اسمه بـ `_`

إذا أنشأت متغيرًا لكنك لا تستخدمه في أي مكان، فعادة ما سيصدر Rust تحذيرًا لأن المتغير غير المستخدم قد يكون خطأ. ومع ذلك، في بعض الأحيان يكون من المفيد أن تكون قادرًا على إنشاء متغير لن تستخدمه بعد، مثل عندما تكون تصنع نموذجًا أوليًا أو تبدأ مشروعًا للتو. في هذا الموقف، يمكنك إخبار Rust بعدم تحذيرك حول المتغير غير المستخدم عن طريق بدء اسم المتغير بشرطة سفلية. في القائمة 19-20، نُنشئ متغيرين غير مستخدمين، لكن عندما نجمع هذا الكود، يجب أن نحصل فقط على تحذير حول أحدهما.

<Listing number="19-20" file-name="src/main.rs" caption="بدء اسم متغير بشرطة سفلية لتجنب الحصول على تحذيرات متغير غير مستخدم">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-20/src/main.rs}}
```

</Listing>

هنا، نحصل على تحذير حول عدم استخدام المتغير `y`، لكننا لا نحصل على تحذير حول عدم استخدام `_x`.

لاحظ أن هناك فرقًا دقيقًا بين استخدام `_` فقط واستخدام اسم يبدأ بشرطة سفلية. بناء الجملة `_x` لا يزال يربط القيمة بالمتغير، بينما `_` لا يرتبط على الإطلاق. لإظهار حالة حيث يهم هذا التمييز، ستوفر لنا القائمة 19-21 خطأ.

<Listing number="19-21" caption="متغير غير مستخدم يبدأ بشرطة سفلية لا يزال يربط القيمة، مما قد يأخذ ملكية القيمة.">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-21/src/main.rs:here}}
```

</Listing>

سنتلقى خطأً لأن قيمة `s` ستظل تُنقل إلى `_s`، مما يمنعنا من استخدام `s` مرة أخرى. ومع ذلك، استخدام الشرطة السفلية بمفردها لا يرتبط أبدًا بالقيمة. ستُجمَّع القائمة 19-22 بدون أي أخطاء لأن `s` لا يتم نقلها إلى `_`.

<Listing number="19-22" caption="استخدام شرطة سفلية لا يربط القيمة.">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-22/src/main.rs:here}}
```

</Listing>

هذا الكود يعمل بشكل جيد لأننا لا نربط `s` بأي شيء أبدًا؛ لا يتم نقله.

<a id="ignoring-remaining-parts-of-a-value-with-"></a>

#### الأجزاء المتبقية من قيمة مع `..`

مع القيم التي لديها أجزاء كثيرة، يمكننا استخدام بناء جملة `..` لاستخدام أجزاء محددة وتجاهل الباقي، وتجنب الحاجة إلى سرد الشرطات السفلية لكل قيمة متجاهلة. يتجاهل نمط `..` أي أجزاء من قيمة لم نطابقها صراحة في بقية النمط. في القائمة 19-23، لدينا هيكل `Point` يحتوي على إحداثي في فضاء ثلاثي الأبعاد. في تعبير `match`، نريد العمل فقط على إحداثي `x` وتجاهل القيم في حقول `y` و `z`.

<Listing number="19-23" caption="تجاهل جميع حقول `Point` باستثناء `x` باستخدام `..`">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-23/src/main.rs:here}}
```

</Listing>

نسرد قيمة `x` ثم نُدرج فقط نمط `..`. هذا أسرع من الاضطرار إلى سرد `y: _` و `z: _`، خاصة عندما نعمل مع الهياكل التي لديها الكثير من الحقول في المواقف التي يكون فيها حقل واحد أو حقلان فقط ذا صلة.

سيتوسع بناء الجملة `..` إلى أكبر عدد ممكن من القيم حسب الحاجة. توضح القائمة 19-24 كيفية استخدام `..` مع صف.

<Listing number="19-24" file-name="src/main.rs" caption="مطابقة القيم الأولى والأخيرة فقط في صف وتجاهل جميع القيم الأخرى">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-24/src/main.rs}}
```

</Listing>

في هذا الكود، تتم مطابقة القيم الأولى والأخيرة مع `first` و `last`. سيطابق `..` ويتجاهل كل شيء في الوسط.

ومع ذلك، يجب أن يكون استخدام `..` غير غامض. إذا لم يكن واضحًا أي القيم مخصصة للمطابقة وأي يجب تجاهلها، فسيعطينا Rust خطأ. توضح القائمة 19-25 مثالاً على استخدام `..` بشكل غامض، لذلك لن يتم تجميعها.

<Listing number="19-25" file-name="src/main.rs" caption="محاولة استخدام `..` بطريقة غامضة">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-25/src/main.rs}}
```

</Listing>

عندما نجمع هذا المثال، نحصل على هذا الخطأ:

```console
{{#include ../listings/ch19-patterns-and-matching/listing-19-25/output.txt}}
```

من المستحيل على Rust تحديد عدد القيم في الصف لتجاهلها قبل مطابقة قيمة مع `second` ثم عدد القيم الأخرى لتجاهلها بعد ذلك. قد يعني هذا الكود أننا نريد تجاهل `2`، وربط `second` بـ `4`، ثم تجاهل `8` و `16` و `32`؛ أو أننا نريد تجاهل `2` و `4`، وربط `second` بـ `8`، ثم تجاهل `16` و `32`؛ وهكذا. اسم المتغير `second` لا يعني أي شيء خاص لـ Rust، لذلك نحصل على خطأ في المترجم لأن استخدام `..` في مكانين مثل هذا غامض.

<!-- Old headings. Do not remove or links may break. -->

<a id="extra-conditionals-with-match-guards"></a>

### إضافة شروط مع حراس المطابقة

_حارس المطابقة_ (match guard) هو شرط `if` إضافي، محدد بعد النمط في ذراع `match`، يجب أيضًا أن يطابق لكي يتم اختيار ذلك الذراع. حراس المطابقة مفيدة للتعبير عن أفكار أكثر تعقيدًا مما يسمح به النمط وحده. لاحظ، مع ذلك، أنها متاحة فقط في تعبيرات `match`، وليس في تعبيرات `if let` أو `while let`.

يمكن للشرط استخدام المتغيرات المُنشأة في النمط. توضح القائمة 19-26 `match` حيث يحتوي الذراع الأول على النمط `Some(x)` وأيضًا لديه حارس مطابقة من `if x % 2 == 0` (والذي سيكون `true` إذا كان الرقم زوجيًا).

<Listing number="19-26" caption="إضافة حارس مطابقة إلى نمط">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-26/src/main.rs:here}}
```

</Listing>

سيطبع هذا المثال `The number 4 is even`. عندما تتم مقارنة `num` مع النمط في الذراع الأول، فإنها تطابق لأن `Some(4)` تطابق `Some(x)`. ثم يتحقق حارس المطابقة مما إذا كانت باقي قسمة `x` على 2 تساوي 0، ولأنها كذلك، يتم اختيار الذراع الأول.

إذا كان `num` هو `Some(5)` بدلاً من ذلك، فإن حارس المطابقة في الذراع الأول سيكون `false` لأن باقي 5 مقسومًا على 2 هو 1، وليس مساويًا لـ 0. ثم سينتقل Rust إلى الذراع الثاني، الذي سيطابق لأن الذراع الثاني لا يحتوي على حارس مطابقة وبالتالي يطابق أي متغير `Some`.

لا توجد طريقة للتعبير عن الشرط `if x % 2 == 0` داخل نمط، لذلك يمنحنا حارس المطابقة القدرة على التعبير عن هذا المنطق. الجانب السلبي من هذا التعبير الإضافي هو أن المترجم لا يحاول التحقق من الشمولية عندما تكون تعبيرات حراس المطابقة متورطة.

عند مناقشة القائمة 19-11، ذكرنا أنه يمكننا استخدام حراس المطابقة لحل مشكلة حجب النمط لدينا. تذكر أننا أنشأنا متغيرًا جديدًا داخل النمط في تعبير `match` بدلاً من استخدام المتغير خارج `match`. كان ذلك المتغير الجديد يعني أننا لا نستطيع الاختبار مقابل قيمة المتغير الخارجي. توضح القائمة 19-27 كيف يمكننا استخدام حارس مطابقة لإصلاح هذه المشكلة.

<Listing number="19-27" file-name="src/main.rs" caption="استخدام حارس مطابقة لاختبار المساواة مع متغير خارجي">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-27/src/main.rs}}
```

</Listing>

سيطبع هذا الكود الآن `Default case, x = Some(5)`. لا يُقدِّم النمط في ذراع المطابقة الثاني متغير `y` جديدًا سيحجب `y` الخارجي، مما يعني أنه يمكننا استخدام `y` الخارجي في حارس المطابقة. بدلاً من تحديد النمط كـ `Some(y)`، الذي كان سيحجب `y` الخارجي، نحدد `Some(n)`. ينشئ هذا متغير `n` جديدًا لا يحجب أي شيء لأنه لا يوجد متغير `n` خارج `match`.

حارس المطابقة `if n == y` ليس نمطًا وبالتالي لا يُقدِّم متغيرات جديدة. هذا `y` _هو_ `y` الخارجي بدلاً من `y` جديد يحجبه، ويمكننا البحث عن قيمة لها نفس قيمة `y` الخارجي عن طريق مقارنة `n` بـ `y`.

يمكنك أيضًا استخدام مشغل _أو_ `|` في حارس مطابقة لتحديد أنماط متعددة؛ سيطبق شرط حارس المطابقة على جميع الأنماط. توضح القائمة 19-28 الأسبقية عند الجمع بين نمط يستخدم `|` مع حارس مطابقة. الجزء المهم من هذا المثال هو أن حارس المطابقة `if y` ينطبق على `4` و `5` _و_ `6`، على الرغم من أنه قد يبدو أن `if y` ينطبق فقط على `6`.

<Listing number="19-28" caption="الجمع بين أنماط متعددة مع حارس مطابقة">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-28/src/main.rs:here}}
```

</Listing>

ينص شرط المطابقة على أن الذراع يطابق فقط إذا كانت قيمة `x` تساوي `4` أو `5` أو `6` _و_ إذا كان `y` هو `true`. عندما يعمل هذا الكود، يطابق نمط الذراع الأول لأن `x` هو `4`، لكن حارس المطابقة `if y` هو `false`، لذلك لا يتم اختيار الذراع الأول. ينتقل الكود إلى الذراع الثاني، الذي يطابق، وهذا البرنامج يطبع `no`. السبب هو أن شرط `if` ينطبق على النمط الكامل `4 | 5 | 6`، وليس فقط على القيمة الأخيرة `6`. بمعنى آخر، أسبقية حارس المطابقة فيما يتعلق بالنمط تتصرف كما يلي:

```text
(4 | 5 | 6) if y => ...
```

بدلاً من هذا:

```text
4 | 5 | (6 if y) => ...
```

بعد تشغيل الكود، يكون سلوك الأسبقية واضحًا: إذا كان حارس المطابقة يطبق فقط على القيمة الأخيرة في قائمة القيم المحددة باستخدام مشغل `|`، لكان الذراع قد طابق، ولكان البرنامج قد طبع `yes`.

<!-- Old headings. Do not remove or links may break. -->

<a id="-bindings"></a>

### استخدام ربطات `@`

مشغل _at_ `@` يتيح لنا إنشاء متغير يحتوي على قيمة في نفس الوقت الذي نختبر فيه تلك القيمة لمطابقة نمط. في القائمة 19-29، نريد اختبار أن حقل `id` من `Message::Hello` ضمن النطاق `3..=7`. نريد أيضًا ربط القيمة بالمتغير `id` حتى نتمكن من استخدامها في الكود المرتبط بالذراع.

<Listing number="19-29" caption="استخدام `@` للربط بقيمة في نمط أثناء اختبارها أيضًا">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-29/src/main.rs:here}}
```

</Listing>

سيطبع هذا المثال `Found an id in range: 5`. من خلال تحديد `id @` قبل النطاق `3..=7`، نقوم بالتقاط أي قيمة طابقت النطاق في متغير يسمى `id` بينما نختبر أيضًا أن القيمة طابقت نمط النطاق.

في الذراع الثاني، حيث لدينا فقط نطاق محدد في النمط، فإن الكود المرتبط بالذراع ليس لديه متغير يحتوي على القيمة الفعلية لحقل `id`. يمكن أن تكون قيمة حقل `id` 10 أو 11 أو 12، لكن الكود الذي يذهب مع ذلك النمط لا يعرف أي منها. كود النمط غير قادر على استخدام القيمة من حقل `id` لأننا لم نحفظ قيمة `id` في متغير.

في الذراع الأخير، حيث حددنا متغيرًا بدون نطاق، لدينا بالفعل القيمة المتاحة للاستخدام في كود الذراع في متغير يسمى `id`. السبب هو أننا استخدمنا بناء جملة اختصار حقل الهيكل. لكننا لم نطبق أي اختبار على القيمة في حقل `id` في هذا الذراع، كما فعلنا مع أول ذراعين: أي قيمة ستطابق هذا النمط.

استخدام `@` يتيح لنا اختبار قيمة وحفظها في متغير داخل نمط واحد.

## الخلاصة

أنماط Rust مفيدة جدًا في التمييز بين أنواع مختلفة من البيانات. عند استخدامها في تعبيرات `match`, يضمن Rust أن أنماطك تغطي كل قيمة ممكنة، أو لن يتم تجميع برنامجك. الأنماط في تعليمات `let` ومعاملات الدوال تجعل تلك البنى أكثر فائدة، مما يتيح تفكيك القيم إلى أجزاء أصغر وتعيين تلك الأجزاء إلى متغيرات. يمكننا إنشاء أنماط بسيطة أو معقدة لتناسب احتياجاتنا.

بعد ذلك، في الفصل قبل الأخير من الكتاب، سننظر في بعض الجوانب المتقدمة لمجموعة متنوعة من ميزات Rust.
