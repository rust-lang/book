## استخدام `panic!` أم عدم استخدامه

إذن، كيف تقرر متى يجب عليك استدعاء `panic!` ومتى يجب عليك إرجاع
`Result`؟ عندما يحدث panic في الكود، لا توجد طريقة للاستعادة. يمكنك استدعاء `panic!`
لأي حالة خطأ، سواء كانت هناك طريقة ممكنة للاستعادة أم لا، ولكن
عندها ستتخذ القرار بأن الموقف غير قابل للاستعادة نيابة عن
الكود المستدعي. عندما تختار إرجاع قيمة `Result`، فأنت تعطي
الكود المستدعي خيارات. يمكن للكود المستدعي أن يختار محاولة الاستعادة بطريقة
مناسبة لموقفه، أو يمكن أن يقرر أن قيمة `Err`
في هذه الحالة غير قابلة للاستعادة، لذا يمكنه استدعاء `panic!` وتحويل
خطأك القابل للاستعادة إلى خطأ غير قابل للاستعادة. لذلك، إرجاع `Result` هو
خيار افتراضي جيد عندما تقوم بتعريف دالة قد تفشل.

في حالات مثل الأمثلة، والكود النموذجي، والاختبارات، من
الأنسب كتابة كود يحدث فيه panic بدلاً من إرجاع `Result`. دعنا
نستكشف السبب، ثم نناقش الحالات التي لا يستطيع فيها المصرِّف معرفة أن
الفشل مستحيل، ولكنك كإنسان يمكنك ذلك. سيختتم الفصل ببعض
الإرشادات العامة حول كيفية تقرير ما إذا كنت ستستخدم panic في كود المكتبة.

### الأمثلة، والكود النموذجي، والاختبارات

عندما تكتب مثالاً لتوضيح مفهوم ما، فإن تضمين
كود قوي للتعامل مع الأخطاء يمكن أن يجعل المثال أقل وضوحاً. في الأمثلة،
من المفهوم أن استدعاء طريقة مثل `unwrap` التي قد تسبب panic يُقصد به أن يكون
عنصر نائب للطريقة التي تريد أن يتعامل بها تطبيقك مع الأخطاء، والتي يمكن أن
تختلف بناءً على ما يفعله بقية كودك.

بالمثل، فإن طريقتي `unwrap` و `expect` مفيدتان جداً عندما تكون
في مرحلة النماذج الأولية ولست مستعداً بعد لتقرير كيفية التعامل مع الأخطاء. فهما تتركان
علامات واضحة في كودك لعندما تكون مستعداً لجعل برنامجك أكثر
متانة.

إذا فشل استدعاء طريقة في اختبار، فستريد فشل الاختبار بأكمله، حتى لو
لم تكن تلك الطريقة هي الوظيفة قيد الاختبار. نظراً لأن `panic!` هي الطريقة التي
يُعلَّم بها الاختبار على أنه فشل، فإن استدعاء `unwrap` أو `expect` هو بالضبط ما يجب
أن يحدث.

<!-- Old headings. Do not remove or links may break. -->

<a id="cases-in-which-you-have-more-information-than-the-compiler"></a>

### عندما يكون لديك معلومات أكثر من المصرِّف

سيكون من المناسب أيضاً استدعاء `expect` عندما يكون لديك منطق آخر
يضمن أن `Result` سيحتوي على قيمة `Ok`، ولكن المنطق ليس
شيئاً يفهمه المصرِّف. سيكون لديك لا تزال قيمة `Result` تحتاج
إلى التعامل معها: أياً كانت العملية التي تستدعيها لا تزال لديها احتمالية
الفشل بشكل عام، حتى لو كان ذلك مستحيلاً منطقياً في حالتك
الخاصة. إذا كنت تستطيع التأكد من خلال فحص الكود يدوياً أنك لن تحصل أبداً
على متغير `Err`، فمن المقبول تماماً استدعاء `expect` وتوثيق
السبب الذي تعتقد أنك لن تحصل أبداً على متغير `Err` في نص الوسيط.
إليك مثال:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

نحن ننشئ مثيل `IpAddr` من خلال تحليل نص ثابت. يمكننا أن نرى
أن `127.0.0.1` هو عنوان IP صالح، لذا من المقبول استخدام `expect`
هنا. ومع ذلك، فإن وجود نص ثابت وصالح لا يغير نوع الإرجاع
لطريقة `parse`: نحصل لا تزال على قيمة `Result`، وسيجعلنا المصرِّف لا تزال
نتعامل مع `Result` كما لو أن متغير `Err` هو احتمال
لأن المصرِّف ليس ذكياً بما يكفي لرؤية أن هذا النص دائماً
عنوان IP صالح. إذا كان نص عنوان IP يأتي من مستخدم بدلاً من أن يكون
مضمناً في البرنامج ولذلك _كان_ لديه احتمالية فشل،
سنريد بالتأكيد التعامل مع `Result` بطريقة أكثر قوة بدلاً من ذلك.
ذكر الافتراض أن عنوان IP هذا مضمن سيدفعنا إلى
تغيير `expect` إلى كود أفضل للتعامل مع الأخطاء إذا، في المستقبل، احتجنا إلى الحصول
على عنوان IP من مصدر آخر بدلاً من ذلك.

### إرشادات للتعامل مع الأخطاء

من المستحسن أن يحدث panic في كودك عندما يكون من الممكن أن ينتهي كودك
في حالة سيئة. في هذا السياق، _الحالة السيئة_ هي عندما يتم كسر بعض الافتراضات،
أو الضمانات، أو العقود، أو الثوابت، مثل عندما يتم تمرير قيم غير صالحة،
أو قيم متناقضة، أو قيم مفقودة إلى كودك—بالإضافة إلى واحد أو
أكثر مما يلي:

- الحالة السيئة هي شيء غير متوقع، على عكس شيء
  من المحتمل أن يحدث أحياناً، مثل إدخال مستخدم لبيانات بتنسيق
  خاطئ.
- يحتاج كودك بعد هذه النقطة إلى الاعتماد على عدم وجوده في هذه الحالة السيئة،
  بدلاً من التحقق من المشكلة في كل خطوة.
- ليس هناك طريقة جيدة لترميز هذه المعلومات في الأنواع التي تستخدمها. سنعمل
  من خلال مثال على ما نعنيه في ["ترميز الحالات والسلوك كأنواع"][encoding]<!-- ignore --> في الفصل 18.

إذا اتصل شخص ما بكودك ومرر قيماً لا معنى لها، فمن
الأفضل إرجاع خطأ إذا استطعت حتى يتمكن مستخدم المكتبة من تحديد
ما يريد فعله في تلك الحالة. ومع ذلك، في الحالات التي قد يكون فيها الاستمرار
غير آمن أو ضار، قد يكون الخيار الأفضل هو استدعاء `panic!` وتنبيه
الشخص الذي يستخدم مكتبتك للخطأ في كودهم حتى يتمكنوا من إصلاحه
أثناء التطوير. وبالمثل، غالباً ما يكون `panic!` مناسباً إذا كنت تستدعي
كوداً خارجياً خارج سيطرتك ويرجع حالة غير صالحة ليس لديك
طريقة لإصلاحها.

ومع ذلك، عندما يكون الفشل متوقعاً، يكون من الأنسب إرجاع `Result`
بدلاً من إجراء استدعاء `panic!`. تشمل الأمثلة محلل يُعطى بيانات
مشوهة أو طلب HTTP يرجع حالة تشير إلى أنك وصلت إلى حد
معدل. في هذه الحالات، يشير إرجاع `Result` إلى أن الفشل هو
احتمال متوقع يجب على الكود المستدعي أن يقرر كيفية التعامل معه.

عندما يقوم كودك بإجراء عملية قد تعرض مستخدماً للخطر إذا تم
استدعاؤها باستخدام قيم غير صالحة، يجب على كودك التحقق من صحة القيم أولاً
ويحدث panic إذا لم تكن القيم صالحة. هذا أساساً لأسباب أمنية:
محاولة العمل على بيانات غير صالحة يمكن أن تعرض كودك لثغرات أمنية.
هذا هو السبب الرئيسي الذي يجعل المكتبة القياسية تستدعي `panic!` إذا حاولت
الوصول إلى ذاكرة خارج الحدود: محاولة الوصول إلى ذاكرة لا تنتمي
إلى هيكل البيانات الحالي هي مشكلة أمنية شائعة. غالباً ما يكون للدوال
_عقود_: سلوكها مضمون فقط إذا استوفت المدخلات متطلبات
معينة. حدوث panic عند انتهاك العقد منطقي لأن انتهاك
العقد يشير دائماً إلى خطأ من جانب المستدعي، وليس نوع
الخطأ الذي تريد أن يتعامل معه الكود المستدعي بشكل صريح. في الواقع، ليس هناك
طريقة معقولة للكود المستدعي للاستعادة؛ _المبرمجون_ المستدعون بحاجة
إلى إصلاح الكود. يجب شرح عقود الدالة، خاصة عندما يسبب الانتهاك
panic، في وثائق API للدالة.

ومع ذلك، فإن وجود الكثير من فحوصات الأخطاء في جميع دوالك سيكون مطولاً
ومزعجاً. لحسن الحظ، يمكنك استخدام نظام الأنواع في Rust (وبالتالي التحقق من الأنواع
الذي يقوم به المصرِّف) لإجراء العديد من الفحوصات لك. إذا كان لدى
دالتك نوع معين كمعامل، يمكنك المتابعة مع منطق
كودك مع العلم أن المصرِّف قد تأكد بالفعل من أن لديك قيمة
صالحة. على سبيل المثال، إذا كان لديك نوع بدلاً من `Option`، يتوقع برنامجك
أن يكون لديك _شيء_ بدلاً من _لا شيء_. لن يحتاج كودك بعد ذلك إلى
التعامل مع حالتين لمتغيري `Some` و `None`: سيكون لديه حالة واحدة فقط
لوجود قيمة بالتأكيد. لن يتم ترجمة الكود الذي يحاول تمرير لا شيء إلى
دالتك، لذلك لا يجب على دالتك التحقق من تلك
الحالة في وقت التشغيل. مثال آخر هو استخدام نوع عدد صحيح غير موقع مثل
`u32`، والذي يضمن أن المعامل ليس سالباً أبداً.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-custom-types-for-validation"></a>

### أنواع مخصصة للتحقق

دعنا نأخذ فكرة استخدام نظام أنواع Rust للتأكد من أن لدينا قيمة
صالحة خطوة إضافية وننظر إلى إنشاء نوع مخصص للتحقق.
تذكر لعبة التخمين في الفصل 2 حيث طلب كودنا من المستخدم تخمين
رقم بين 1 و 100. لم نتحقق أبداً من أن تخمين المستخدم كان
بين تلك الأرقام قبل مقارنته برقمنا السري؛ تحققنا فقط
من أن التخمين كان موجباً. في هذه الحالة، لم تكن العواقب
خطيرة جداً: كان مخرجنا "مرتفع جداً" أو "منخفض جداً" سيظل صحيحاً. لكن
سيكون تحسيناً مفيداً توجيه المستخدم نحو تخمينات صالحة وأن يكون
لديك سلوك مختلف عندما يخمن المستخدم رقماً خارج النطاق مقابل
عندما يكتب المستخدم، على سبيل المثال، حروفاً بدلاً من ذلك.

طريقة واحدة للقيام بذلك ستكون تحليل التخمين كـ `i32` بدلاً من مجرد
`u32` للسماح بالأرقام السالبة المحتملة، ثم إضافة فحص للرقم
الموجود في النطاق، مثل:

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

</Listing>

يتحقق تعبير `if` مما إذا كانت قيمتنا خارج النطاق، ويخبر المستخدم
بالمشكلة، ويستدعي `continue` لبدء التكرار التالي من الحلقة
وطلب تخمين آخر. بعد تعبير `if`، يمكننا المتابعة في
المقارنات بين `guess` والرقم السري مع العلم أن `guess`
بين 1 و 100.

ومع ذلك، هذا ليس حلاً مثالياً: إذا كان من الضروري للغاية أن
يعمل البرنامج فقط على قيم بين 1 و 100، وكان لديه العديد من الدوال
بهذا المتطلب، فإن وجود فحص مثل هذا في كل دالة سيكون
مملاً (وقد يؤثر على الأداء).

بدلاً من ذلك، يمكننا إنشاء نوع جديد في وحدة مخصصة ووضع عمليات التحقق
في دالة لإنشاء مثيل من النوع بدلاً من تكرار
عمليات التحقق في كل مكان. بهذه الطريقة، من الآمن للدوال استخدام النوع الجديد
في توقيعاتها واستخدام القيم التي تستلمها بثقة. يوضح الإدراج 9-13
طريقة واحدة لتعريف نوع `Guess` الذي سينشئ مثيل من
`Guess` فقط إذا استلمت دالة `new` قيمة بين 1 و 100.

<Listing number="9-13" caption="نوع `Guess` سيستمر فقط مع القيم بين 1 و 100" file-name="src/guessing_game.rs">

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/guessing_game.rs}}
```

</Listing>

لاحظ أن هذا الكود في _src/guessing_game.rs_ يعتمد على إضافة تصريح وحدة
`mod guessing_game;` في _src/lib.rs_ والذي لم نظهره هنا.
داخل ملف هذه الوحدة الجديدة، نعرف بنية (struct) تسمى `Guess` لها حقل
يسمى `value` يحتوي على `i32`. هذا هو المكان الذي سيتم تخزين الرقم فيه.

ثم، ننفذ دالة مرتبطة تسمى `new` على `Guess` تنشئ
مثيلات من قيم `Guess`. تم تعريف دالة `new` لتحتوي على معامل واحد
يسمى `value` من نوع `i32` ولإرجاع `Guess`. يختبر الكود في
جسم دالة `new` `value` للتأكد من أنه بين 1 و 100.
إذا لم يجتز `value` هذا الاختبار، نقوم باستدعاء `panic!`، الذي سينبه
المبرمج الذي يكتب الكود المستدعي بأن لديه خطأ يحتاج
إلى إصلاحه، لأن إنشاء `Guess` بـ `value` خارج هذا النطاق سينتهك
العقد الذي يعتمد عليه `Guess::new`. يجب مناقشة الشروط التي
قد يحدث فيها `Guess::new` panic في وثائق API العامة؛
سنغطي اتفاقيات التوثيق التي تشير إلى احتمالية
`panic!` في وثائق API التي تنشئها في الفصل 14. إذا
اجتاز `value` الاختبار، ننشئ `Guess` جديد مع تعيين حقل `value` الخاص به
إلى معامل `value` ونرجع `Guess`.

بعد ذلك، ننفذ طريقة تسمى `value` تستعير `self`، ليس لديها أي
معاملات أخرى، وترجع `i32`. يُطلق على هذا النوع من الطرق أحياناً اسم
_getter_ لأن غرضه هو الحصول على بعض البيانات من حقوله وإرجاعها.
هذه الطريقة العامة ضرورية لأن حقل `value` في بنية `Guess`
خاص. من المهم أن يكون حقل `value` خاصاً حتى
لا يُسمح للكود الذي يستخدم بنية `Guess` بتعيين `value` مباشرة: يجب
على الكود خارج وحدة `guessing_game` استخدام دالة `Guess::new` لإنشاء
مثيل من `Guess`، وبالتالي ضمان عدم وجود طريقة لـ
`Guess` ليكون له `value` لم يتم التحقق منه بواسطة الشروط في دالة
`Guess::new`.

دالة تحتوي على معامل أو ترجع أرقاماً فقط بين 1 و 100 يمكن
بعد ذلك أن تعلن في توقيعها أنها تأخذ أو ترجع `Guess` بدلاً من
`i32` ولن تحتاج إلى إجراء أي فحوصات إضافية في جسمها.

## الخلاصة

تم تصميم ميزات التعامل مع الأخطاء في Rust لمساعدتك في كتابة كود أكثر قوة.
يشير ماكرو `panic!` إلى أن برنامجك في حالة لا يمكنه التعامل معها
ويتيح لك إيقاف العملية بدلاً من محاولة المتابعة بقيم غير صالحة أو
غير صحيحة. يستخدم enum `Result` نظام أنواع Rust للإشارة إلى أن
العمليات قد تفشل بطريقة يمكن لكودك الاستعادة منها. يمكنك استخدام
`Result` لإخبار الكود الذي يستدعي كودك أنه يحتاج إلى التعامل مع
النجاح المحتمل أو الفشل أيضاً. استخدام `panic!` و `Result` في
الحالات المناسبة سيجعل كودك أكثر موثوقية في مواجهة المشاكل الحتمية.

الآن بعد أن رأيت طرقاً مفيدة تستخدم بها المكتبة القياسية الأنواع العمومية مع
enums `Option` و `Result`، سنتحدث عن كيفية عمل الأنواع العمومية وكيف يمكنك
استخدامها في كودك.

[encoding]: ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
