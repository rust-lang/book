## الملحق ج: الخصائص القابلة للاشتقاق

في أماكن مختلفة في الكتاب، ناقشنا سمة `derive`، التي يمكنك تطبيقها على تعريف بنية أو تعداد. تولد سمة `derive` كودًا سينفذ خاصية مع تطبيقها الافتراضي الخاص على النوع الذي قمت بتعليقه بصيغة `derive`.

في هذا الملحق، نقدم مرجعًا لجميع الخصائص في المكتبة القياسية التي يمكنك استخدامها مع `derive`. يغطي كل قسم:

- ما هي المعاملات والطرق التي سيمكّنها اشتقاق هذه الخاصية
- ما الذي يفعله تطبيق الخاصية الذي توفره `derive`
- ما الذي يشير إليه تطبيق الخاصية حول النوع
- الشروط التي يُسمح فيها أو لا يُسمح بتطبيق الخاصية
- أمثلة على العمليات التي تتطلب الخاصية

إذا كنت تريد سلوكًا مختلفًا عن ذلك الذي توفره سمة `derive`، استشر [وثائق المكتبة القياسية](../std/index.html)<!-- ignore --> لكل خاصية للحصول على تفاصيل حول كيفية تطبيقها يدويًا.

الخصائص المدرجة هنا هي الوحيدة المعرّفة من قبل المكتبة القياسية التي يمكن تطبيقها على أنواعك باستخدام `derive`. الخصائص الأخرى المعرّفة في المكتبة القياسية ليس لها سلوك افتراضي معقول، لذا الأمر متروك لك لتطبيقها بالطريقة المناسبة لما تحاول تحقيقه.

مثال على خاصية لا يمكن اشتقاقها هو `Display`، التي تتعامل مع التنسيق للمستخدمين النهائيين. يجب عليك دائمًا التفكير في الطريقة المناسبة لعرض نوع للمستخدم النهائي. ما هي أجزاء النوع التي يجب السماح للمستخدم النهائي برؤيتها؟ ما هي الأجزاء التي سيجدونها ذات صلة؟ ما هو تنسيق البيانات الأكثر صلة بهم؟ لا يملك مُترجم Rust هذه الرؤية، لذا لا يمكنه توفير سلوك افتراضي مناسب لك.

قائمة الخصائص القابلة للاشتقاق المقدمة في هذا الملحق ليست شاملة: يمكن للمكتبات تطبيق `derive` لخصائصها الخاصة، مما يجعل قائمة الخصائص التي يمكنك استخدام `derive` معها مفتوحة حقًا. يتضمن تطبيق `derive` استخدام ماكرو إجرائي، والذي يتم تغطيته في قسم ["ماكروهات `derive` المخصصة"][custom-derive-macros]<!-- ignore --> في الفصل 20.

### `Debug` لإخراج المبرمج

تمكّن خاصية `Debug` تنسيق التصحيح في سلاسل التنسيق، والتي تشير إليها بإضافة `:?` داخل عناصر نائبة `{}`.

تسمح لك خاصية `Debug` بطباعة مثيلات نوع لأغراض التصحيح، بحيث يمكنك أنت والمبرمجون الآخرون الذين يستخدمون نوعك فحص مثيل في نقطة معينة في تنفيذ البرنامج.

خاصية `Debug` مطلوبة، على سبيل المثال، في استخدام ماكرو `assert_eq!`. يطبع هذا الماكرو قيم المثيلات المعطاة كوسيطات إذا فشلت مقارنة المساواة بحيث يمكن للمبرمجين رؤية سبب عدم تساوي المثيلين.

### `PartialEq` و `Eq` لمقارنات المساواة

تسمح لك خاصية `PartialEq` بمقارنة مثيلات نوع للتحقق من المساواة وتمكّن استخدام معاملات `==` و `!=`.

يطبّق اشتقاق `PartialEq` طريقة `eq`. عند اشتقاق `PartialEq` على البنى، يتساوى مثيلان فقط إذا كانت _جميع_ الحقول متساوية، ولا تتساوى المثيلات إذا كانت _أي_ حقول غير متساوية. عند الاشتقاق على التعدادات، كل متغير يساوي نفسه ولا يساوي المتغيرات الأخرى.

خاصية `PartialEq` مطلوبة، على سبيل المثال، مع استخدام ماكرو `assert_eq!`، والذي يحتاج إلى أن يكون قادرًا على مقارنة مثيلين من نوع للمساواة.

خاصية `Eq` ليس لها طرق. الغرض منها هو الإشارة إلى أن كل قيمة من النوع المعلّق تساوي نفسها. يمكن تطبيق خاصية `Eq` فقط على الأنواع التي تطبّق أيضًا `PartialEq`، على الرغم من أنه ليست كل الأنواع التي تطبّق `PartialEq` يمكنها تطبيق `Eq`. مثال على ذلك هو أنواع الأعداد العشرية الكسرية: ينص تطبيق الأعداد العشرية الكسرية على أن مثيلين من قيمة ليست-عددًا (`NaN`) غير متساويين مع بعضهما البعض.

مثال على متى تكون `Eq` مطلوبة هو للمفاتيح في `HashMap<K, V>` بحيث يمكن لـ `HashMap<K, V>` معرفة ما إذا كان مفتاحان متماثلين.

### `PartialOrd` و `Ord` لمقارنات الترتيب

تسمح لك خاصية `PartialOrd` بمقارنة مثيلات نوع لأغراض الترتيب. يمكن استخدام نوع ينفذ `PartialOrd` مع معاملات `<`, `>`, `<=`, و `>=`. يمكنك تطبيق خاصية `PartialOrd` فقط على الأنواع التي تطبّق أيضًا `PartialEq`.

يطبّق اشتقاق `PartialOrd` طريقة `partial_cmp`، والتي تُرجع `Option<Ordering>` والتي ستكون `None` عندما لا تنتج القيم المعطاة ترتيبًا. مثال على قيمة لا تنتج ترتيبًا، على الرغم من أن معظم قيم ذلك النوع يمكن مقارنتها، هو قيمة الفاصلة العشرية `NaN`. استدعاء `partial_cmp` مع أي عدد فاصلة عشرية وقيمة الفاصلة العشرية `NaN` سيُرجع `None`.

عند الاشتقاق على البنى، تقارن `PartialOrd` مثيلين بمقارنة القيمة في كل حقل بالترتيب الذي تظهر به الحقول في تعريف البنية. عند الاشتقاق على التعدادات، تُعتبر متغيرات التعداد المعلنة في وقت مبكر في تعريف التعداد أقل من المتغيرات المدرجة لاحقًا.

خاصية `PartialOrd` مطلوبة، على سبيل المثال، لطريقة `gen_range` من صندوق `rand` التي تولد قيمة عشوائية في النطاق المحدد بواسطة تعبير نطاق.

تسمح لك خاصية `Ord` بمعرفة أنه لأي قيمتين من النوع المعلّق، سيوجد ترتيب صالح. تطبّق خاصية `Ord` طريقة `cmp`، والتي تُرجع `Ordering` بدلاً من `Option<Ordering>` لأن ترتيبًا صالحًا سيكون دائمًا ممكنًا. يمكنك تطبيق خاصية `Ord` فقط على الأنواع التي تطبّق أيضًا `PartialOrd` و `Eq` (و `Eq` تتطلب `PartialEq`). عند الاشتقاق على البنى والتعدادات، يتصرف `cmp` بنفس الطريقة التي يتصرف بها التطبيق المشتق لـ `partial_cmp` مع `PartialOrd`.

مثال على متى تكون `Ord` مطلوبة هو عند تخزين القيم في `BTreeSet<T>`، وهي بنية بيانات تخزن البيانات بناءً على ترتيب الفرز للقيم.

### `Clone` و `Copy` لمضاعفة القيم

تسمح لك خاصية `Clone` بإنشاء نسخة عميقة صريحة من قيمة، وقد تتضمن عملية المضاعفة تشغيل كود عشوائي ونسخ بيانات الكومة. راجع قسم ["المتغيرات والبيانات التي تتفاعل مع Clone"][variables-and-data-interacting-with-clone]<!-- ignore --> في الفصل 4 لمزيد من المعلومات حول `Clone`.

يطبّق اشتقاق `Clone` طريقة `clone`، والتي عند تطبيقها على النوع بالكامل، تستدعي `clone` على كل جزء من أجزاء النوع. هذا يعني أن جميع الحقول أو القيم في النوع يجب أن تطبّق أيضًا `Clone` لاشتقاق `Clone`.

مثال على متى تكون `Clone` مطلوبة هو عند استدعاء طريقة `to_vec` على شريحة. لا تملك الشريحة مثيلات النوع التي تحتويها، ولكن المتجه المُرجع من `to_vec` سيحتاج إلى امتلاك مثيلاته، لذا يستدعي `to_vec` `clone` على كل عنصر. وبالتالي، يجب أن ينفذ النوع المخزن في الشريحة `Clone`.

تسمح لك خاصية `Copy` بمضاعفة قيمة عن طريق نسخ البتات المخزنة على المكدس فقط؛ لا حاجة لأي كود عشوائي. راجع قسم ["البيانات على المكدس فقط: Copy"][stack-only-data-copy]<!-- ignore --> في الفصل 4 لمزيد من المعلومات حول `Copy`.

لا تحدد خاصية `Copy` أي طرق لمنع المبرمجين من تحميل تلك الطرق زائدًا وانتهاك الافتراض بأنه لا يتم تشغيل أي كود عشوائي. بهذه الطريقة، يمكن لجميع المبرمجين افتراض أن نسخ قيمة ستكون سريعة جدًا.

يمكنك اشتقاق `Copy` على أي نوع جميع أجزائه تطبّق `Copy`. يجب أن ينفذ النوع الذي يطبّق `Copy` أيضًا `Clone` لأن نوعًا ينفذ `Copy` لديه تطبيق بسيط لـ `Clone` يؤدي نفس المهمة مثل `Copy`.

نادرًا ما تكون خاصية `Copy` مطلوبة؛ الأنواع التي تطبّق `Copy` لديها تحسينات متاحة، مما يعني أنك لست مضطرًا لاستدعاء `clone`، مما يجعل الكود أكثر إيجازًا.

كل ما هو ممكن مع `Copy` يمكنك أيضًا تحقيقه مع `Clone`، ولكن الكود قد يكون أبطأ أو يضطر لاستخدام `clone` في الأماكن.

### `Hash` لتعيين قيمة إلى قيمة بحجم ثابت

تسمح لك خاصية `Hash` بأخذ مثيل من نوع بحجم عشوائي وتعيين ذلك المثيل إلى قيمة بحجم ثابت باستخدام دالة تجزئة. يطبّق اشتقاق `Hash` طريقة `hash`. يجمع التطبيق المشتق لطريقة `hash` نتيجة استدعاء `hash` على كل جزء من أجزاء النوع، مما يعني أن جميع الحقول أو القيم يجب أن تطبّق أيضًا `Hash` لاشتقاق `Hash`.

مثال على متى تكون `Hash` مطلوبة هو في تخزين المفاتيح في `HashMap<K, V>` لتخزين البيانات بكفاءة.

### `Default` للقيم الافتراضية

تسمح لك خاصية `Default` بإنشاء قيمة افتراضية لنوع. يطبّق اشتقاق `Default` دالة `default`. يستدعي التطبيق المشتق لدالة `default` دالة `default` على كل جزء من النوع، مما يعني أن جميع الحقول أو القيم في النوع يجب أن تطبّق أيضًا `Default` لاشتقاق `Default`.

تُستخدم دالة `Default::default` بشكل شائع مع صيغة تحديث البنية التي تمت مناقشتها في قسم ["إنشاء مثيلات من مثيلات أخرى بصيغة تحديث البنية"][creating-instances-from-other-instances-with-struct-update-syntax]<!-- ignore --> في الفصل 5. يمكنك تخصيص بعض حقول بنية ثم تعيين واستخدام قيمة افتراضية لبقية الحقول باستخدام `..Default::default()`.

خاصية `Default` مطلوبة عند استخدام طريقة `unwrap_or_default` على مثيلات `Option<T>`، على سبيل المثال. إذا كانت `Option<T>` هي `None`، فستُرجع طريقة `unwrap_or_default` نتيجة `Default::default` للنوع `T` المخزن في `Option<T>`.

[creating-instances-from-other-instances-with-struct-update-syntax]: ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
[stack-only-data-copy]: ch04-01-what-is-ownership.html#stack-only-data-copy
[variables-and-data-interacting-with-clone]: ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone
[custom-derive-macros]: ch20-05-macros.html#custom-derive-macros
