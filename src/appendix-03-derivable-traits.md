## ภาคผนวก C: Derivable Traits (เทรตที่สามารถ Derive ได้)

ในหลายๆ ส่วนของหนังสือเล่มนี้ เราได้พูดถึงแอททริบิวต์ `derive` ซึ่งคุณสามารถนำไปใช้กับคำจำกัดความของ struct หรือ enum ได้ แอททริบิวต์ `derive` จะสร้างโค้ดที่จะ υλοποιώ (implement) เทรตด้วย υλοποίηση (implementation) เริ่มต้นของมันเองบนไทป์ที่คุณได้ใส่คำอธิบายประกอบด้วย синтаксис `derive`

ในภาคผนวกนี้ เราได้รวบรวมข้อมูลอ้างอิงของเทรตทั้งหมดในไลบรารีมาตรฐานที่คุณสามารถใช้กับ `derive` ได้ แต่ละส่วนจะครอบคลุมถึง:

- ตัวดำเนินการและเมธอดใดบ้างที่การ derive เทรตนี้จะเปิดใช้งาน
- υλοποίηση (implementation) ของเทรตที่ได้จาก `derive` ทำอะไร
- การ υλοποιώ (implement) เทรตนั้นบ่งบอกอะไรเกี่ยวกับไทป์
- เงื่อนไขที่คุณได้รับอนุญาตหรือไม่ได้รับอนุญาตให้ υλοποιώ (implement) เทรต
- ตัวอย่างของการดำเนินการที่ต้องการเทรตนั้น

หากคุณต้องการพฤติกรรมที่แตกต่างจากที่แอททริบิวต์ `derive` มอบให้ โปรดดู [เอกสารประกอบไลบรารีมาตรฐาน](../std/index.html)<!-- ignore --> สำหรับแต่ละเทรตเพื่อดูรายละเอียดเกี่ยวกับวิธีการ υλοποιώ (implement) ด้วยตนเอง

เทรตที่ระบุไว้ที่นี่เป็นเพียงเทรตเดียวที่กำหนดโดยไลบรารีมาตรฐานที่สามารถ υλοποιώ (implement) บนไทป์ของคุณโดยใช้ `derive` เทรตอื่นๆ ที่กำหนดในไลบรารีมาตรฐานไม่มีพฤติกรรมเริ่มต้นที่สมเหตุสมผล ดังนั้นจึงขึ้นอยู่กับคุณที่จะ υλοποιώ (implement) ในลักษณะที่สมเหตุสมผลกับสิ่งที่คุณพยายามทำให้สำเร็จ

ตัวอย่างของเทรตที่ไม่สามารถ derive ได้คือ `Display` ซึ่งจัดการการจัดรูปแบบสำหรับผู้ใช้ปลายทาง คุณควรพิจารณาวิธีที่เหมาะสมในการแสดงไทป์ต่อผู้ใช้ปลายทางเสมอ ผู้ใช้ปลายทางควรได้รับอนุญาตให้เห็นส่วนใดของไทป์บ้าง? ส่วนใดที่พวกเขาจะพบว่าเกี่ยวข้อง? รูปแบบใดของข้อมูลที่จะเกี่ยวข้องกับพวกเขามากที่สุด? คอมไพเลอร์ Rust ไม่มีข้อมูลเชิงลึกนี้ ดังนั้นจึงไม่สามารถให้พฤติกรรมเริ่มต้นที่เหมาะสมสำหรับคุณได้

รายการของ derivable traits ที่ให้ไว้ในภาคผนวกนี้ไม่ครอบคลุมทั้งหมด: ไลบรารีสามารถ υλοποιώ (implement) `derive` สำหรับเทรตของตนเองได้ ทำให้รายการของเทรตที่คุณสามารถใช้ `derive` ด้วยนั้นเปิดกว้างอย่างแท้จริง การ υλοποιώ (implement) `derive` เกี่ยวข้องกับการใช้ procedural macro ซึ่งครอบคลุมอยู่ในส่วน [“Macros”][macros]<!-- ignore --> ของบทที่ 20

### `Debug` สำหรับ Output ของโปรแกรมเมอร์

เทรต `Debug` เปิดใช้งานการจัดรูปแบบดีบักในสตริงรูปแบบ ซึ่งคุณระบุโดยการเพิ่ม `:?` ภายในวงเล็บปีกกา `{}`

เทรต `Debug` ช่วยให้คุณสามารถพิมพ์อินสแตนซ์ของไทป์เพื่อวัตถุประสงค์ในการดีบัก เพื่อให้คุณและโปรแกรมเมอร์คนอื่นๆ ที่ใช้ไทป์ของคุณสามารถตรวจสอบอินสแตนซ์ ณ จุดใดจุดหนึ่งในการทำงานของโปรแกรมได้

เทรต `Debug` เป็นสิ่งจำเป็น ตัวอย่างเช่น ในการใช้มาโคร `assert_eq!` มาโครนี้จะพิมพ์ค่าของอินสแตนซ์ที่ให้เป็นอาร์กิวเมนต์หากการยืนยันความเท่ากันล้มเหลว เพื่อให้โปรแกรมเมอร์สามารถเห็นได้ว่าทำไมอินสแตนซ์ทั้งสองจึงไม่เท่ากัน

### `PartialEq` และ `Eq` สำหรับการเปรียบเทียบความเท่ากัน

เทรต `PartialEq` ช่วยให้คุณสามารถเปรียบเทียบอินสแตนซ์ของไทป์เพื่อตรวจสอบความเท่ากัน และเปิดใช้งานการใช้ตัวดำเนินการ `==` และ `!=`

การ derive `PartialEq` จะ υλοποιώ (implement) เมธอด `eq` เมื่อ `PartialEq` ถูก derive บน structs อินสแตนซ์สองตัวจะเท่ากันก็ต่อเมื่อฟิลด์ _ทั้งหมด_ เท่ากัน และอินสแตนซ์จะไม่เท่ากันหากมีฟิลด์ใดๆ ไม่เท่ากัน เมื่อ derive บน enums แต่ละ variant จะเท่ากับตัวเองและไม่เท่ากับ variants อื่นๆ

เทรต `PartialEq` เป็นสิ่งจำเป็น ตัวอย่างเช่น กับการใช้มาโคร `assert_eq!` ซึ่งจำเป็นต้องสามารถเปรียบเทียบอินสแตนซ์สองตัวของไทป์เพื่อความเท่ากันได้

เทรต `Eq` ไม่มีเมธอด จุดประสงค์ของมันคือเพื่อส่งสัญญาณว่าสำหรับทุกค่าของไทป์ที่มีคำอธิบายประกอบ ค่านั้นจะเท่ากับตัวเอง เทรต `Eq` สามารถใช้ได้กับไทป์ที่ υλοποιώ (implement) `PartialEq` ด้วยเท่านั้น แม้ว่าไม่ใช่ทุกไทป์ที่ υλοποιώ (implement) `PartialEq` จะสามารถ υλοποιώ (implement) `Eq` ได้ ตัวอย่างหนึ่งคือไทป์ของตัวเลขทศนิยม: υλοποίηση (implementation) ของตัวเลขทศนิยมระบุว่าอินสแตนซ์สองตัวของค่าที่ไม่ใช่ตัวเลข (`NaN`) จะไม่เท่ากัน

ตัวอย่างของเมื่อ `Eq` เป็นสิ่งจำเป็นคือสำหรับ keys ใน `HashMap<K, V>` เพื่อให้ `HashMap<K, V>` สามารถบอกได้ว่า keys สองตัวเหมือนกันหรือไม่

### `PartialOrd` และ `Ord` สำหรับการเปรียบเทียบการเรียงลำดับ

เทรต `PartialOrd` ช่วยให้คุณสามารถเปรียบเทียบอินสแตนซ์ของไทป์เพื่อวัตถุประสงค์ในการเรียงลำดับ ไทป์ที่ υλοποιώ (implement) `PartialOrd` สามารถใช้กับตัวดำเนินการ `<`, `>`, `<=`, และ `>=` ได้ คุณสามารถใช้เทรต `PartialOrd` กับไทป์ที่ υλοποιώ (implement) `PartialEq` ด้วยเท่านั้น

การ derive `PartialOrd` จะ υλοποιώ (implement) เมธอด `partial_cmp` ซึ่งจะคืนค่า `Option<Ordering>` ที่จะเป็น `None` เมื่อค่าที่ให้มาไม่ได้สร้างการเรียงลำดับ ตัวอย่างของค่าที่ไม่ได้สร้างการเรียงลำดับ แม้ว่าค่าส่วนใหญ่ของไทป์นั้นจะสามารถเปรียบเทียบได้ คือค่าทศนิยมที่ไม่ใช่ตัวเลข (`NaN`) การเรียก `partial_cmp` ด้วยตัวเลขทศนิยมใดๆ และค่าทศนิยม `NaN` จะคืนค่า `None`

เมื่อ derive บน structs `PartialOrd` จะเปรียบเทียบอินสแตนซ์สองตัวโดยการเปรียบเทียบค่าในแต่ละฟิลด์ตามลำดับที่ฟิลด์ปรากฏในคำจำกัดความของ struct เมื่อ derive บน enums variants ของ enum ที่ประกาศไว้ก่อนหน้าในคำจำกัดความของ enum จะถือว่าน้อยกว่า variants ที่ระบุไว้ในภายหลัง

เทรต `PartialOrd` เป็นสิ่งจำเป็น ตัวอย่างเช่น สำหรับเมธอด `gen_range` จาก крейт `rand` ที่สร้างค่าสุ่มในช่วงที่ระบุโดยนิพจน์ช่วง

เทรต `Ord` ช่วยให้คุณทราบว่าสำหรับค่าสองค่าใดๆ ของไทป์ที่มีคำอธิบายประกอบ จะมีการเรียงลำดับที่ถูกต้องอยู่เสมอ เทรต `Ord` υλοποιώ (implement) เมธอด `cmp` ซึ่งจะคืนค่า `Ordering` แทนที่จะเป็น `Option<Ordering>` เนื่องจากการเรียงลำดับที่ถูกต้องจะเป็นไปได้เสมอ คุณสามารถใช้เทรต `Ord` กับไทป์ที่ υλοποιώ (implement) `PartialOrd` และ `Eq` (และ `Eq` ต้องการ `PartialEq`) ด้วยเท่านั้น เมื่อ derive บน structs และ enums `cmp` จะทำงานในลักษณะเดียวกับ υλοποίηση (implementation) ที่ derive สำหรับ `partial_cmp` ด้วย `PartialOrd`

ตัวอย่างของเมื่อ `Ord` เป็นสิ่งจำเป็นคือเมื่อเก็บค่าใน `BTreeSet<T>` ซึ่งเป็นโครงสร้างข้อมูลที่เก็บข้อมูลตามลำดับการจัดเรียงของค่า

### `Clone` และ `Copy` สำหรับการทำซ้ำค่า

เทรต `Clone` ช่วยให้คุณสามารถสร้างสำเนาลึก (deep copy) ของค่าได้อย่างชัดเจน และกระบวนการทำซ้ำอาจเกี่ยวข้องกับการรันโค้ดที่กำหนดเองและการคัดลอกข้อมูลบน heap ดู [“ตัวแปรและข้อมูลมีปฏิสัมพันธ์กับ Clone”][variables-and-data-interacting-with-clone]<!-- ignore --> ในบทที่ 4 สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ `Clone`

การ derive `Clone` จะ υλοποιώ (implement) เมธอด `clone` ซึ่งเมื่อ υλοποιώ (implement) สำหรับทั้งไทป์ จะเรียก `clone` บนแต่ละส่วนของไทป์นั้น ซึ่งหมายความว่าฟิลด์หรือค่าทั้งหมดในไทป์จะต้อง υλοποιώ (implement) `Clone` ด้วยเพื่อที่จะ derive `Clone`

ตัวอย่างของเมื่อ `Clone` เป็นสิ่งจำเป็นคือเมื่อเรียกเมธอด `to_vec` บน slice slice ไม่ได้เป็นเจ้าของอินสแตนซ์ของไทป์ที่มันมีอยู่ แต่ vector ที่คืนค่าจาก `to_vec` จะต้องเป็นเจ้าของอินสแตนซ์ของมัน ดังนั้น `to_vec` จึงเรียก `clone` บนแต่ละไอเท็ม ดังนั้นไทป์ที่เก็บไว้ใน slice จะต้อง υλοποιώ (implement) `Clone`

เทรต `Copy` ช่วยให้คุณสามารถทำซ้ำค่าได้โดยการคัดลอกบิตที่เก็บไว้บน stack เท่านั้น ไม่จำเป็นต้องใช้โค้ดที่กำหนดเอง ดู [“ข้อมูลเฉพาะ Stack: Copy”][stack-only-data-copy]<!-- ignore --> ในบทที่ 4 สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ `Copy`

เทรต `Copy` ไม่ได้กำหนดเมธอดใดๆ เพื่อป้องกันไม่ให้โปรแกรมเมอร์ overload เมธอดเหล่านั้นและละเมิดข้อสันนิษฐานที่ว่าไม่มีโค้ดที่กำหนดเองกำลังทำงาน ด้วยวิธีนี้ โปรแกรมเมอร์ทุกคนสามารถสันนิษฐานได้ว่าการคัดลอกค่าจะรวดเร็วมาก

คุณสามารถ derive `Copy` บนไทป์ใดๆ ที่ทุกส่วนของมัน υλοποιώ (implement) `Copy` ไทป์ที่ υλοποιώ (implement) `Copy` จะต้อง υλοποιώ (implement) `Clone` ด้วย เนื่องจากไทป์ที่ υλοποιώ (implement) `Copy` มี υλοποίηση (implementation) ของ `Clone` ที่ไม่ซับซ้อนซึ่งทำงานเหมือนกับ `Copy`

เทรต `Copy` ไม่ค่อยจำเป็น ไทป์ที่ υλοποιώ (implement) `Copy` มีการปรับให้เหมาะสม ซึ่งหมายความว่าคุณไม่จำเป็นต้องเรียก `clone` ซึ่งทำให้โค้ดกระชับยิ่งขึ้น

ทุกสิ่งที่ทำได้ด้วย `Copy` คุณก็สามารถทำได้ด้วย `Clone` แต่โค้ดอาจทำงานช้ากว่าหรือต้องใช้ `clone` ในบางแห่ง

### `Hash` สำหรับการจับคู่ค่ากับค่าขนาดคงที่

เทรต `Hash` ช่วยให้คุณสามารถนำอินสแตนซ์ของไทป์ที่มีขนาดใดก็ได้และจับคู่ินสแตนซ์นั้นกับค่าขนาดคงที่โดยใช้ฟังก์ชันแฮช การ derive `Hash` จะ υλοποιώ (implement) เมธอด `hash` υλοποίηση (implementation) ที่ derive ของเมธอด `hash` จะรวมผลลัพธ์ของการเรียก `hash` บนแต่ละส่วนของไทป์ ซึ่งหมายความว่าฟิลด์หรือค่าทั้งหมดจะต้อง υλοποιώ (implement) `Hash` ด้วยเพื่อที่จะ derive `Hash`

ตัวอย่างของเมื่อ `Hash` เป็นสิ่งจำเป็นคือในการเก็บ keys ใน `HashMap<K, V>` เพื่อเก็บข้อมูลอย่างมีประสิทธิภาพ

### `Default` สำหรับค่าเริ่มต้น

เทรต `Default` ช่วยให้คุณสามารถสร้างค่าเริ่มต้นสำหรับไทป์ได้ การ derive `Default` จะ υλοποιώ (implement) ฟังก์ชัน `default` υλοποίηση (implementation) ที่ derive ของฟังก์ชัน `default` จะเรียกฟังก์ชัน `default` บนแต่ละส่วนของไทป์ ซึ่งหมายความว่าฟิลด์หรือค่าทั้งหมดในไทป์จะต้อง υλοποιώ (implement) `Default` ด้วยเพื่อที่จะ derive `Default`

ฟังก์ชัน `Default::default` มักใช้ร่วมกับ синтаксисอัปเดต struct ที่กล่าวถึงใน [“การสร้างอินสแตนซ์จากอินสแตนซ์อื่นด้วย синтаксисอัปเดต Struct”][creating-instances-from-other-instances-with-struct-update-syntax]<!-- ignore --> ในบทที่ 5 คุณสามารถปรับแต่งฟิลด์บางส่วนของ struct แล้วตั้งค่าและใช้ค่าเริ่มต้นสำหรับฟิลด์ที่เหลือโดยใช้ `..Default::default()`

เทรต `Default` เป็นสิ่งจำเป็นเมื่อคุณใช้เมธอด `unwrap_or_default` บนอินสแตนซ์ `Option<T>` เป็นต้น หาก `Option<T>` เป็น `None` เมธอด `unwrap_or_default` จะคืนค่าผลลัพธ์ของ `Default::default` สำหรับไทป์ `T` ที่เก็บไว้ใน `Option<T>`

[creating-instances-from-other-instances-with-struct-update-syntax]: ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
[stack-only-data-copy]: ch04-01-what-is-ownership.html#stack-only-data-copy
[variables-and-data-interacting-with-clone]: ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone
[macros]: ch20-05-macros.html#macros
