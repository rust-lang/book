## تخزين نص مشفر بـ UTF-8 مع السلاسل النصية

تحدثنا عن السلاسل النصية في الفصل 4، لكننا سننظر إليها بمزيد من العمق الآن.
غالبًا ما يواجه مبرمجو Rust الجدد صعوبة مع السلاسل النصية لمجموعة من ثلاثة
أسباب: ميل Rust لكشف الأخطاء المحتملة، كون السلاسل النصية هيكل بيانات أكثر
تعقيدًا مما يعتقد العديد من المبرمجين، و UTF-8. تتحد هذه العوامل بطريقة قد
تبدو صعبة عندما تأتي من لغات برمجة أخرى.

نناقش السلاسل النصية في سياق المجموعات لأن السلاسل النصية مطبقة كمجموعة من
البايتات، بالإضافة إلى بعض الدوال لتوفير وظائف مفيدة عندما تُفسر هذه البايتات
كنص. في هذا القسم، سنتحدث عن العمليات على `String` التي يحتويها كل نوع مجموعة،
مثل الإنشاء والتحديث والقراءة. سنناقش أيضًا الطرق التي يختلف بها `String` عن
المجموعات الأخرى، أي كيف أن الفهرسة في `String` معقدة بسبب الاختلافات بين كيفية
تفسير البشر والحواسيب لبيانات `String`.

<!-- Old headings. Do not remove or links may break. -->

<a id="what-is-a-string"></a>

### تعريف السلاسل النصية

سنحدد أولاً ما نعنيه بمصطلح _سلسلة نصية_. لدى Rust نوع سلسلة نصية واحد فقط في
اللغة الأساسية، وهو شريحة السلسلة النصية `str` التي عادة ما تُرى في شكلها
المُستعار `&str`. في الفصل 4، تحدثنا عن شرائح السلاسل النصية، وهي مراجع لبعض
بيانات السلاسل النصية المشفرة بـ UTF-8 المخزنة في مكان آخر. السلاسل النصية
الحرفية، على سبيل المثال، مخزنة في ملف البرنامج الثنائي وبالتالي فهي شرائح
سلاسل نصية.

نوع `String`، الذي توفره المكتبة القياسية لـ Rust بدلاً من كونه مشفرًا في اللغة
الأساسية، هو نوع سلسلة نصية قابل للنمو، قابل للتغيير، مملوك، ومشفر بـ UTF-8.
عندما يشير مبرمجو Rust إلى "السلاسل النصية" في Rust، قد يشيرون إلى نوع `String`
أو نوع شريحة السلسلة النصية `&str`، وليس فقط أحد هذه الأنواع. على الرغم من أن
هذا القسم يتعلق بشكل أساسي بـ `String`، إلا أن كلا النوعين يُستخدمان بكثرة في
المكتبة القياسية لـ Rust، وكل من `String` وشرائح السلاسل النصية مشفرة بـ UTF-8.

### إنشاء سلسلة نصية جديدة

العديد من نفس العمليات المتاحة مع `Vec<T>` متاحة أيضًا مع `String` لأن `String`
مطبق فعليًا كغلاف حول متجه من البايتات مع بعض الضمانات والقيود والقدرات
الإضافية. مثال على دالة تعمل بنفس الطريقة مع `Vec<T>` و `String` هي دالة `new`
لإنشاء نسخة، كما هو موضح في القائمة 8-11.

<Listing number="8-11" caption="إنشاء `String` جديدة فارغة">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

</Listing>

ينشئ هذا السطر سلسلة نصية جديدة فارغة تسمى `s`، يمكننا بعد ذلك تحميل البيانات
فيها. غالبًا، سيكون لدينا بعض البيانات الأولية التي نريد بدء السلسلة النصية بها.
لذلك، نستخدم طريقة `to_string`، المتاحة على أي نوع يطبق سمة `Display`، كما تفعل
السلاسل النصية الحرفية. تظهر القائمة 8-12 مثالين.

<Listing number="8-12" caption="استخدام طريقة `to_string` لإنشاء `String` من سلسلة نصية حرفية">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

</Listing>

ينشئ هذا الكود سلسلة نصية تحتوي على `initial contents`.

يمكننا أيضًا استخدام الدالة `String::from` لإنشاء `String` من سلسلة نصية حرفية.
الكود في القائمة 8-13 مكافئ للكود في القائمة 8-12 الذي يستخدم `to_string`.

<Listing number="8-13" caption="استخدام دالة `String::from` لإنشاء `String` من سلسلة نصية حرفية">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

</Listing>

نظرًا لأن السلاسل النصية تُستخدم للعديد من الأشياء، يمكننا استخدام العديد من
واجهات برمجة التطبيقات العامة المختلفة للسلاسل النصية، مما يوفر لنا الكثير من
الخيارات. قد يبدو بعضها زائدًا عن الحاجة، لكن لكل منها مكانها! في هذه الحالة،
تقوم `String::from` و `to_string` بنفس الشيء، لذا فإن اختيار أيهما هو مسألة
أسلوب وقابلية للقراءة.

تذكر أن السلاسل النصية مشفرة بـ UTF-8، لذا يمكننا تضمين أي بيانات مشفرة بشكل
صحيح فيها، كما هو موضح في القائمة 8-14.

<Listing number="8-14" caption="تخزين تحيات بلغات مختلفة في سلاسل نصية">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

</Listing>

كل هذه قيم `String` صالحة.

### تحديث سلسلة نصية

يمكن أن تنمو `String` في الحجم ويمكن أن تتغير محتوياتها، تمامًا مثل محتويات
`Vec<T>`، إذا قمت بدفع المزيد من البيانات إليها. بالإضافة إلى ذلك، يمكنك بسهولة
استخدام معامل `+` أو ماكرو `format!` لتجميع قيم `String`.

<!-- Old headings. Do not remove or links may break. -->

<a id="appending-to-a-string-with-push_str-and-push"></a>

#### الإلحاق باستخدام `push_str` أو `push`

يمكننا تنمية `String` باستخدام طريقة `push_str` لإلحاق شريحة سلسلة نصية، كما هو
موضح في القائمة 8-15.

<Listing number="8-15" caption="إلحاق شريحة سلسلة نصية إلى `String` باستخدام طريقة `push_str`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

</Listing>

بعد هذين السطرين، ستحتوي `s` على `foobar`. تأخذ طريقة `push_str` شريحة سلسلة
نصية لأننا لا نريد بالضرورة أخذ ملكية المعامل. على سبيل المثال، في الكود في
القائمة 8-16، نريد أن نكون قادرين على استخدام `s2` بعد إلحاق محتوياته بـ `s1`.

<Listing number="8-16" caption="استخدام شريحة سلسلة نصية بعد إلحاق محتوياتها بـ `String`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

</Listing>

إذا أخذت طريقة `push_str` ملكية `s2`، فلن نتمكن من طباعة قيمتها في السطر الأخير.
ومع ذلك، يعمل هذا الكود كما نتوقع!

تأخذ طريقة `push` حرفًا واحدًا كمعامل وتضيفه إلى `String`. تضيف القائمة 8-17
الحرف _l_ إلى `String` باستخدام طريقة `push`.

<Listing number="8-17" caption="إضافة حرف واحد إلى قيمة `String` باستخدام `push`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

</Listing>

نتيجة لذلك، ستحتوي `s` على `lol`.

<!-- Old headings. Do not remove or links may break. -->

<a id="concatenation-with-the--operator-or-the-format-macro"></a>

#### الترجمة باستخدام `+` أو `format!`

غالبًا، ستريد دمج سلسلتين نصيتين موجودتين. إحدى الطرق للقيام بذلك هي استخدام
معامل `+`، كما هو موضح في القائمة 8-18.

<Listing number="8-18" caption="استخدام معامل `+` لدمج قيمتي `String` في قيمة `String` جديدة">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

</Listing>

ستحتوي السلسلة النصية `s3` على `Hello, world!`. السبب في أن `s1` لم يعد صالحًا
بعد الإضافة، والسبب في أننا استخدمنا مرجعًا لـ `s2`، له علاقة بتوقيع الطريقة
التي تُستدعى عند استخدام معامل `+`. يستخدم معامل `+` طريقة `add`، التي يبدو
توقيعها كالتالي:

```rust,ignore
fn add(self, s: &str) -> String {
```

في المكتبة القياسية، سترى `add` معرفة باستخدام الأنواع العمومية والأنواع المرتبطة.
هنا، استبدلنا الأنواع الملموسة، وهو ما يحدث عندما نستدعي هذه الطريقة بقيم
`String`. سنناقش الأنواع العمومية في الفصل 10. يعطينا هذا التوقيع الإشارات التي
نحتاجها لفهم الأجزاء الصعبة من معامل `+`.

أولاً، لدى `s2` علامة `&`، مما يعني أننا نضيف مرجعًا للسلسلة النصية الثانية إلى
السلسلة النصية الأولى. هذا بسبب معامل `s` في دالة `add`: يمكننا فقط إضافة شريحة
سلسلة نصية إلى `String`؛ لا يمكننا إضافة قيمتي `String` معًا. لكن انتظر—نوع
`&s2` هو `&String`، وليس `&str`، كما هو محدد في المعامل الثاني لـ `add`. إذن،
لماذا تُترجم القائمة 8-18؟

السبب في أننا قادرون على استخدام `&s2` في استدعاء `add` هو أن المصرِّف يمكنه
إجبار وسيطة `&String` على أن تصبح `&str`. عندما نستدعي طريقة `add`، تستخدم Rust
إجبار إلغاء المرجع، والذي يحول هنا `&s2` إلى `&s2[..]`. سنناقش إجبار إلغاء
المرجع بمزيد من التفصيل في الفصل 15. نظرًا لأن `add` لا تأخذ ملكية معامل `s`،
سيظل `s2` `String` صالحًا بعد هذه العملية.

ثانيًا، يمكننا أن نرى في التوقيع أن `add` تأخذ ملكية `self` لأن `self` _لا_
يحتوي على `&`. هذا يعني أن `s1` في القائمة 8-18 سيتم نقله إلى استدعاء `add` ولن
يعود صالحًا بعد ذلك. لذا، على الرغم من أن `let s3 = s1 + &s2;` يبدو وكأنه سينسخ
كلا السلسلتين النصيتين وينشئ سلسلة نصية جديدة، إلا أن هذا البيان يأخذ في الواقع
ملكية `s1`، ويلحق نسخة من محتويات `s2`، ثم يعيد ملكية النتيجة. بعبارة أخرى، يبدو
وكأنه يقوم بالكثير من النسخ ولكنه ليس كذلك؛ التطبيق أكثر كفاءة من النسخ.

إذا كنا بحاجة إلى ترجمة سلاسل نصية متعددة، فإن سلوك معامل `+` يصبح مرهقًا:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

في هذه المرحلة، يكون `s` هو `tic-tac-toe`. مع كل علامات `+` و `"`، من الصعب رؤية
ما يحدث. لتجميع أكثر تعقيدًا، يمكننا بدلاً من ذلك استخدام ماكرو `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

ينشئ هذا الكود أيضًا `s` بمحتوى `tic-tac-toe`. ماكرو `format!` يعمل مثل `println!`،
لكن بدلاً من طباعة الإخراج على الشاشة، فإنه يعيد `String` بالمحتويات. نسخة الكود
التي تستخدم `format!` أسهل بكثير في القراءة، ولا يأخذ الكود الذي يولده ماكرو
`format!` ملكية أي من معاملاته.

### الفهرسة في السلاسل النصية

في العديد من لغات البرمجة الأخرى، يعد الوصول إلى الأحرف الفردية في سلسلة نصية
عن طريق الإشارة إليها بالفهرس عملية صالحة وشائعة. ومع ذلك، إذا حاولت الوصول إلى
أجزاء من `String` باستخدام صيغة الفهرسة في Rust، فستحصل على خطأ. خذ في الاعتبار
الكود غير الصالح في القائمة 8-19.

<Listing number="8-19" caption="محاولة استخدام صيغة الفهرسة مع سلسلة نصية">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

</Listing>

سينتج عن هذا الكود الخطأ التالي:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

يروي الخطأ القصة: السلاسل النصية في Rust لا تدعم الفهرسة. لكن لماذا؟ للإجابة على
هذا السؤال، نحتاج إلى مناقشة كيفية تخزين Rust للسلاسل النصية في الذاكرة.

#### التمثيل الداخلي

`String` هي غلاف حول `Vec<u8>`. دعنا ننظر إلى بعض سلاسلنا النصية المشفرة بشكل
صحيح بـ UTF-8 من القائمة 8-14. أولاً، هذه:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

في هذه الحالة، سيكون `len` هو `4`، مما يعني أن المتجه الذي يخزن السلسلة النصية
`"Hola"` طوله 4 بايتات. يستغرق كل من هذه الأحرف 1 بايت عند التشفير في UTF-8.
ومع ذلك، قد يفاجئك السطر التالي (لاحظ أن هذه السلسلة النصية تبدأ بحرف السيريلية
الكبير _Ze_، وليس الرقم 3):

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

إذا سُئلت عن طول السلسلة النصية، فقد تقول 12. في الواقع، إجابة Rust هي 24: هذا
هو عدد البايتات المطلوبة لتشفير "Здравствуйте" في UTF-8، لأن كل قيمة عددية يونيكود
في تلك السلسلة النصية تستغرق 2 بايت من التخزين. لذلك، لن يرتبط فهرس في بايتات
السلسلة النصية دائمًا بقيمة عددية يونيكود صالحة. لتوضيح ذلك، خذ في الاعتبار هذا
الكود Rust غير الصالح:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

تعرف بالفعل أن `answer` لن يكون `З`، الحرف الأول. عند التشفير في UTF-8، يكون
البايت الأول من `З` هو `208` والثاني هو `151`، لذا يبدو أن `answer` يجب أن يكون
في الواقع `208`، لكن `208` ليس حرفًا صالحًا من تلقاء نفسه. إرجاع `208` ليس على
الأرجح ما يريده المستخدم إذا طلب الحرف الأول من هذه السلسلة النصية؛ ومع ذلك،
هذا هو البيانات الوحيدة التي لدى Rust عند فهرس البايت 0. لا يريد المستخدمون
عمومًا إرجاع قيمة البايت، حتى لو كانت السلسلة النصية تحتوي فقط على أحرف لاتينية:
إذا كان `&"hi"[0]` كودًا صالحًا يعيد قيمة البايت، فسيعيد `104`، وليس `h`.

الجواب، إذن، هو أنه لتجنب إرجاع قيمة غير متوقعة والتسبب في أخطاء قد لا يتم
اكتشافها على الفور، لا تترجم Rust هذا الكود على الإطلاق وتمنع سوء الفهم في وقت
مبكر من عملية التطوير.

<!-- Old headings. Do not remove or links may break. -->

<a id="bytes-and-scalar-values-and-grapheme-clusters-oh-my"></a>

#### البايتات والقيم العددية والمجموعات الرسومية

نقطة أخرى حول UTF-8 هي أن هناك في الواقع ثلاث طرق ذات صلة للنظر إلى السلاسل
النصية من منظور Rust: كبايتات، وقيم عددية، ومجموعات رسومية (أقرب شيء إلى ما
نسميه _أحرف_).

إذا نظرنا إلى الكلمة الهندية "नमस्ते" المكتوبة بخط ديفاناغاري، فإنها مخزنة
كمتجه من قيم `u8` يبدو كالتالي:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

هذا 18 بايت وهو كيف تخزن الحواسيب هذه البيانات في النهاية. إذا نظرنا إليها كقيم
عددية يونيكود، وهي ما يمثله نوع `char` في Rust، تبدو هذه البايتات كالتالي:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

هناك ست قيم `char` هنا، لكن الرابعة والسادسة ليستا أحرفًا: إنهما علامات تشكيلية
لا معنى لها بمفردها. أخيرًا، إذا نظرنا إليها كمجموعات رسومية، سنحصل على ما قد
يسميه الشخص الأحرف الأربعة التي تشكل الكلمة الهندية:

```text
["न", "म", "स्", "ते"]
```

توفر Rust طرقًا مختلفة لتفسير بيانات السلسلة النصية الخام التي تخزنها الحواسيب
بحيث يمكن لكل برنامج اختيار التفسير الذي يحتاجه، بغض النظر عن اللغة البشرية
التي تكون البيانات بها.

سبب أخير لعدم السماح لنا Rust بالفهرسة في `String` للحصول على حرف هو أنه من
المتوقع أن تستغرق عمليات الفهرسة دائمًا وقتًا ثابتًا (O(1)). لكن ليس من الممكن
ضمان هذا الأداء مع `String`، لأن Rust سيتعين عليه المشي عبر المحتويات من البداية
إلى الفهرس لتحديد عدد الأحرف الصالحة الموجودة.

### تقطيع السلاسل النصية

غالبًا ما تكون الفهرسة في سلسلة نصية فكرة سيئة لأنه ليس من الواضح ما يجب أن يكون
نوع الإرجاع لعملية فهرسة السلسلة النصية: قيمة بايت، أو حرف، أو مجموعة رسومية، أو
شريحة سلسلة نصية. إذا كنت تحتاج حقًا إلى استخدام الفهارس لإنشاء شرائح سلاسل
نصية، لذلك، تطلب منك Rust أن تكون أكثر تحديدًا.

بدلاً من الفهرسة باستخدام `[]` برقم واحد، يمكنك استخدام `[]` بنطاق لإنشاء شريحة
سلسلة نصية تحتوي على بايتات معينة:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

هنا، ستكون `s` عبارة عن `&str` تحتوي على أول 4 بايتات من السلسلة النصية. في
وقت سابق، ذكرنا أن كل من هذه الأحرف كان 2 بايت، مما يعني أن `s` ستكون `Зд`.

إذا حاولنا تقطيع جزء فقط من بايتات الحرف بشيء مثل `&hello[0..1]`، فإن Rust ستتعطل
في وقت التشغيل بنفس الطريقة كما لو تم الوصول إلى فهرس غير صالح في متجه:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

يجب عليك استخدام الحذر عند إنشاء شرائح سلاسل نصية بنطاقات، لأن القيام بذلك يمكن
أن يتسبب في تعطل برنامجك.

<!-- Old headings. Do not remove or links may break. -->

<a id="methods-for-iterating-over-strings"></a>

### التكرار عبر السلاسل النصية

أفضل طريقة للعمل على أجزاء من السلاسل النصية هي أن تكون صريحًا حول ما إذا كنت
تريد أحرفًا أو بايتات. للقيم العددية الفردية ليونيكود، استخدم طريقة `chars`.
يفصل استدعاء `chars` على "Зд" ويعيد قيمتين من النوع `char`، ويمكنك التكرار عبر
النتيجة للوصول إلى كل عنصر:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

سيطبع هذا الكود ما يلي:

```text
З
д
```

بدلاً من ذلك، تعيد طريقة `bytes` كل بايت خام، والذي قد يكون مناسبًا لمجالك:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

سيطبع هذا الكود الـ 4 بايتات التي تشكل هذه السلسلة النصية:

```text
208
151
208
180
```

لكن تأكد من تذكر أن قيم يونيكود العددية الصالحة قد تتكون من أكثر من 1 بايت.

الحصول على مجموعات رسومية من السلاسل النصية، كما هو الحال مع خط ديفاناغاري،
معقد، لذا لا توفر المكتبة القياسية هذه الوظيفة. تتوفر صناديق على
[crates.io](https://crates.io/)<!-- ignore --> إذا كانت هذه هي الوظيفة التي
تحتاجها.

<!-- Old headings. Do not remove or links may break. -->

<a id="strings-are-not-so-simple"></a>

### التعامل مع تعقيدات السلاسل النصية

للتلخيص، السلاسل النصية معقدة. تتخذ لغات البرمجة المختلفة خيارات مختلفة حول كيفية
تقديم هذا التعقيد للمبرمج. اختارت Rust جعل المعالجة الصحيحة لبيانات `String`
السلوك الافتراضي لجميع برامج Rust، مما يعني أن المبرمجين يجب أن يبذلوا المزيد من
التفكير في معالجة بيانات UTF-8 مقدمًا. يكشف هذا التبادل عن المزيد من تعقيد
السلاسل النصية مما هو واضح في لغات البرمجة الأخرى، لكنه يمنعك من الاضطرار إلى
التعامل مع الأخطاء التي تتضمن أحرف غير ASCII لاحقًا في دورة حياة التطوير الخاصة
بك.

الأخبار الجيدة هي أن المكتبة القياسية تقدم الكثير من الوظائف المبنية على أنواع
`String` و `&str` للمساعدة في التعامل مع هذه المواقف المعقدة بشكل صحيح. تأكد من
مراجعة الوثائق للطرق المفيدة مثل `contains` للبحث في سلسلة نصية و `replace`
لاستبدال أجزاء من سلسلة نصية بسلسلة نصية أخرى.

دعنا ننتقل إلى شيء أقل تعقيدًا قليلاً: خرائط التجزئة!
