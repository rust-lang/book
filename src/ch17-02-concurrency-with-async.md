<!-- Old headings. Do not remove or links may break. -->

<a id="concurrency-with-async"></a>

## تطبيق التزامن (Concurrency) باستخدام Async

في هذا القسم، سنطبق async على بعض تحديات التزامن (concurrency) نفسها التي تعاملنا معها باستخدام الخيوط (threads) في الفصل 16. نظرًا لأننا تحدثنا بالفعل عن الكثير من الأفكار الأساسية هناك، في هذا القسم سنركز على ما هو مختلف بين الخيوط (threads) والمستقبلات (futures).

في كثير من الحالات، تكون واجهات برمجة التطبيقات (APIs) للعمل مع التزامن باستخدام async مشابهة جدًا لتلك الخاصة باستخدام الخيوط. في حالات أخرى، ينتهي بهم الأمر بأن يكونوا مختلفين تمامًا. حتى عندما تبدو واجهات برمجة التطبيقات _متشابهة_ بين الخيوط و async، فإنها غالبًا ما يكون لها سلوك مختلف - وتقريبًا دائمًا لها خصائص أداء مختلفة.

<!-- Old headings. Do not remove or links may break. -->

<a id="counting"></a>

### إنشاء مهمة (task) جديدة باستخدام `spawn_task`

العملية الأولى التي تعاملنا معها في قسم ["إنشاء خيط (thread) جديد باستخدام `spawn`"][thread-spawn]<!-- ignore --> في الفصل 16 كانت العد على خيطين (threads) منفصلين. لنفعل الشيء نفسه باستخدام async. توفر مكتبة `trpl` دالة `spawn_task` التي تبدو مشابهة جدًا لواجهة برمجة التطبيقات `thread::spawn`، ودالة `sleep` التي هي نسخة async من واجهة برمجة التطبيقات `thread::sleep`. يمكننا استخدام هذه معًا لتنفيذ مثال العد، كما هو موضح في القائمة 17-6.

<Listing number="17-6" caption="إنشاء مهمة جديدة لطباعة شيء واحد بينما تطبع المهمة الرئيسية شيئًا آخر" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-06/src/main.rs:all}}
```

</Listing>

كنقطة انطلاق، نقوم بإعداد دالة `main` باستخدام `trpl::block_on` بحيث يمكن أن تكون دالتنا ذات المستوى الأعلى async.

> ملاحظة: من هذه النقطة فصاعدًا في الفصل، سيتضمن كل مثال نفس كود التغليف هذا بالضبط مع `trpl::block_on` في `main`، لذلك غالبًا ما نتخطاه تمامًا كما نفعل مع `main`. تذكر تضمينه في الكود الخاص بك!

ثم نكتب حلقتين داخل تلك الكتلة، كل منهما تحتوي على استدعاء `trpl::sleep`، الذي ينتظر نصف ثانية (500 ميلي ثانية) قبل إرسال الرسالة التالية. نضع حلقة واحدة في نص `trpl::spawn_task` والأخرى في حلقة `for` ذات المستوى الأعلى. نضيف أيضًا `await` بعد استدعاءات `sleep`.

يتصرف هذا الكود بشكل مشابه للتنفيذ المعتمد على الخيوط - بما في ذلك حقيقة أنك قد ترى الرسائل تظهر بترتيب مختلف في terminal الخاص بك عند تشغيله:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
```

تتوقف هذه النسخة بمجرد انتهاء حلقة `for` في نص كتلة async الرئيسية، لأن المهمة التي تم إنشاؤها بواسطة `spawn_task` يتم إيقافها عند انتهاء دالة `main`. إذا كنت تريد تشغيلها حتى اكتمال المهمة، فستحتاج إلى استخدام مقبض انضمام (join handle) للانتظار حتى تنتهي المهمة الأولى. مع الخيوط، استخدمنا طريقة `join` لـ "حجب" حتى ينتهي الخيط من العمل. في القائمة 17-7، يمكننا استخدام `await` للقيام بنفس الشيء، لأن مقبض المهمة نفسه هو مستقبل. نوع `Output` الخاص به هو `Result`، لذلك نقوم أيضًا بفك تغليفه بعد انتظاره.

<Listing number="17-7" caption="استخدام `await` مع مقبض انضمام لتشغيل مهمة حتى الاكتمال" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-07/src/main.rs:handle}}
```

</Listing>

تعمل هذه النسخة المحدثة حتى تنتهي _كلتا_ الحلقتين:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
```

حتى الآن، يبدو أن async والخيوط تعطينا نتائج مماثلة، فقط بصيغة مختلفة: استخدام `await` بدلاً من استدعاء `join` على مقبض الانضمام، وانتظار استدعاءات `sleep`.

الفرق الأكبر هو أننا لم نحتج إلى إنشاء خيط نظام تشغيل آخر للقيام بذلك. في الواقع، لا نحتاج حتى إلى إنشاء مهمة هنا. نظرًا لأن كتل async يتم ترجمتها إلى مستقبلات مجهولة، يمكننا وضع كل حلقة في كتلة async ونجعل بيئة التشغيل تشغلهما كليهما حتى الاكتمال باستخدام دالة `trpl::join`.

في قسم ["انتظار انتهاء جميع الخيوط"][join-handles]<!-- ignore --> في الفصل 16، أظهرنا كيفية استخدام طريقة `join` على نوع `JoinHandle` المرجع عند استدعاء `std::thread::spawn`. دالة `trpl::join` مشابهة، ولكن للمستقبلات. عندما تعطيها مستقبلين، فإنها تنتج مستقبلًا جديدًا واحدًا يكون ناتجه tuple يحتوي على ناتج كل مستقبل قمت بتمريره بمجرد اكتمال _كليهما_. وبالتالي، في القائمة 17-8، نستخدم `trpl::join` للانتظار حتى ينتهي كل من `fut1` و `fut2`. نحن _لا_ ننتظر `fut1` و `fut2` بل المستقبل الجديد الذي ينتجه `trpl::join`. نتجاهل الناتج، لأنه مجرد tuple يحتوي على قيمتي وحدة.

<Listing number="17-8" caption="استخدام `trpl::join` لانتظار كتلتي async مجهولتين" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-08/src/main.rs:join}}
```

</Listing>

عندما نشغل هذا، نرى كلا المستقبلين يعملان حتى الاكتمال:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
```

الآن، سترى نفس الترتيب بالضبط في كل مرة، وهو مختلف تمامًا عما رأيناه مع الخيوط ومع `trpl::spawn_task` في القائمة 17-7. ذلك لأن دالة `trpl::join` _عادلة_ (fair)، مما يعني أنها تتحقق من كل مستقبل بشكل متساوٍ، متناوبة بينهما، ولا تدع واحدًا يسبق إذا كان الآخر جاهزًا. مع الخيوط، يقرر نظام التشغيل أي خيط يجب التحقق منه ومدة السماح له بالعمل. مع async في Rust، تقرر بيئة التشغيل أي مهمة يجب التحقق منها. (عمليًا، تصبح التفاصيل معقدة لأن بيئة تشغيل async قد تستخدم خيوط نظام التشغيل تحت الغطاء كجزء من كيفية إدارة التزامن، لذلك قد يكون ضمان العدالة المزيد من العمل لبيئة التشغيل - لكنه لا يزال ممكنًا!) لا يتعين على بيئات التشغيل ضمان العدالة لأي عملية معينة، وغالبًا ما توفر واجهات برمجة تطبيقات مختلفة لتتيح لك اختيار ما إذا كنت تريد العدالة أم لا.

جرب بعضًا من هذه الاختلافات في انتظار المستقبلات وانظر ماذا يفعلون:

- إزالة كتلة async من حول إحدى الحلقتين أو كليهما.
- انتظار كل كتلة async فور تحديدها.
- تغليف الحلقة الأولى فقط في كتلة async، وانتظار المستقبل الناتج بعد نص الحلقة الثانية.

كتحدي إضافي، انظر إذا كنت تستطيع معرفة ما سيكون الناتج في كل حالة _قبل_ تشغيل الكود!

<!-- Old headings. Do not remove or links may break. -->

<a id="message-passing"></a>
<a id="counting-up-on-two-tasks-using-message-passing"></a>

### إرسال البيانات بين مهمتين (tasks) باستخدام تمرير الرسائل (message passing)

سيكون مشاركة البيانات بين المستقبلات (futures) مألوفًا أيضًا: سنستخدم تمرير الرسائل (message passing) مرة أخرى، لكن هذه المرة بإصدارات async من الأنواع والدوال. سنأخذ مسارًا مختلفًا قليلاً عما فعلناه في قسم ["نقل البيانات بين الخيوط بتمرير الرسائل"][message-passing-threads]<!-- ignore --> في الفصل 16 لتوضيح بعض الاختلافات الرئيسية بين التزامن المعتمد على الخيوط والتزامن المعتمد على المستقبلات. في القائمة 17-9، سنبدأ بكتلة async واحدة فقط - _لا_ ننشئ مهمة منفصلة كما أنشأنا خيطًا منفصلاً.

<Listing number="17-9" caption="إنشاء قناة async وتعيين النصفين إلى `tx` و `rx`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-09/src/main.rs:channel}}
```

</Listing>

هنا، نستخدم `trpl::channel`، وهي نسخة async من واجهة برمجة التطبيقات للقناة متعددة المنتجين أحادية المستهلك التي استخدمناها مع الخيوط في الفصل 16. النسخة async من واجهة برمجة التطبيقات مختلفة قليلاً فقط عن النسخة المعتمدة على الخيوط: تستخدم مستقبل `rx` قابل للتغيير بدلاً من غير قابل للتغيير، وطريقة `recv` الخاصة بها تنتج مستقبلًا نحتاج إلى انتظاره بدلاً من إنتاج القيمة مباشرة. الآن يمكننا إرسال رسائل من المرسل إلى المستقبل. لاحظ أننا لا نحتاج إلى إنشاء خيط منفصل أو حتى مهمة؛ نحتاج فقط إلى انتظار استدعاء `rx.recv`.

طريقة `Receiver::recv` المتزامنة في `std::mpsc::channel` تحجب حتى تستلم رسالة. طريقة `trpl::Receiver::recv` لا تفعل ذلك، لأنها async. بدلاً من الحجب، تعيد التحكم إلى بيئة التشغيل حتى يتم استلام رسالة أو إغلاق جانب الإرسال من القناة. على النقيض من ذلك، لا ننتظر استدعاء `send`، لأنه لا يحجب. لا يحتاج إلى ذلك، لأن القناة التي نرسل إليها غير محدودة.

> ملاحظة: نظرًا لأن كل هذا الكود async يعمل في كتلة async في استدعاء `trpl::block_on`، يمكن لكل شيء بداخله تجنب الحجب. ومع ذلك، فإن الكود _خارجه_ سيحجب على دالة `block_on` التي ترجع. هذه هي النقطة الكاملة لدالة `trpl::block_on`: تتيح لك _اختيار_ مكان الحجب على بعض مجموعة من الكود async، وبالتالي مكان الانتقال بين الكود المتزامن وغير المتزامن.

لاحظ شيئين حول هذا المثال. أولاً، ستصل الرسالة على الفور. ثانيًا، على الرغم من أننا نستخدم مستقبلًا هنا، لا يوجد تزامن بعد. كل شيء في القائمة يحدث بالتسلسل، تمامًا كما لو لم يكن هناك مستقبلات متضمنة.

دعنا نعالج الجزء الأول عن طريق إرسال سلسلة من الرسائل والنوم بينها، كما هو موضح في القائمة 17-10.

<!-- We cannot test this one because it never stops! -->

<Listing number="17-10" caption="إرسال واستقبال رسائل متعددة عبر القناة async والنوم مع `await` بين كل رسالة" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-10/src/main.rs:many-messages}}
```

</Listing>

بالإضافة إلى إرسال الرسائل، نحتاج إلى استقبالها. في هذه الحالة، نظرًا لأننا نعرف عدد الرسائل القادمة، يمكننا القيام بذلك يدويًا عن طريق استدعاء `rx.recv().await` أربع مرات. ولكن في العالم الحقيقي، سننتظر عادةً بعض العدد _غير المعروف_ من الرسائل، لذلك نحتاج إلى الاستمرار في الانتظار حتى نحدد أنه لا توجد المزيد من الرسائل.

في القائمة 16-10، استخدمنا حلقة `for` لمعالجة جميع العناصر المستلمة من قناة متزامنة. ومع ذلك، ليس لدى Rust بعد طريقة لاستخدام حلقة `for` مع سلسلة من العناصر _المنتجة بشكل غير متزامن_، لذلك نحتاج إلى استخدام حلقة لم نرها من قبل: حلقة `while let` الشرطية. هذه هي نسخة الحلقة من بناء `if let` الذي رأيناه في قسم ["تدفق التحكم المختصر باستخدام `if let` و `let else`"][if-let]<!-- ignore --> في الفصل 6. ستستمر الحلقة في التنفيذ طالما استمر النمط الذي تحدده في مطابقة القيمة.

يُنتج استدعاء `rx.recv` مستقبلًا، والذي ننتظره. ستوقف بيئة التشغيل المستقبل مؤقتًا حتى يصبح جاهزًا. بمجرد وصول رسالة، سيتحول المستقبل إلى `Some(message)` بقدر ما تصل رسالة. عندما تُغلق القناة، بغض النظر عما إذا كانت قد وصلت _أي_ رسائل، سيتحول المستقبل بدلاً من ذلك إلى `None` للإشارة إلى عدم وجود المزيد من القيم وبالتالي يجب أن نتوقف عن الاستطلاع - أي، نتوقف عن الانتظار.

تجمع حلقة `while let` كل هذا معًا. إذا كانت نتيجة استدعاء `rx.recv().await` هي `Some(message)`، فنحصل على الوصول إلى الرسالة ويمكننا استخدامها في نص الحلقة، تمامًا كما يمكننا مع `if let`. إذا كانت النتيجة `None`، تنتهي الحلقة. في كل مرة تكتمل فيها الحلقة، تصل إلى نقطة await مرة أخرى، لذلك توقفها بيئة التشغيل مؤقتًا مرة أخرى حتى تصل رسالة أخرى.

ينجح الكود الآن في إرسال واستقبال جميع الرسائل. لسوء الحظ، لا يزال هناك مشكلتان. أولاً، لا تصل الرسائل على فترات نصف ثانية. إنها تصل جميعًا مرة واحدة، بعد ثانيتين (2000 ميلي ثانية) من بدء البرنامج. ثانيًا، لا ينتهي هذا البرنامج أبدًا! بدلاً من ذلك، ينتظر إلى الأبد رسائل جديدة. ستحتاج إلى إيقافه باستخدام <kbd>ctrl</kbd>-<kbd>C</kbd>.

#### الكود داخل كتلة Async واحدة يتم تنفيذه خطيًا

لنبدأ بفحص سبب وصول الرسائل جميعها في وقت واحد بعد التأخير الكامل، بدلاً من الوصول مع تأخيرات بينها. داخل كتلة async معينة، الترتيب الذي تظهر فيه الكلمات الأساسية `await` في الكود هو أيضًا الترتيب الذي يتم فيه تنفيذها عند تشغيل البرنامج.

يوجد كتلة async واحدة فقط في القائمة 17-10، لذلك كل شيء فيها يعمل خطيًا. لا يزال لا يوجد تزامن. تحدث جميع استدعاءات `tx.send`، متناثرة مع جميع استدعاءات `trpl::sleep` ونقاط await المرتبطة بها. بعد ذلك فقط تصل حلقة `while let` للذهاب خلال أي من نقاط `await` على استدعاءات `recv`.

للحصول على السلوك الذي نريده، حيث يحدث تأخير النوم بين كل رسالة، نحتاج إلى وضع عمليات `tx` و `rx` في كتل async الخاصة بها، كما هو موضح في القائمة 17-11. ثم يمكن لبيئة التشغيل تنفيذ كل منها بشكل منفصل باستخدام `trpl::join`، تمامًا كما في القائمة 17-8. مرة أخرى، ننتظر نتيجة استدعاء `trpl::join`، وليس المستقبلات الفردية. إذا انتظرنا المستقبلات الفردية بالتسلسل، فسننتهي مرة أخرى في تدفق تسلسلي - بالضبط ما نحاول _عدم_ القيام به.

<!-- We cannot test this one because it never stops! -->

<Listing number="17-11" caption="فصل `send` و `recv` إلى كتل `async` الخاصة بهما وانتظار المستقبلات لتلك الكتل" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-11/src/main.rs:futures}}
```

</Listing>

مع الكود المحدث في القائمة 17-11، يتم طباعة الرسائل على فترات 500 ميلي ثانية، بدلاً من كلها في اندفاع بعد ثانيتين.

#### نقل الملكية إلى كتلة Async

ومع ذلك، لا يزال البرنامج لا ينتهي أبدًا، بسبب الطريقة التي تتفاعل بها حلقة `while let` مع `trpl::join`:

- المستقبل المرجع من `trpl::join` يكتمل فقط بمجرد اكتمال _كلا_ المستقبلين الممررين إليه.
- يكتمل المستقبل `tx_fut` بمجرد الانتهاء من النوم بعد إرسال آخر رسالة في `vals`.
- لن يكتمل المستقبل `rx_fut` حتى تنتهي حلقة `while let`.
- لن تنتهي حلقة `while let` حتى ينتج انتظار `rx.recv` `None`.
- سيعيد انتظار `rx.recv` `None` فقط بمجرد إغلاق الطرف الآخر من القناة.
- ستُغلق القناة فقط إذا استدعينا `rx.close` أو عندما يتم إسقاط جانب المرسل، `tx`.
- نحن لا نستدعي `rx.close` في أي مكان، ولن يتم إسقاط `tx` حتى تنتهي كتلة async الخارجية الممررة إلى `trpl::block_on`.
- لا يمكن للكتلة أن تنتهي لأنها محجوبة على اكتمال `trpl::join`، مما يعيدنا إلى أعلى هذه القائمة.

الآن، كتلة async التي نرسل فيها الرسائل فقط _تستعير_ `tx` لأن إرسال رسالة لا يتطلب الملكية، ولكن إذا استطعنا _نقل_ `tx` إلى تلك الكتلة async، فسيتم إسقاطها بمجرد انتهاء تلك الكتلة. في قسم ["التقاط المراجع أو نقل الملكية"][capture-or-move]<!-- ignore --> في الفصل 13، تعلمت كيفية استخدام الكلمة الأساسية `move` مع الإغلاقات، وكما تمت مناقشته في قسم ["استخدام إغلاقات `move` مع الخيوط"][move-threads]<!-- ignore --> في الفصل 16، غالبًا ما نحتاج إلى نقل البيانات إلى الإغلاقات عند العمل مع الخيوط. تنطبق نفس الديناميكيات الأساسية على كتل async، لذلك تعمل الكلمة الأساسية `move` مع كتل async تمامًا كما تفعل مع الإغلاقات.

في القائمة 17-12، نقوم بتغيير الكتلة المستخدمة لإرسال الرسائل من `async` إلى `async move`.

<Listing number="17-12" caption="مراجعة للكود من القائمة 17-11 التي تُغلق بشكل صحيح عند الاكتمال" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-12/src/main.rs:with-move}}
```

</Listing>

عندما نشغل _هذه_ النسخة من الكود، يُغلق بشكل جيد بعد إرسال واستقبال آخر رسالة. بعد ذلك، دعنا نرى ما يحتاج إلى التغيير لإرسال البيانات من أكثر من مستقبل واحد.

#### ضم عدد من المستقبلات باستخدام ماكرو `join!`

هذه القناة async هي أيضًا قناة متعددة المنتجين، لذلك يمكننا استدعاء `clone` على `tx` إذا أردنا إرسال رسائل من مستقبلات متعددة، كما هو موضح في القائمة 17-13.

<Listing number="17-13" caption="استخدام منتجين متعددين مع كتل async" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-13/src/main.rs:here}}
```

</Listing>

أولاً، نستنسخ `tx`، منشئين `tx1` خارج كتلة async الأولى. ننقل `tx1` إلى تلك الكتلة تمامًا كما فعلنا من قبل مع `tx`. ثم، لاحقًا، ننقل `tx` الأصلي إلى كتلة async _جديدة_، حيث نرسل المزيد من الرسائل على تأخير أبطأ قليلاً. يحدث أننا نضع هذه الكتلة async الجديدة بعد كتلة async لاستقبال الرسائل، لكن يمكن أن تذهب قبلها بنفس الطريقة. المفتاح هو ترتيب انتظار المستقبلات، وليس ترتيب إنشائها.

يجب أن تكون كلتا كتلتي async لإرسال الرسائل كتل `async move` بحيث يتم إسقاط كل من `tx` و `tx1` عند انتهاء تلك الكتل. وإلا، فسننتهي مرة أخرى في نفس الحلقة اللانهائية التي بدأنا بها.

أخيرًا، نتحول من `trpl::join` إلى `trpl::join!` للتعامل مع المستقبل الإضافي: ماكرو `join!` ينتظر عددًا عشوائيًا من المستقبلات حيث نعرف عدد المستقبلات في وقت الترجمة. سنناقش انتظار مجموعة من عدد غير معروف من المستقبلات لاحقًا في هذا الفصل.

الآن نرى جميع الرسائل من كلا مستقبلي الإرسال، ولأن مستقبلي الإرسال يستخدمان تأخيرات مختلفة قليلاً بعد الإرسال، يتم استقبال الرسائل أيضًا على تلك الفترات المختلفة:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
```

لقد استكشفنا كيفية استخدام تمرير الرسائل لإرسال البيانات بين المستقبلات، وكيف يعمل الكود داخل كتلة async بشكل تسلسلي، وكيفية نقل الملكية إلى كتلة async، وكيفية ضم مستقبلات متعددة. بعد ذلك، دعنا نناقش كيف ولماذا نخبر بيئة التشغيل أنه يمكنها التبديل إلى مهمة أخرى.

[thread-spawn]: ch16-01-threads.html#creating-a-new-thread-with-spawn
[join-handles]: ch16-01-threads.html#waiting-for-all-threads-to-finish
[message-passing-threads]: ch16-02-message-passing.html
[if-let]: ch06-03-if-let.html
[capture-or-move]: ch13-01-closures.html#capturing-references-or-moving-ownership
[move-threads]: ch16-01-threads.html#using-move-closures-with-threads
