## تدفق التحكم

القدرة على تشغيل بعض الأكواد اعتماداً على ما إذا كان شرط معين `true` والقدرة على تشغيل بعض الأكواد بشكل متكرر بينما يكون الشرط `true` هي لبنات بناء أساسية في معظم لغات البرمجة. أكثر البنى شيوعاً التي تسمح لك بالتحكم في تدفق تنفيذ كود Rust هي تعبيرات `if` والحلقات.

### تعبيرات `if`

يسمح لك تعبير `if` بتفريع كودك اعتماداً على الشروط. أنت توفر شرطاً ثم تقول، "إذا تحقق هذا الشرط، شغل هذه الكتلة من الكود. إذا لم يتحقق الشرط، لا تشغل هذه الكتلة من الكود."

أنشئ مشروعاً جديداً يسمى _branches_ في دليل _projects_ الخاص بك لاستكشاف تعبير `if`. في ملف _src/main.rs_، أدخل ما يلي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-26-if-true/src/main.rs}}
```

جميع تعبيرات `if` تبدأ بالكلمة المفتاحية `if`، متبوعة بشرط. في هذه الحالة، يتحقق الشرط مما إذا كان المتغير `number` له قيمة أقل من 5. نضع كتلة الكود التي سيتم تنفيذها إذا كان الشرط `true` مباشرة بعد الشرط داخل أقواس معقوفة. كتل الكود المرتبطة بالشروط في تعبيرات `if` تسمى أحياناً _أذرع_، تماماً مثل الأذرع في تعبيرات `match` التي ناقشناها في قسم ["مقارنة التخمين بالرقم السري"][comparing-the-guess-to-the-secret-number]<!-- ignore --> من الفصل 2.

اختيارياً، يمكننا أيضاً تضمين تعبير `else`، الذي اخترنا القيام به هنا، لإعطاء البرنامج كتلة كود بديلة لتنفيذها في حال كان تقييم الشرط `false`. إذا لم توفر تعبير `else` وكان الشرط `false`، سيقوم البرنامج ببساطة بتخطي كتلة `if` والانتقال إلى الجزء التالي من الكود.

جرّب تشغيل هذا الكود؛ يجب أن ترى الإخراج التالي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-26-if-true/output.txt}}
```

لنجرب تغيير قيمة `number` إلى قيمة تجعل الشرط `false` لنرى ما يحدث:

```rust,ignore
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-27-if-false/src/main.rs:here}}
```

شغّل البرنامج مرة أخرى، وانظر إلى الإخراج:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-27-if-false/output.txt}}
```

من الجدير بالذكر أيضاً أن الشرط في هذا الكود _يجب_ أن يكون `bool`. إذا لم يكن الشرط `bool`، سنحصل على خطأ. على سبيل المثال، جرب تشغيل الكود التالي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/src/main.rs}}
```

شرط `if` يُقَيَّم إلى قيمة `3` هذه المرة، وRust يطرح خطأ:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/output.txt}}
```

يشير الخطأ إلى أن Rust توقعت `bool` لكن حصلت على عدد صحيح. على عكس لغات مثل Ruby و JavaScript، لن تحاول Rust تلقائياً تحويل الأنواع غير المنطقية إلى منطقية. يجب أن تكون صريحاً وأن توفر دائماً لـ `if` قيمة منطقية كشرطها. إذا أردنا أن تعمل كتلة كود `if` فقط عندما لا يكون الرقم مساوياً لـ `0`، على سبيل المثال، يمكننا تغيير تعبير `if` إلى التالي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-29-if-not-equal-0/src/main.rs}}
```

تشغيل هذا الكود سيطبع `number was something other than zero`.

#### معالجة شروط متعددة مع `else if`

يمكنك استخدام شروط متعددة عن طريق الجمع بين `if` و `else` في تعبير `else if`. على سبيل المثال:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-30-else-if/src/main.rs}}
```

هذا البرنامج لديه أربعة مسارات محتملة يمكن أن يسلكها. بعد تشغيله، يجب أن ترى الإخراج التالي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-30-else-if/output.txt}}
```

عندما يُنَفَّذ هذا البرنامج، يفحص كل تعبير `if` بالتتابع وينفذ أول جسم يُقَيَّم شرطه إلى `true`. لاحظ أنه على الرغم من أن 6 قابل للقسمة على 2، لا نرى الإخراج `number is divisible by 2`، ولا نرى النص `number is not divisible by 4, 3, or 2` من كتلة `else`. ذلك لأن Rust تنفذ فقط الكتلة الخاصة بأول شرط `true`، وبمجرد أن تجد واحداً، لا تفحص حتى البقية.

استخدام الكثير من تعبيرات `else if` يمكن أن يزدحم كودك، لذا إذا كان لديك أكثر من واحد، قد ترغب في إعادة هيكلة كودك. يصف الفصل 6 بنية تفريع قوية في Rust تسمى `match` لهذه الحالات.

#### استخدام `if` في جملة `let`

لأن `if` هو تعبير، يمكننا استخدامه على الجانب الأيمن من جملة `let` لإسناد النتيجة إلى متغير، كما في القائمة 3-2.

<Listing number="3-2" file-name="src/main.rs" caption="إسناد نتيجة تعبير `if` إلى متغير">

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-02/src/main.rs}}
```

</Listing>

سيتم ربط المتغير `number` بقيمة بناءً على نتيجة تعبير `if`. شغّل هذا الكود لترى ما يحدث:

```console
{{#include ../listings/ch03-common-programming-concepts/listing-03-02/output.txt}}
```

تذكر أن كتل الكود تُقَيَّم إلى آخر تعبير فيها، والأرقام بحد ذاتها هي أيضاً تعبيرات. في هذه الحالة، قيمة تعبير `if` الكامل تعتمد على أي كتلة كود تُنَفَّذ. هذا يعني أن القيم التي لديها إمكانية أن تكون نتائج من كل ذراع في `if` يجب أن تكون من نفس النوع؛ في القائمة 3-2، كانت نتائج كل من ذراع `if` وذراع `else` أعداداً صحيحة من نوع `i32`. إذا كانت الأنواع غير متطابقة، كما في المثال التالي، سنحصل على خطأ:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/src/main.rs}}
```

عندما نحاول تجميع هذا الكود، سنحصل على خطأ. أذرع `if` و `else` لها أنواع قيم غير متوافقة، وRust تشير بالضبط إلى مكان المشكلة في البرنامج:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/output.txt}}
```

التعبير في كتلة `if` يُقَيَّم إلى عدد صحيح، والتعبير في كتلة `else` يُقَيَّم إلى سلسلة نصية. هذا لن يعمل، لأن المتغيرات يجب أن يكون لها نوع واحد، وRust تحتاج إلى معرفة بشكل قاطع في وقت الترجمة ما هو نوع المتغير `number`. معرفة نوع `number` يسمح للمترجم بالتحقق من أن النوع صالح في كل مكان نستخدم فيه `number`. لن تكون Rust قادرة على القيام بذلك إذا كان نوع `number` يتحدد فقط في وقت التشغيل؛ سيكون المترجم أكثر تعقيداً وسيقدم ضمانات أقل حول الكود إذا كان عليه تتبع أنواع افتراضية متعددة لأي متغير.

### التكرار مع الحلقات

من المفيد في كثير من الأحيان تنفيذ كتلة كود أكثر من مرة. لهذه المهمة، توفر Rust عدة _حلقات_، والتي ستعمل من خلال الكود داخل جسم الحلقة حتى النهاية ثم تبدأ فوراً مرة أخرى من البداية. لتجربة الحلقات، دعنا ننشئ مشروعاً جديداً يسمى _loops_.

لدى Rust ثلاثة أنواع من الحلقات: `loop` و `while` و `for`. دعنا نجرب كل واحدة.

#### تكرار الكود مع `loop`

الكلمة المفتاحية `loop` تخبر Rust بتنفيذ كتلة كود مراراً وتكراراً إلى الأبد أو حتى تخبرها صراحة بالتوقف.

كمثال، غيّر ملف _src/main.rs_ في دليل _loops_ الخاص بك ليبدو كالتالي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-loop/src/main.rs}}
```

عندما نشغل هذا البرنامج، سنرى `again!` تُطبع مراراً وتكراراً بشكل مستمر حتى نوقف البرنامج يدوياً. تقدم معظم الترمنلات اختصار لوحة المفاتيح <kbd>ctrl</kbd>-<kbd>c</kbd> لمقاطعة برنامج عالق في حلقة مستمرة. جربه:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->

```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```

الرمز `^C` يمثل المكان الذي ضغطت فيه <kbd>ctrl</kbd>-<kbd>c</kbd>. قد ترى أو لا ترى الكلمة `again!` مطبوعة بعد `^C`، اعتماداً على مكان وجود الكود في الحلقة عندما استقبل إشارة المقاطعة.

لحسن الحظ، توفر Rust أيضاً طريقة للخروج من حلقة باستخدام الكود. يمكنك وضع الكلمة المفتاحية `break` داخل الحلقة لإخبار البرنامج متى يتوقف عن تنفيذ الحلقة. تذكر أننا فعلنا ذلك في لعبة التخمين في قسم ["الخروج بعد تخمين صحيح"][quitting-after-a-correct-guess]<!-- ignore --> من الفصل 2 للخروج من البرنامج عندما فاز المستخدم باللعبة بتخمين الرقم الصحيح.

استخدمنا أيضاً `continue` في لعبة التخمين، والتي في حلقة تخبر البرنامج بتخطي أي كود متبقي في هذا التكرار من الحلقة والذهاب إلى التكرار التالي.

#### إرجاع القيم من الحلقات

أحد استخدامات `loop` هو إعادة محاولة عملية تعرف أنها قد تفشل، مثل التحقق مما إذا كان خيط قد أكمل مهمته. قد تحتاج أيضاً إلى تمرير نتيجة تلك العملية من الحلقة إلى بقية كودك. للقيام بذلك، يمكنك إضافة القيمة التي تريد إرجاعها بعد تعبير `break` الذي تستخدمه لإيقاف الحلقة؛ ستُرجع تلك القيمة من الحلقة بحيث يمكنك استخدامها، كما هو موضح هنا:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-33-return-value-from-loop/src/main.rs}}
```

قبل الحلقة، نعلن عن متغير يسمى `counter` ونهيئه إلى `0`. ثم، نعلن عن متغير يسمى `result` لحمل القيمة المُرجَعة من الحلقة. في كل تكرار من الحلقة، نضيف `1` إلى المتغير `counter`، ثم نتحقق مما إذا كان `counter` يساوي `10`. عندما يكون كذلك، نستخدم الكلمة المفتاحية `break` مع القيمة `counter * 2`. بعد الحلقة، نستخدم فاصلة منقوطة لإنهاء الجملة التي تُسند القيمة إلى `result`. أخيراً، نطبع القيمة في `result`، والتي في هذه الحالة هي `20`.

يمكنك أيضاً استخدام `return` من داخل حلقة. بينما `break` فقط يخرج من الحلقة الحالية، `return` دائماً يخرج من الدالة الحالية.

<!-- Old headings. Do not remove or links may break. -->
<a id="loop-labels-to-disambiguate-between-multiple-loops"></a>

#### التمييز مع تسميات الحلقات

إذا كان لديك حلقات داخل حلقات، فإن `break` و `continue` تنطبق على أعمق حلقة عند تلك النقطة. يمكنك اختيارياً تحديد _تسمية حلقة_ على حلقة يمكنك بعد ذلك استخدامها مع `break` أو `continue` لتحديد أن تلك الكلمات المفتاحية تنطبق على الحلقة المُسَمَّاة بدلاً من أعمق حلقة. يجب أن تبدأ تسميات الحلقات بعلامة اقتباس واحدة. إليك مثالاً بحلقتين متداخلتين:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/src/main.rs}}
```

الحلقة الخارجية لها التسمية `'counting_up`، وستعد من 0 إلى 2. الحلقة الداخلية بدون تسمية تعد من 10 إلى 9. أول `break` الذي لا يحدد تسمية سيخرج من الحلقة الداخلية فقط. جملة `break 'counting_up;` ستخرج من الحلقة الخارجية. يطبع هذا الكود:

```console
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/output.txt}}
```

<!-- Old headings. Do not remove or links may break. -->
<a id="conditional-loops-with-while"></a>

#### تبسيط الحلقات الشرطية مع while

غالباً ما يحتاج البرنامج إلى تقييم شرط داخل حلقة. بينما يكون الشرط `true`، تعمل الحلقة. عندما يتوقف الشرط عن أن يكون `true`، يستدعي البرنامج `break`، موقفاً الحلقة. من الممكن تنفيذ سلوك مثل هذا باستخدام مزيج من `loop` و `if` و `else` و `break`؛ يمكنك تجربة ذلك الآن في برنامج، إذا أردت. ومع ذلك، هذا النمط شائع جداً لدرجة أن Rust لديها بنية لغوية مدمجة له، تسمى حلقة `while`. في القائمة 3-3، نستخدم `while` لجعل البرنامج يحلق ثلاث مرات، يعد للأسفل في كل مرة، ثم، بعد الحلقة، يطبع رسالة ويخرج.

<Listing number="3-3" file-name="src/main.rs" caption="استخدام حلقة `while` لتشغيل الكود بينما يُقَيَّم شرط إلى `true`">

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-03/src/main.rs}}
```

</Listing>

هذه البنية تلغي الكثير من التداخل الذي سيكون ضرورياً إذا استخدمت `loop` و `if` و `else` و `break`، وهي أوضح. بينما يُقَيَّم شرط إلى `true`، يعمل الكود؛ وإلا، يخرج من الحلقة.

#### الحلقة عبر مجموعة مع `for`

يمكنك اختيار استخدام بنية `while` للحلقة عبر عناصر مجموعة، مثل مصفوفة. على سبيل المثال، الحلقة في القائمة 3-4 تطبع كل عنصر في المصفوفة `a`.

<Listing number="3-4" file-name="src/main.rs" caption="الحلقة عبر كل عنصر من مجموعة باستخدام حلقة `while`">

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-04/src/main.rs}}
```

</Listing>

هنا، يعد الكود عبر العناصر في المصفوفة. يبدأ عند الفهرس `0` ثم يحلق حتى يصل إلى الفهرس النهائي في المصفوفة (أي عندما لا يكون `index < 5` صحيحاً). تشغيل هذا الكود سيطبع كل عنصر في المصفوفة:

```console
{{#include ../listings/ch03-common-programming-concepts/listing-03-04/output.txt}}
```

جميع قيم المصفوفة الخمس تظهر في الترمنل، كما هو متوقع. على الرغم من أن `index` سيصل إلى قيمة `5` في مرحلة ما، تتوقف الحلقة عن التنفيذ قبل محاولة جلب قيمة سادسة من المصفوفة.

ومع ذلك، هذا النهج عرضة للخطأ؛ يمكن أن نتسبب في توقف البرنامج بشكل مفاجئ إذا كانت قيمة الفهرس أو شرط الاختبار غير صحيح. على سبيل المثال، إذا غيّرت تعريف المصفوفة `a` لتحتوي على أربعة عناصر لكن نسيت تحديث الشرط إلى `while index < 4`، سيتوقف الكود بشكل مفاجئ. إنه أيضاً بطيء، لأن المترجم يضيف كود وقت تشغيل لأداء الفحص الشرطي لما إذا كان الفهرس ضمن حدود المصفوفة في كل تكرار من الحلقة.

كبديل أكثر إيجازاً، يمكنك استخدام حلقة `for` وتنفيذ بعض الكود لكل عنصر في مجموعة. تبدو حلقة `for` مثل الكود في القائمة 3-5.

<Listing number="3-5" file-name="src/main.rs" caption="الحلقة عبر كل عنصر من مجموعة باستخدام حلقة `for`">

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-05/src/main.rs}}
```

</Listing>

عندما نشغل هذا الكود، سنرى نفس الإخراج كما في القائمة 3-4. الأهم من ذلك، لقد زدنا الآن من سلامة الكود وقضينا على فرصة الأخطاء التي قد تنتج عن تجاوز نهاية المصفوفة أو عدم الذهاب بعيداً بما فيه الكفاية وتفويت بعض العناصر. كود الآلة المولد من حلقات `for` يمكن أن يكون أكثر كفاءة أيضاً لأن الفهرس لا يحتاج إلى مقارنته بطول المصفوفة في كل تكرار.

باستخدام حلقة `for`، لن تحتاج إلى تذكر تغيير أي كود آخر إذا غيّرت عدد القيم في المصفوفة، كما كنت ستفعل مع الطريقة المستخدمة في القائمة 3-4.

سلامة وإيجاز حلقات `for` تجعلها البنية الحلقية الأكثر استخداماً في Rust. حتى في الحالات التي تريد فيها تشغيل بعض الكود عدداً معيناً من المرات، كما في مثال العد التنازلي الذي استخدم حلقة `while` في القائمة 3-3، معظم مبرمجي Rust سيستخدمون حلقة `for`. الطريقة للقيام بذلك ستكون باستخدام `Range`، المقدم من المكتبة القياسية، والذي يولد جميع الأرقام بالتسلسل بدءاً من رقم واحد وانتهاءً قبل رقم آخر.

إليك كيف سيبدو العد التنازلي باستخدام حلقة `for` وطريقة أخرى لم نتحدث عنها بعد، `rev`، لعكس النطاق:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-34-for-range/src/main.rs}}
```

هذا الكود أجمل قليلاً، أليس كذلك؟

## ملخص

لقد نجحت! كان هذا فصلاً كبيراً: تعلمت عن المتغيرات، أنواع البيانات القياسية والمركبة، الدوال، التعليقات، تعبيرات `if`، والحلقات! لممارسة المفاهيم التي نوقشت في هذا الفصل، جرب بناء برامج للقيام بما يلي:

- تحويل درجات الحرارة بين فهرنهايت وسلزيوس.
- توليد رقم فيبوناتشي الـ *n*.
- طباعة كلمات أغنية عيد الميلاد "الأيام الاثنا عشر لعيد الميلاد"، مستفيداً من التكرار في الأغنية.

عندما تكون مستعداً للمضي قدماً، سنتحدث عن مفهوم في Rust _لا_ يوجد عادة في لغات البرمجة الأخرى: الملكية.

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[quitting-after-a-correct-guess]: ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess
