# أساسيات البرمجة غير المتزامنة (Asynchronous Programming): Async و Await والمستقبلات والتدفقات

العديد من العمليات التي نطلب من الكمبيوتر القيام بها يمكن أن تستغرق وقتًا طويلاً لإنهائها. سيكون من الجيد لو تمكنا من القيام بشيء آخر أثناء انتظار هذه العمليات طويلة الأمد لتكتمل. توفر أجهزة الكمبيوتر الحديثة تقنيتين للعمل على أكثر من عملية في نفس الوقت: التوازي (parallelism) والتزامن (concurrency). ومع ذلك، يتم كتابة منطق برامجنا بطريقة خطية في الغالب. نود أن نكون قادرين على تحديد العمليات التي يجب على البرنامج تنفيذها والنقاط التي يمكن فيها لدالة أن تتوقف مؤقتًا وتشغيل جزء آخر من البرنامج بدلاً من ذلك، دون الحاجة إلى تحديد الترتيب والطريقة التي يجب أن تعمل بها كل جزء من الكود بشكل مسبق. _البرمجة غير المتزامنة_ (Asynchronous programming) هي تجريد يتيح لنا التعبير عن الكود الخاص بنا من حيث نقاط التوقف المحتملة والنتائج النهائية التي تهتم بتفاصيل التنسيق نيابة عنا.

يعتمد هذا الفصل على استخدام الفصل 16 للخيوط (threads) للتوازي والتزامن من خلال تقديم نهج بديل لكتابة الكود: مستقبلات Rust (futures) والتدفقات (streams) وصيغة `async` و `await` التي تتيح لنا التعبير عن كيفية أن تكون العمليات غير متزامنة، والمكتبات الخارجية (crates) التي تنفذ بيئات التشغيل غير المتزامنة (asynchronous runtimes): الكود الذي يدير وينسق تنفيذ العمليات غير المتزامنة.

لنفكر في مثال. لنفترض أنك تقوم بتصدير فيديو قمت بإنشائه لاحتفال عائلي، عملية يمكن أن تستغرق من دقائق إلى ساعات. سيستخدم تصدير الفيديو أكبر قدر ممكن من قوة المعالج (CPU) ومعالج الرسومات (GPU). إذا كان لديك نواة معالج واحدة فقط ولم يقم نظام التشغيل الخاص بك بإيقاف عملية التصدير مؤقتًا حتى تكتمل - أي إذا قام بتنفيذ التصدير _بشكل متزامن_ (synchronously) - فلن تتمكن من القيام بأي شيء آخر على جهاز الكمبيوتر الخاص بك أثناء تشغيل هذه المهمة. سيكون ذلك تجربة محبطة للغاية. لحسن الحظ، يمكن لنظام تشغيل جهاز الكمبيوتر الخاص بك، ويفعل ذلك، مقاطعة التصدير بشكل غير مرئي بشكل متكرر بما يكفي للسماح لك بإنجاز أعمال أخرى في وقت واحد.

الآن لنفترض أنك تقوم بتنزيل فيديو شاركه شخص آخر، والذي يمكن أن يستغرق أيضًا بعض الوقت ولكنه لا يستهلك الكثير من وقت المعالج. في هذه الحالة، يجب على المعالج الانتظار حتى تصل البيانات من الشبكة. بينما يمكنك البدء في قراءة البيانات بمجرد أن تبدأ في الوصول، قد يستغرق الأمر بعض الوقت حتى يصل كل شيء. حتى بمجرد وصول جميع البيانات، إذا كان الفيديو كبيرًا جدًا، فقد يستغرق تحميله بالكامل ثانية أو ثانيتين على الأقل. قد لا يبدو ذلك كثيرًا، ولكنه وقت طويل جدًا بالنسبة لمعالج حديث، والذي يمكنه تنفيذ مليارات العمليات كل ثانية. مرة أخرى، سيقوم نظام التشغيل بمقاطعة برنامجك بشكل غير مرئي للسماح للمعالج بأداء أعمال أخرى أثناء انتظار اكتمال استدعاء الشبكة.

تصدير الفيديو هو مثال على عملية _مرتبطة بالمعالج_ (CPU-bound) أو _مرتبطة بالحساب_ (compute-bound). إنها محدودة بسرعة معالجة البيانات المحتملة للكمبيوتر داخل المعالج أو معالج الرسومات، ومقدار تلك السرعة التي يمكن تخصيصها للعملية. تنزيل الفيديو هو مثال على عملية _مرتبطة بالإدخال/الإخراج_ (I/O-bound)، لأنها محدودة بسرعة _إدخال وإخراج_ الكمبيوتر؛ يمكن أن تسير بسرعة إرسال البيانات عبر الشبكة فقط.

في كلا المثالين، توفر المقاطعات غير المرئية لنظام التشغيل شكلاً من أشكال التزامن. ومع ذلك، يحدث هذا التزامن فقط على مستوى البرنامج بالكامل: يقاطع نظام التشغيل برنامجًا واحدًا للسماح لبرامج أخرى بإنجاز العمل. في كثير من الحالات، نظرًا لأننا نفهم برامجنا على مستوى أكثر تفصيلاً مما يفعله نظام التشغيل، يمكننا اكتشاف فرص للتزامن لا يستطيع نظام التشغيل رؤيتها.

على سبيل المثال، إذا كنا نقوم ببناء أداة لإدارة تنزيلات الملفات، فيجب أن نكون قادرين على كتابة برنامجنا بحيث لا يؤدي بدء تنزيل واحد إلى تجميد واجهة المستخدم، ويجب أن يكون المستخدمون قادرين على بدء تنزيلات متعددة في نفس الوقت. العديد من واجهات برمجة التطبيقات (APIs) لنظام التشغيل للتفاعل مع الشبكة هي _حجب_ (blocking)؛ أي أنها تحجب تقدم البرنامج حتى تصبح البيانات التي تتم معالجتها جاهزة تمامًا.

> ملاحظة: هذه هي الطريقة التي تعمل بها _معظم_ استدعاءات الدوال، إذا فكرت في الأمر. ومع ذلك، عادةً ما يتم حجز مصطلح _blocking_ لاستدعاءات الدوال التي تتفاعل مع الملفات أو الشبكة أو الموارد الأخرى على الكمبيوتر، لأن هذه هي الحالات التي يستفيد فيها البرنامج الفردي من كون العملية _غير حاجبة_ (non-blocking).

يمكننا تجنب حجب الخيط الرئيسي عن طريق إنشاء خيط مخصص لتنزيل كل ملف. ومع ذلك، فإن النفقات العامة لموارد النظام المستخدمة من قبل تلك الخيوط ستصبح في النهاية مشكلة. سيكون من الأفضل لو لم يقم الاستدعاء بالحجب في المقام الأول، وبدلاً من ذلك يمكننا تحديد عدد من المهام (tasks) التي نرغب في إكمالها في برنامجنا والسماح لبيئة التشغيل باختيار أفضل ترتيب وطريقة لتشغيلها.

هذا بالضبط ما يمنحنا إياه تجريد _async_ في Rust (اختصار لـ _asynchronous_). في هذا الفصل، ستتعلم كل شيء عن async بينما نغطي المواضيع التالية:

- كيفية استخدام صيغة `async` و `await` في Rust وتنفيذ الدوال غير المتزامنة باستخدام بيئة تشغيل
- كيفية استخدام نموذج async لحل بعض التحديات نفسها التي نظرنا إليها في الفصل 16
- كيف يوفر تعدد الخيوط (multithreading) و async حلولاً تكميلية يمكنك دمجها في كثير من الحالات

ولكن قبل أن نرى كيف يعمل async عمليًا، نحتاج إلى التحدث قليلاً عن الاختلافات بين التوازي والتزامن.

## التوازي (Parallelism) والتزامن (Concurrency)

لقد تعاملنا مع التوازي (parallelism) والتزامن (concurrency) على أنهما متبادلان إلى حد كبير حتى الآن. الآن نحتاج إلى التمييز بينهما بشكل أكثر دقة، لأن الاختلافات ستظهر عندما نبدأ العمل.

لنفكر في الطرق المختلفة التي يمكن لفريق تقسيم العمل فيها على مشروع برمجي. يمكنك تعيين عدة مهام لعضو واحد، أو تعيين مهمة واحدة لكل عضو، أو استخدام مزيج من النهجين.

عندما يعمل فرد واحد على عدة مهام مختلفة قبل اكتمال أي منها، فهذا هو _التزامن_ (concurrency). إحدى الطرق لتنفيذ التزامن تشبه وجود مشروعين مختلفين على جهاز الكمبيوتر الخاص بك، وعندما تشعر بالملل أو تعلق في مشروع واحد، تنتقل إلى الآخر. أنت مجرد شخص واحد، لذلك لا يمكنك إحراز تقدم في كلتا المهمتين في نفس الوقت بالضبط، ولكن يمكنك تعدد المهام، وإحراز تقدم في واحدة في كل مرة عن طريق التبديل بينهما (انظر الشكل 17-1).

<figure>

<img src="img/trpl17-01.svg" class="center" alt="رسم تخطيطي يحتوي على صناديق مكدسة تحمل علامات المهمة A والمهمة B، مع الماس فيها يمثل مهام فرعية. تشير الأسهم من A1 إلى B1، وB1 إلى A2، وA2 إلى B2، وB2 إلى A3، وA3 إلى A4، وA4 إلى B3. تعبر الأسهم بين المهام الفرعية الصناديق بين المهمة A والمهمة B." />

<figcaption>الشكل 17-1: سير عمل متزامن، التبديل بين المهمة A والمهمة B</figcaption>

</figure>

عندما يقسم الفريق مجموعة من المهام من خلال قيام كل عضو بمهمة واحدة والعمل عليها بمفرده، فهذا هو _التوازي_ (parallelism). يمكن لكل شخص في الفريق إحراز تقدم في نفس الوقت بالضبط (انظر الشكل 17-2).

<figure>

<img src="img/trpl17-02.svg" class="center" alt="رسم تخطيطي يحتوي على صناديق مكدسة تحمل علامات المهمة A والمهمة B، مع الماس فيها يمثل مهام فرعية. تشير الأسهم من A1 إلى A2، وA2 إلى A3، وA3 إلى A4، وB1 إلى B2، وB2 إلى B3. لا توجد أسهم تعبر بين الصناديق للمهمة A والمهمة B." />

<figcaption>الشكل 17-2: سير عمل متوازي، حيث يحدث العمل على المهمة A والمهمة B بشكل مستقل</figcaption>

</figure>

في كلا سير العمل هذين، قد تحتاج إلى التنسيق بين المهام المختلفة. ربما كنت تعتقد أن المهمة المعينة لشخص واحد كانت مستقلة تمامًا عن عمل الآخرين، ولكنها في الواقع تتطلب من شخص آخر في الفريق إنهاء مهمته أولاً. يمكن إنجاز بعض الأعمال بالتوازي، لكن بعضها كان في الواقع _تسلسليًا_ (serial): يمكن أن يحدث فقط في سلسلة، مهمة تلو الأخرى، كما في الشكل 17-3.

<figure>

<img src="img/trpl17-03.svg" class="center" alt="رسم تخطيطي يحتوي على صناديق مكدسة تحمل علامات المهمة A والمهمة B، مع الماس فيها يمثل مهام فرعية. في المهمة A، تشير الأسهم من A1 إلى A2، ومن A2 إلى زوج من الخطوط العمودية السميكة مثل رمز "إيقاف مؤقت"، ومن ذلك الرمز إلى A3. في المهمة B، تشير الأسهم من B1 إلى B2، ومن B2 إلى B3، ومن B3 إلى A3، ومن B3 إلى B4." />

<figcaption>الشكل 17-3: سير عمل متوازي جزئيًا، حيث يحدث العمل على المهمة A والمهمة B بشكل مستقل حتى يتم حظر المهمة A3 على نتائج المهمة B3.</figcaption>

</figure>

وبالمثل، قد تدرك أن إحدى مهامك الخاصة تعتمد على مهمة أخرى من مهامك. الآن أصبح عملك المتزامن تسلسليًا أيضًا.

يمكن أن يتقاطع التوازي والتزامن مع بعضهما البعض أيضًا. إذا علمت أن زميلاً عالق حتى تنتهي من إحدى مهامك، فستركز على الأرجح كل جهودك على تلك المهمة لـ "إلغاء حظر" زميلك. لم تعد أنت وزميلك قادرين على العمل بالتوازي، كما أنك لم تعد قادرًا على العمل بشكل متزامن على مهامك الخاصة.

تنطبق نفس الديناميكيات الأساسية على البرامج والأجهزة. على جهاز بنواة معالج واحدة، يمكن للمعالج القيام بعملية واحدة فقط في كل مرة، ولكن لا يزال بإمكانه العمل بشكل متزامن. باستخدام أدوات مثل الخيوط والعمليات و async، يمكن للكمبيوتر إيقاف نشاط واحد مؤقتًا والتبديل إلى أنشطة أخرى قبل العودة في النهاية إلى النشاط الأول مرة أخرى. على جهاز بنوى معالج متعددة، يمكنه أيضًا القيام بالعمل بالتوازي. يمكن لنواة واحدة أداء مهمة واحدة بينما تؤدي نواة أخرى مهمة غير ذات صلة تمامًا، وتحدث هذه العمليات فعليًا في نفس الوقت.

عادةً ما يحدث تشغيل كود async في Rust بشكل متزامن. اعتمادًا على الأجهزة ونظام التشغيل وبيئة التشغيل غير المتزامنة التي نستخدمها (المزيد عن بيئات التشغيل غير المتزامنة قريبًا)، قد يستخدم هذا التزامن أيضًا التوازي تحت الغطاء.

الآن، لننتقل إلى كيفية عمل البرمجة غير المتزامنة في Rust فعليًا.
