## الملحق (Appendix) ز - كيف يتم تطوير Rust و"Nightly Rust"

يتناول هذا الملحق كيفية تطوير Rust وكيف يؤثر ذلك عليك كمطور Rust.

### الاستقرار دون الركود

كلغة برمجة، تهتم Rust _كثيراً_ باستقرار الكود الخاص بك. نريد أن تكون Rust
أساساً متيناً يمكنك البناء عليه، وإذا كانت الأشياء تتغير باستمرار، فسيكون
ذلك مستحيلاً. في الوقت نفسه، إذا لم نتمكن من تجربة ميزات جديدة، فقد لا
نكتشف العيوب المهمة إلا بعد إصدارها، عندما لا يمكننا تغيير الأشياء بعد الآن.

حلنا لهذه المشكلة هو ما نسميه "الاستقرار دون الركود"، ومبدأنا التوجيهي هو:
يجب ألا تخشى أبداً الترقية إلى نسخة جديدة من Rust المستقرة. يجب أن تكون كل
ترقية سهلة، ولكن يجب أيضاً أن تجلب لك ميزات جديدة، وأخطاء أقل، وأوقات
ترجمة أسرع.

### تشو، تشو! قنوات الإصدار وركوب القطارات

يعمل تطوير Rust على _جدول القطارات_. أي أن كل التطوير يتم في الفرع الرئيسي
من مستودع Rust. تتبع الإصدارات نموذج قطار إصدار البرمجيات، والذي تم
استخدامه بواسطة Cisco IOS ومشاريع برمجيات أخرى. هناك ثلاث _قنوات إصدار_
لـ Rust:

- Nightly
- Beta
- Stable

يستخدم معظم مطوري Rust بشكل أساسي القناة المستقرة، ولكن أولئك الذين يرغبون
في تجربة ميزات تجريبية جديدة قد يستخدمون nightly أو beta.

إليك مثالاً على كيفية عمل عملية التطوير والإصدار: لنفترض أن فريق Rust يعمل
على إصدار Rust 1.5. حدث هذا الإصدار في ديسمبر 2015، لكنه سيوفر لنا أرقام
إصدارات واقعية. تتم إضافة ميزة جديدة إلى Rust: يتم وضع commit جديد على
الفرع الرئيسي. كل ليلة، يتم إنتاج نسخة nightly جديدة من Rust. كل يوم هو
يوم إصدار، ويتم إنشاء هذه الإصدارات بواسطة بنيتنا التحتية للإصدار تلقائياً.
لذا مع مرور الوقت، تبدو إصداراتنا هكذا، مرة واحدة في الليلة:

```text
nightly: * - - * - - *
```

كل ستة أسابيع، حان الوقت لإعداد إصدار جديد! يتفرع فرع `beta` من مستودع
Rust من الفرع الرئيسي المستخدم بواسطة nightly. الآن، هناك إصداران:

```text
nightly: * - - * - - *
                     |
beta:                *
```

لا يستخدم معظم مستخدمي Rust إصدارات beta بشكل نشط، ولكنهم يختبرون ضد beta
في نظام CI الخاص بهم لمساعدة Rust في اكتشاف التراجعات المحتملة. في هذه
الأثناء، لا يزال هناك إصدار nightly كل ليلة:

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

لنفترض أنه تم العثور على تراجع. من الجيد أن لدينا بعض الوقت لاختبار إصدار
beta قبل أن يتسلل التراجع إلى إصدار مستقر! يتم تطبيق الإصلاح على الفرع
الرئيسي، بحيث يتم إصلاح nightly، ثم يتم نقل الإصلاح إلى فرع `beta`، ويتم
إنتاج إصدار جديد من beta:

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

بعد ستة أسابيع من إنشاء أول beta، حان الوقت لإصدار مستقر! يتم إنتاج فرع
`stable` من فرع `beta`:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

مبروك! تم الانتهاء من Rust 1.5! ومع ذلك، نسينا شيئاً واحداً: لأن الأسابيع
الستة قد مرت، نحتاج أيضاً إلى beta جديد من الإصدار _التالي_ من Rust، 1.6.
لذا بعد أن يتفرع `stable` من `beta`، يتفرع الإصدار التالي من `beta` من
`nightly` مرة أخرى:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

يُسمى هذا "نموذج القطار" لأنه كل ستة أسابيع، يتم "مغادرة المحطة" بإصدار،
ولكن لا يزال يتعين عليه القيام برحلة عبر قناة beta قبل أن يصل كإصدار مستقر.

يصدر Rust كل ستة أسابيع، كالساعة. إذا كنت تعرف تاريخ إصدار Rust واحد،
يمكنك معرفة تاريخ الإصدار التالي: إنه بعد ستة أسابيع. الجانب الجميل من
وجود إصدارات مجدولة كل ستة أسابيع هو أن القطار التالي قادم قريباً. إذا حدث
أن فاتت ميزة إصداراً معيناً، فلا داعي للقلق: سيحدث إصدار آخر في وقت قصير!
هذا يساعد على تقليل الضغط لإدخال ميزات ربما غير مصقولة بالقرب من الموعد
النهائي للإصدار.

بفضل هذه العملية، يمكنك دائماً الحصول على الإصدار التالي من Rust والتحقق
بنفسك من سهولة الترقية إليه: إذا لم يعمل إصدار beta كما هو متوقع، يمكنك
الإبلاغ عنه للفريق وإصلاحه قبل حدوث الإصدار المستقر التالي! الكسر في إصدار
beta نادر نسبياً، لكن `rustc` لا يزال جزءاً من البرمجيات، والأخطاء موجودة.

### وقت الصيانة

يدعم مشروع Rust أحدث نسخة مستقرة فقط. عندما يتم إصدار نسخة مستقرة جديدة،
تصل النسخة القديمة إلى نهاية عمرها (EOL). هذا يعني أن كل نسخة مدعومة لمدة
ستة أسابيع.

### الميزات غير المستقرة

هناك مشكلة واحدة أخرى مع نموذج الإصدار هذا: الميزات غير المستقرة. تستخدم
Rust تقنية تسمى "أعلام الميزات" لتحديد الميزات الممكّنة في إصدار معين. إذا
كانت ميزة جديدة قيد التطوير النشط، فإنها تصل إلى الفرع الرئيسي، وبالتالي،
في nightly، ولكن خلف _علم ميزة_. إذا كنت، كمستخدم، ترغب في تجربة الميزة
قيد العمل، يمكنك ذلك، ولكن يجب أن تستخدم إصدار nightly من Rust وتضع
تعليقاً توضيحياً على الكود المصدري الخاص بك بالعلم المناسب للمشاركة.

إذا كنت تستخدم إصدار beta أو stable من Rust، فلا يمكنك استخدام أي أعلام
ميزات. هذا هو المفتاح الذي يسمح لنا بالحصول على استخدام عملي للميزات
الجديدة قبل أن نعلنها مستقرة إلى الأبد. أولئك الذين يرغبون في الاشتراك في
الطليعة يمكنهم القيام بذلك، وأولئك الذين يريدون تجربة صلبة كالصخر يمكنهم
الالتزام بـ stable ومعرفة أن الكود الخاص بهم لن ينكسر. الاستقرار دون الركود.

يحتوي هذا الكتاب فقط على معلومات حول الميزات المستقرة، حيث أن الميزات قيد
العمل لا تزال تتغير، ومن المؤكد أنها ستكون مختلفة بين وقت كتابة هذا الكتاب
ووقت تمكينها في الإصدارات المستقرة. يمكنك العثور على وثائق للميزات
الخاصة بـ nightly فقط عبر الإنترنت.

### Rustup ودور Rust Nightly

يجعل Rustup من السهل التغيير بين قنوات الإصدار المختلفة لـ Rust، على أساس
عالمي أو لكل مشروع. بشكل افتراضي، سيكون لديك Rust المستقرة مثبتة. لتثبيت
nightly، على سبيل المثال:

```console
$ rustup toolchain install nightly
```

يمكنك رؤية جميع _toolchains_ (إصدارات Rust والمكونات المرتبطة بها) التي
قمت بتثبيتها باستخدام `rustup` أيضاً. إليك مثالاً على جهاز كمبيوتر Windows
لأحد المؤلفين:

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

كما ترى، toolchain المستقر هو الافتراضي. يستخدم معظم مستخدمي Rust stable
معظم الوقت. قد ترغب في استخدام stable معظم الوقت، ولكن استخدام nightly على
مشروع معين، لأنك تهتم بميزة طليعية. للقيام بذلك، يمكنك استخدام
`rustup override` في دليل هذا المشروع لتعيين toolchain nightly كالذي يجب
على `rustup` استخدامه عندما تكون في هذا الدليل:

```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

الآن، في كل مرة تستدعي فيها `rustc` أو `cargo` داخل _~/projects/needs-nightly_،
سيتأكد `rustup` من أنك تستخدم nightly Rust، بدلاً من الافتراضي stable
Rust. هذا مفيد عندما يكون لديك الكثير من مشاريع Rust!

### عملية RFC والفرق

إذن كيف تتعلم عن هذه الميزات الجديدة؟ يتبع نموذج تطوير Rust _عملية طلب
التعليقات (RFC)_. إذا كنت ترغب في تحسين في Rust، يمكنك كتابة مقترح، يسمى
RFC.

يمكن لأي شخص كتابة RFCs لتحسين Rust، وتتم مراجعة المقترحات ومناقشتها
بواسطة فريق Rust، والذي يتألف من العديد من الفرق الفرعية للموضوعات. هناك
قائمة كاملة بالفرق [على موقع Rust الإلكتروني](https://www.rust-lang.org/governance)، والتي تتضمن فرقاً لكل
مجال من المشروع: تصميم اللغة، تنفيذ المصرِّف، البنية التحتية، التوثيق،
والمزيد. يقرأ الفريق المناسب المقترح والتعليقات، ويكتب بعض التعليقات
الخاصة به، وفي النهاية، هناك إجماع على قبول أو رفض الميزة.

إذا تم قبول الميزة، يتم فتح issue على مستودع Rust، ويمكن لشخص ما تنفيذها.
الشخص الذي ينفذها قد لا يكون بالضرورة الشخص الذي اقترح الميزة في المقام
الأول! عندما يكون التنفيذ جاهزاً، يصل إلى الفرع الرئيسي خلف feature gate،
كما ناقشنا في قسم ["الميزات غير المستقرة"](#unstable-features)<!-- ignore -->.

بعد بعض الوقت، بمجرد أن يتمكن مطورو Rust الذين يستخدمون إصدارات nightly
من تجربة الميزة الجديدة، سيناقش أعضاء الفريق الميزة، وكيف عملت على
nightly، ويقررون ما إذا كان يجب أن تصل إلى Rust المستقرة أم لا. إذا كان
القرار هو المضي قدماً، يتم إزالة feature gate، وتعتبر الميزة الآن مستقرة!
تركب القطارات إلى إصدار مستقر جديد من Rust.
