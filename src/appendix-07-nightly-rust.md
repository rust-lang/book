## ภาคผนวก G - Rust ถูกสร้างขึ้นมาอย่างไร และ “Nightly Rust”

ภาคผนวกนี้เกี่ยวกับวิธีการสร้าง Rust และผลกระทบต่อคุณในฐานะนักพัฒนา Rust

### เสถียรภาพโดยไม่หยุดนิ่ง

ในฐานะภาษา Rust ให้ความสำคัญกับความเสถียรของโค้ดของคุณเป็นอย่าง _มาก_ เราต้องการให้ Rust เป็นรากฐานที่มั่นคงที่คุณสามารถสร้างขึ้นได้ และหากสิ่งต่างๆ เปลี่ยนแปลงอยู่ตลอดเวลา นั่นคงเป็นไปไม่ได้ ในขณะเดียวกัน หากเราไม่สามารถทดลองกับฟีเจอร์ใหม่ๆ ได้ เราอาจไม่พบข้อบกพร่องที่สำคัญจนกว่าจะปล่อยออกมาแล้ว ซึ่งเมื่อถึงตอนนั้นเราก็ไม่สามารถเปลี่ยนแปลงอะไรได้อีก

วิธีแก้ปัญหาของเราสำหรับปัญหานี้คือสิ่งที่เราเรียกว่า “เสถียรภาพโดยไม่หยุดนิ่ง” (stability without stagnation) และหลักการชี้นำของเราคือ: คุณไม่ควรต้องกลัวที่จะอัปเกรดเป็น Rust เวอร์ชันเสถียรใหม่ การอัปเกรดแต่ละครั้งควรไม่ยุ่งยาก แต่ควรนำฟีเจอร์ใหม่ๆ ข้อบกพร่องที่น้อยลง และเวลาคอมไพล์ที่เร็วขึ้นมาให้คุณด้วย

### ชู่ว์ ชู่ว์! ช่องทางการเผยแพร่และการเดินทางของรถไฟ

การพัฒนา Rust ดำเนินการตาม _ตารางเวลารถไฟ_ นั่นคือ การพัฒนาทั้งหมดทำบน branch `master` ของ repository Rust การเผยแพร่เป็นไปตามโมเดลรถไฟการเผยแพร่ซอฟต์แวร์ ซึ่งใช้โดย Cisco IOS และโปรเจกต์ซอฟต์แวร์อื่นๆ มี _ช่องทางการเผยแพร่_ (release channels) สามช่องทางสำหรับ Rust:

- Nightly
- Beta
- Stable

นักพัฒนา Rust ส่วนใหญ่ใช้ช่องทาง stable เป็นหลัก แต่ผู้ที่ต้องการลองใช้ฟีเจอร์ใหม่ๆ ที่ยังทดลองอยู่ อาจใช้ nightly หรือ beta

นี่คือตัวอย่างของกระบวนการพัฒนาและเผยแพร่: สมมติว่าทีม Rust กำลังทำงานกับการเผยแพร่ Rust 1.5 การเผยแพร่นั้นเกิดขึ้นในเดือนธันวาคม 2015 แต่มันจะให้หมายเลขเวอร์ชันที่สมจริงแก่เรา มีการเพิ่มฟีเจอร์ใหม่เข้าไปใน Rust: commit ใหม่จะถูกรวมเข้ากับ branch `master` ในแต่ละคืน จะมีการผลิต Rust เวอร์ชัน nightly ใหม่ ทุกวันคือวันเผยแพร่ และการเผยแพร่เหล่านี้สร้างขึ้นโดยโครงสร้างพื้นฐานการเผยแพร่ของเราโดยอัตโนมัติ ดังนั้นเมื่อเวลาผ่านไป การเผยแพร่ของเราจะมีลักษณะดังนี้ คืนละครั้ง:

```text
nightly: * - - * - - *
```

ทุกๆ หกสัปดาห์ ก็ถึงเวลาเตรียมการเผยแพร่ใหม่! branch `beta` ของ repository Rust จะแตกแขนงออกจาก branch `master` ที่ nightly ใช้ ตอนนี้มีการเผยแพร่สองแบบ:

```text
nightly: * - - * - - *
                     |
beta:                *
```

ผู้ใช้ Rust ส่วนใหญ่ไม่ได้ใช้ beta releases อย่างจริงจัง แต่จะทดสอบกับ beta ในระบบ CI ของตนเพื่อช่วยให้ Rust ค้นพบ regressions ที่อาจเกิดขึ้น ในขณะเดียวกัน ก็ยังคงมีการเผยแพร่ nightly ทุกคืน:

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

สมมติว่าพบ regression เป็นเรื่องดีที่เรามีเวลาทดสอบ beta release ก่อนที่ regression จะแอบเข้าไปใน stable release! การแก้ไขจะถูกนำไปใช้กับ `master` เพื่อให้ nightly ได้รับการแก้ไข จากนั้นการแก้ไขจะถูก backport ไปยัง branch `beta` และมีการผลิต beta release ใหม่:

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

หกสัปดาห์หลังจากสร้าง beta แรก ก็ถึงเวลาสำหรับ stable release! branch `stable` ถูกสร้างขึ้นจาก branch `beta`:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

เย้! Rust 1.5 เสร็จแล้ว! อย่างไรก็ตาม เราลืมไปอย่างหนึ่ง: เนื่องจากหกสัปดาห์ผ่านไปแล้ว เราจึงต้องการ beta ใหม่ของ Rust เวอร์ชัน _ถัดไป_ คือ 1.6 ด้วย ดังนั้นหลังจากที่ `stable` แตกแขนงออกจาก `beta` แล้ว `beta` เวอร์ชันถัดไปก็จะแตกแขนงออกจาก `nightly` อีกครั้ง:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

นี่เรียกว่า “โมเดลรถไฟ” เพราะทุกๆ หกสัปดาห์ การเผยแพร่จะ “ออกจากสถานี” แต่ยังคงต้องเดินทางผ่านช่องทาง beta ก่อนที่จะมาถึงเป็น stable release

Rust เผยแพร่ทุกๆ หกสัปดาห์เหมือนเครื่องจักร หากคุณทราบวันที่เผยแพร่ Rust ครั้งหนึ่ง คุณก็จะทราบวันที่เผยแพร่ครั้งถัดไปได้: คือหกสัปดาห์ต่อมา ข้อดีของการมีกำหนดการเผยแพร่ทุกๆ หกสัปดาห์คือรถไฟขบวนถัดไปกำลังจะมาในไม่ช้า หากฟีเจอร์ใดพลาดการเผยแพร่ครั้งใดครั้งหนึ่งไป ก็ไม่จำเป็นต้องกังวล: จะมีการเผยแพร่อีกครั้งในไม่ช้า! สิ่งนี้ช่วยลดแรงกดดันในการแอบใส่ฟีเจอร์ที่อาจยังไม่สมบูรณ์เข้าไปใกล้กับกำหนดเวลาการเผยแพร่

ด้วยกระบวนการนี้ คุณสามารถตรวจสอบ Rust build ถัดไปได้เสมอและยืนยันด้วยตัวเองว่าการอัปเกรดนั้นง่ายดาย: หาก beta release ทำงานไม่เป็นไปตามที่คาดไว้ คุณสามารถรายงานไปยังทีมและแก้ไขได้ก่อนที่ stable release ถัดไปจะเกิดขึ้น! การแตกหักใน beta release นั้นค่อนข้างหายาก แต่ `rustc` ก็ยังคงเป็นซอฟต์แวร์ชิ้นหนึ่ง และข้อบกพร่องก็ยังคงมีอยู่

### เวลาในการบำรุงรักษา

โปรเจกต์ Rust รองรับเวอร์ชัน stable ล่าสุด เมื่อมีการเผยแพร่เวอร์ชัน stable ใหม่ เวอร์ชันเก่าจะสิ้นสุดอายุการใช้งาน (EOL) ซึ่งหมายความว่าแต่ละเวอร์ชันจะได้รับการสนับสนุนเป็นเวลาหกสัปดาห์

### ฟีเจอร์ที่ไม่เสถียร (Unstable Features)

ยังมีอีกหนึ่งประเด็นเกี่ยวกับโมเดลการเผยแพร่นี้: ฟีเจอร์ที่ไม่เสถียร Rust ใช้เทคนิคที่เรียกว่า “feature flags” เพื่อกำหนดว่าฟีเจอร์ใดบ้างที่เปิดใช้งานในการเผยแพร่ที่กำหนด หากฟีเจอร์ใหม่กำลังอยู่ระหว่างการพัฒนาอย่างจริงจัง มันจะถูกรวมเข้ากับ `master` และดังนั้นจึงอยู่ใน nightly แต่จะอยู่หลัง _feature flag_ หากคุณในฐานะผู้ใช้ต้องการลองใช้ฟีเจอร์ที่กำลังดำเนินการอยู่ คุณสามารถทำได้ แต่คุณต้องใช้ Rust เวอร์ชัน nightly และใส่คำอธิบายประกอบซอร์สโค้ดของคุณด้วย flag ที่เหมาะสมเพื่อเลือกใช้งาน

หากคุณใช้ Rust เวอร์ชัน beta หรือ stable คุณจะไม่สามารถใช้ feature flags ใดๆ ได้ นี่คือกุญแจสำคัญที่ช่วยให้เราสามารถใช้งานจริงกับฟีเจอร์ใหม่ๆ ได้ก่อนที่เราจะประกาศว่ามันเสถียรตลอดไป ผู้ที่ต้องการเลือกใช้เทคโนโลยีล้ำสมัยสามารถทำได้ และผู้ที่ต้องการประสบการณ์ที่มั่นคงสามารถใช้ stable ต่อไปได้และรู้ว่าโค้ดของตนจะไม่เสียหาย เสถียรภาพโดยไม่หยุดนิ่ง

หนังสือเล่มนี้มีเฉพาะข้อมูลเกี่ยวกับฟีเจอร์ที่เสถียรเท่านั้น เนื่องจากฟีเจอร์ที่กำลังดำเนินการยังคงมีการเปลี่ยนแปลง และแน่นอนว่ามันจะแตกต่างกันระหว่างช่วงเวลาที่เขียนหนังสือเล่มนี้กับเมื่อมันถูกเปิดใช้งานใน stable builds คุณสามารถค้นหาเอกสารประกอบสำหรับฟีเจอร์เฉพาะ nightly ได้ทางออนไลน์

### Rustup และบทบาทของ Rust Nightly

Rustup ทำให้ง่ายต่อการสลับระหว่างช่องทางการเผยแพร่ต่างๆ ของ Rust ทั้งแบบโกลบอลหรือแบบต่อโปรเจกต์ โดยค่าเริ่มต้น คุณจะติดตั้ง Rust เวอร์ชัน stable หากต้องการติดตั้ง nightly ตัวอย่างเช่น:

```console
$ rustup toolchain install nightly
```

คุณยังสามารถดู _toolchains_ ทั้งหมด (Rust releases และส่วนประกอบที่เกี่ยวข้อง) ที่คุณติดตั้งไว้ด้วย `rustup` ได้อีกด้วย นี่คือตัวอย่างบนคอมพิวเตอร์ Windows ของผู้เขียนคนหนึ่งของคุณ:

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

ดังที่คุณเห็น toolchain stable เป็นค่าเริ่มต้น ผู้ใช้ Rust ส่วนใหญ่ใช้ stable เกือบตลอดเวลา คุณอาจต้องการใช้ stable เกือบตลอดเวลา แต่ใช้ nightly กับโปรเจกต์เฉพาะ เนื่องจากคุณสนใจฟีเจอร์ล้ำสมัย ในการทำเช่นนั้น คุณสามารถใช้ `rustup override` ในไดเรกทอรีของโปรเจกต์นั้นเพื่อตั้งค่า toolchain nightly ให้เป็น toolchain ที่ `rustup` ควรใช้เมื่อคุณอยู่ในไดเรกทอรีนั้น:

```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

ตอนนี้ ทุกครั้งที่คุณเรียก `rustc` หรือ `cargo` ภายใน _~/projects/needs-nightly_ `rustup` จะตรวจสอบให้แน่ใจว่าคุณกำลังใช้ nightly Rust แทนที่จะเป็น stable Rust ที่เป็นค่าเริ่มต้นของคุณ สิ่งนี้มีประโยชน์เมื่อคุณมีโปรเจกต์ Rust จำนวนมาก!

### กระบวนการ RFC และทีมงาน

แล้วคุณจะเรียนรู้เกี่ยวกับฟีเจอร์ใหม่เหล่านี้ได้อย่างไร? โมเดลการพัฒนาของ Rust เป็นไปตาม _กระบวนการ Request For Comments (RFC)_ หากคุณต้องการการปรับปรุงใน Rust คุณสามารถเขียนข้อเสนอที่เรียกว่า RFC

ทุกคนสามารถเขียน RFC เพื่อปรับปรุง Rust ได้ และข้อเสนอจะได้รับการตรวจสอบและหารือโดยทีม Rust ซึ่งประกอบด้วยทีมย่อยหลายหัวข้อ มีรายชื่อทีมทั้งหมด [บนเว็บไซต์ของ Rust](https://www.rust-lang.org/governance) ซึ่งรวมถึงทีมสำหรับแต่ละส่วนของโปรเจกต์: การออกแบบภาษา การ υλοποιώ (implement) คอมไพเลอร์ โครงสร้างพื้นฐาน เอกสารประกอบ และอื่นๆ ทีมที่เหมาะสมจะอ่านข้อเสนอและความคิดเห็น เขียนความคิดเห็นของตนเอง และในที่สุดก็จะมีฉันทามติในการยอมรับหรือปฏิเสธฟีเจอร์นั้น

หากฟีเจอร์นั้นได้รับการยอมรับ จะมีการเปิด issue บน repository Rust และมีคนสามารถ υλοποιώ (implement) ได้ คนที่ υλοποιώ (implement) อาจไม่ใช่คนเดียวกับที่เสนอฟีเจอร์ตั้งแต่แรก! เมื่อ υλοποίηση (implementation) พร้อมแล้ว มันจะถูกรวมเข้ากับ branch `master` หลัง feature gate ดังที่เราได้กล่าวถึงในส่วน [“ฟีเจอร์ที่ไม่เสถียร”](#unstable-features)<!-- ignore -->

หลังจากนั้นไม่นาน เมื่อนักพัฒนา Rust ที่ใช้ nightly releases ได้ลองใช้ฟีเจอร์ใหม่แล้ว สมาชิกในทีมจะหารือเกี่ยวกับฟีเจอร์นั้น ว่ามันทำงานอย่างไรบน nightly และตัดสินใจว่าควรจะนำเข้าสู่ stable Rust หรือไม่ หากตัดสินใจที่จะดำเนินการต่อ feature gate จะถูกลบออก และฟีเจอร์นั้นจะถือว่าเสถียรแล้ว! มันจะเดินทางไปกับรถไฟสู่ Rust stable release ใหม่
