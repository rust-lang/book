## تنظيم الاختبارات

كما ذُكر في بداية الفصل، الاختبار هو مجال معقد، ويستخدم أشخاص مختلفون
مصطلحات وتنظيمات مختلفة. يفكر مجتمع Rust في الاختبارات من حيث فئتين
رئيسيتين: اختبارات الوحدة واختبارات التكامل. _اختبارات الوحدة_ صغيرة وأكثر
تركيزًا، تختبر وحدة واحدة بمعزل عن الآخرين في كل مرة، ويمكنها اختبار
الواجهات الخاصة. _اختبارات التكامل_ خارجية تمامًا عن مكتبتك وتستخدم
كودك بنفس الطريقة التي سيستخدمه بها أي كود خارجي آخر، باستخدام الواجهة
العامة فقط وربما تمرين عدة وحدات في كل اختبار.

كتابة كلا النوعين من الاختبارات مهمة للتأكد من أن أجزاء مكتبتك تقوم بما
تتوقعه منها، بشكل منفصل ومعًا.

### اختبارات الوحدة

الغرض من اختبارات الوحدة هو اختبار كل وحدة من الكود بمعزل عن بقية الكود
لتحديد بسرعة أين يعمل الكود وأين لا يعمل كما هو متوقع. ستضع اختبارات
الوحدة في دليل _src_ في كل ملف مع الكود الذي تختبره. العرف هو إنشاء وحدة
باسم `tests` في كل ملف لاحتواء دوال الاختبار والتعليق على الوحدة بـ
`cfg(test)`.

#### وحدة `tests` و `#[cfg(test)]`

التعليق `#[cfg(test)]` على وحدة `tests` يخبر Rust بتجميع وتشغيل كود
الاختبار فقط عندما تقوم بتشغيل `cargo test`، وليس عندما تقوم بتشغيل `cargo
build`. هذا يوفر وقت الترجمة عندما تريد فقط بناء المكتبة ويوفر مساحة في
الناتج المجمع الناتج لأن الاختبارات غير مضمنة. سترى أنه لأن اختبارات
التكامل تذهب في دليل مختلف، فإنها لا تحتاج إلى التعليق `#[cfg(test)]`.
ومع ذلك، لأن اختبارات الوحدة تذهب في نفس الملفات مثل الكود، ستستخدم
`#[cfg(test)]` لتحديد أنها يجب ألا تُضمَّن في النتيجة المجمعة.

تذكر أنه عندما أنشأنا مشروع `adder` الجديد في القسم الأول من هذا الفصل،
أنشأ Cargo هذا الكود لنا:

<span class="filename">اسم الملف: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

على وحدة `tests` المولدة تلقائيًا، تمثل السمة `cfg` _التهيئة_ وتخبر Rust
أن العنصر التالي يجب تضمينه فقط في حالة توفر خيار تهيئة معين. في هذه
الحالة، خيار التهيئة هو `test`، والذي يوفره Rust لتجميع وتشغيل الاختبارات.
باستخدام سمة `cfg`، يقوم Cargo بتجميع كود الاختبار الخاص بنا فقط إذا
قمنا بتشغيل الاختبارات بشكل نشط باستخدام `cargo test`. يتضمن هذا أي دوال
مساعدة قد تكون ضمن هذه الوحدة، بالإضافة إلى الدوال المعلَّمة بـ `#[test]`.

<!-- Old headings. Do not remove or links may break. -->

<a id="testing-private-functions"></a>

#### اختبارات الدوال الخاصة

هناك نقاش داخل مجتمع الاختبار حول ما إذا كان يجب اختبار الدوال الخاصة
بشكل مباشر أم لا، وتجعل لغات أخرى من الصعب أو المستحيل اختبار الدوال
الخاصة. بغض النظر عن أيديولوجية الاختبار التي تلتزم بها، فإن قواعد
الخصوصية في Rust تسمح لك باختبار الدوال الخاصة. ضع في اعتبارك الكود في
القائمة 11-12 مع الدالة الخاصة `internal_adder`.

<Listing number="11-12" file-name="src/lib.rs" caption="اختبار دالة خاصة">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}
```

</Listing>

لاحظ أن دالة `internal_adder` غير معلَّمة بـ `pub`. الاختبارات هي مجرد
كود Rust، ووحدة `tests` هي مجرد وحدة أخرى. كما ناقشنا في [«المسارات
للإشارة إلى عنصر في شجرة الوحدات»][paths]<!-- ignore -->، يمكن للعناصر في
الوحدات الفرعية استخدام العناصر في وحداتها الأصلية. في هذا الاختبار،
نجلب جميع العناصر التي تنتمي إلى الوحدة الأصلية لوحدة `tests` إلى النطاق
باستخدام `use super::*`، ثم يمكن للاختبار استدعاء `internal_adder`. إذا
كنت لا تعتقد أنه يجب اختبار الدوال الخاصة، فليس هناك شيء في Rust سيجبرك
على القيام بذلك.

### اختبارات التكامل

في Rust، اختبارات التكامل خارجية تمامًا عن مكتبتك. إنها تستخدم مكتبتك
بنفس الطريقة التي سيستخدمها أي كود آخر، مما يعني أنها يمكنها فقط استدعاء
الدوال التي تشكل جزءًا من واجهة برمجة التطبيقات العامة لمكتبتك. غرضها هو
اختبار ما إذا كانت أجزاء كثيرة من مكتبتك تعمل معًا بشكل صحيح. وحدات الكود
التي تعمل بشكل صحيح بمفردها يمكن أن تواجه مشاكل عند دمجها، لذا فإن تغطية
الاختبار للكود المدمج مهمة أيضًا. لإنشاء اختبارات التكامل، تحتاج أولاً إلى
دليل _tests_.

#### دليل _tests_

ننشئ دليل _tests_ في المستوى الأعلى من دليل مشروعنا، بجوار _src_. يعرف
Cargo البحث عن ملفات اختبار التكامل في هذا الدليل. يمكننا بعد ذلك إنشاء
العدد الذي نريده من ملفات الاختبار، وسيقوم Cargo بتجميع كل من الملفات
كصندوق فردي.

لننشئ اختبار تكامل. مع الكود في القائمة 11-12 لا يزال في ملف
_src/lib.rs_، أنشئ دليل _tests_، وأنشئ ملفًا جديدًا باسم
_tests/integration_test.rs_. يجب أن يبدو هيكل الدليل الخاص بك كما يلي:

```text
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

أدخل الكود في القائمة 11-13 في ملف _tests/integration_test.rs_.

<Listing number="11-13" file-name="tests/integration_test.rs" caption="اختبار تكامل لدالة في صندوق `adder`">

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}
```

</Listing>

كل ملف في دليل _tests_ هو صندوق منفصل، لذا نحتاج إلى جلب مكتبتنا إلى نطاق
كل صندوق اختبار. لهذا السبب، نضيف `use adder::add_two;` في أعلى الكود،
وهو ما لم نحتاج إليه في اختبارات الوحدة.

لا نحتاج إلى التعليق على أي كود في _tests/integration_test.rs_ بـ
`#[cfg(test)]`. يتعامل Cargo مع دليل _tests_ بشكل خاص ويجمع الملفات في
هذا الدليل فقط عندما نقوم بتشغيل `cargo test`. قم بتشغيل `cargo test` الآن:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
```

الأقسام الثلاثة من الإخراج تشمل اختبارات الوحدة، واختبار التكامل،
واختبارات الوثائق. لاحظ أنه إذا فشل أي اختبار في قسم ما، فلن يتم تشغيل
الأقسام التالية. على سبيل المثال، إذا فشل اختبار وحدة، فلن يكون هناك أي
إخراج لاختبارات التكامل والوثائق، لأن تلك الاختبارات ستُشغَّل فقط إذا تم
تمرير جميع اختبارات الوحدة.

القسم الأول لاختبارات الوحدة هو نفسه الذي كنا نراه: سطر واحد لكل اختبار
وحدة (واحد يسمى `internal` أضفناه في القائمة 11-12) ثم سطر ملخص لاختبارات
الوحدة.

يبدأ قسم اختبارات التكامل بالسطر `Running tests/integration_test.rs`.
بعد ذلك، يوجد سطر لكل دالة اختبار في اختبار التكامل هذا وسطر ملخص لنتائج
اختبار التكامل مباشرة قبل بدء قسم `Doc-tests adder`.

كل ملف اختبار تكامل له قسم خاص به، لذا إذا أضفنا المزيد من الملفات في
دليل _tests_، فسيكون هناك المزيد من أقسام اختبار التكامل.

لا يزال بإمكاننا تشغيل دالة اختبار تكامل معينة بتحديد اسم دالة الاختبار
كوسيطة لـ `cargo test`. لتشغيل جميع الاختبارات في ملف اختبار تكامل معين،
استخدم وسيطة `--test` من `cargo test` متبوعة باسم الملف:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
```

هذا الأمر يشغل فقط الاختبارات في ملف _tests/integration_test.rs_.

#### الوحدات الفرعية في اختبارات التكامل

مع إضافة المزيد من اختبارات التكامل، قد ترغب في إنشاء المزيد من الملفات
في دليل _tests_ للمساعدة في تنظيمها؛ على سبيل المثال، يمكنك ترجمة دوال
الاختبار حسب الوظائف التي تختبرها. كما ذكرنا سابقًا، يتم ترجمة كل ملف في
دليل _tests_ كصندوق منفصل خاص به، وهو أمر مفيد لإنشاء نطاقات منفصلة لتقليد
الطريقة التي سيستخدم بها المستخدمون النهائيون صندوقك بشكل أكثر دقة. ومع
ذلك، هذا يعني أن الملفات في دليل _tests_ لا تشترك في نفس السلوك مثل
الملفات في _src_، كما تعلمت في الفصل 7 بشأن كيفية فصل الكود إلى وحدات
وملفات.

السلوك المختلف لملفات دليل _tests_ ملحوظ بشكل أكبر عندما يكون لديك مجموعة
من الدوال المساعدة لاستخدامها في ملفات اختبار تكامل متعددة، وتحاول اتباع
الخطوات في قسم [«فصل الوحدات إلى ملفات
مختلفة»][separating-modules-into-files]<!-- ignore --> من الفصل 7
لاستخراجها في وحدة مشتركة. على سبيل المثال، إذا قمنا بإنشاء
_tests/common.rs_ ووضعنا دالة باسم `setup` فيها، يمكننا إضافة بعض الكود إلى
`setup` نريد استدعاءه من دوال اختبار متعددة في ملفات اختبار متعددة:

<span class="filename">اسم الملف: tests/common.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}
```

عندما نقوم بتشغيل الاختبارات مرة أخرى، سنرى قسمًا جديدًا في إخراج
الاختبار لملف _common.rs_، على الرغم من أن هذا الملف لا يحتوي على أي دوال
اختبار ولم نستدع دالة `setup` من أي مكان:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
```

ظهور `common` في نتائج الاختبار مع عرض `running 0 tests` له ليس ما أردناه.
أردنا فقط مشاركة بعض الكود مع ملفات اختبار التكامل الأخرى. لتجنب ظهور
`common` في إخراج الاختبار، بدلاً من إنشاء _tests/common.rs_، سننشئ
_tests/common/mod.rs_. دليل المشروع الآن يبدو كما يلي:

```text
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

هذا هو اصطلاح التسمية الأقدم الذي تفهمه Rust أيضًا والذي ذكرناه في [«مسارات
الملفات البديلة»][alt-paths]<!-- ignore --> في الفصل 7. تسمية الملف بهذه
الطريقة تخبر Rust بعدم معاملة وحدة `common` كملف اختبار تكامل. عندما ننقل
كود دالة `setup` إلى _tests/common/mod.rs_ ونحذف ملف _tests/common.rs_، لن
يظهر القسم في إخراج الاختبار بعد الآن. الملفات في الأدلة الفرعية لدليل
_tests_ لا يتم ترجمتها كصناديق منفصلة أو لها أقسام في إخراج الاختبار.

بعد أن أنشأنا _tests/common/mod.rs_، يمكننا استخدامه من أي من ملفات اختبار
التكامل كوحدة. فيما يلي مثال على استدعاء دالة `setup` من اختبار
`it_adds_two` في _tests/integration_test.rs_:

<span class="filename">اسم الملف: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}
```

لاحظ أن تصريح `mod common;` هو نفسه تصريح الوحدة الذي أظهرناه في القائمة
7-21. ثم، في دالة الاختبار، يمكننا استدعاء دالة `common::setup()`.

#### اختبارات التكامل لصناديق الملفات التنفيذية

إذا كان مشروعنا صندوق ملف تنفيذي يحتوي فقط على ملف _src/main.rs_ وليس
لديه ملف _src/lib.rs_، فلا يمكننا إنشاء اختبارات تكامل في دليل _tests_
وجلب الدوال المحددة في ملف _src/main.rs_ إلى النطاق باستخدام عبارة `use`.
فقط صناديق المكتبات تكشف الدوال التي يمكن للصناديق الأخرى استخدامها؛
صناديق الملفات التنفيذية مخصصة للتشغيل بمفردها.

هذا أحد الأسباب التي تجعل مشاريع Rust التي توفر ملفًا تنفيذيًا لديها ملف
_src/main.rs_ بسيط يستدعي المنطق الموجود في ملف _src/lib.rs_. باستخدام هذا
الهيكل، _يمكن_ لاختبارات التكامل اختبار صندوق المكتبة باستخدام `use`
لجعل الوظائف المهمة متاحة. إذا كانت الوظائف المهمة تعمل، فإن الكمية
الصغيرة من الكود في ملف _src/main.rs_ ستعمل أيضًا، وتلك الكمية الصغيرة من
الكود لا تحتاج إلى اختبار.

## الخلاصة

توفر ميزات الاختبار في Rust طريقة لتحديد كيفية عمل الكود للتأكد من أنه
يستمر في العمل كما تتوقع، حتى عند إجراء تغييرات. تمارس اختبارات الوحدة
أجزاء مختلفة من المكتبة بشكل منفصل ويمكنها اختبار تفاصيل التنفيذ الخاصة.
تتحقق اختبارات التكامل من أن أجزاء كثيرة من المكتبة تعمل معًا بشكل صحيح،
وتستخدم واجهة برمجة التطبيقات العامة للمكتبة لاختبار الكود بنفس الطريقة
التي سيستخدمها بها الكود الخارجي. على الرغم من أن نظام الأنواع وقواعد
الملكية في Rust تساعد في منع بعض أنواع الأخطاء، لا تزال الاختبارات مهمة
لتقليل الأخطاء المنطقية المتعلقة بكيفية توقع سلوك كودك.

لنجمع المعرفة التي تعلمتها في هذا الفصل والفصول السابقة للعمل على مشروع!

[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[separating-modules-into-files]: ch07-05-separating-modules-into-different-files.html
[alt-paths]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths
