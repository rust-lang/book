## سازماندهی تست‌ها

همانطور که در ابتدای فصل ذکر شد، تست‌نویسی یک رشته پیچیده است، و افراد مختلف از اصطلاحات و سازماندهی متفاوتی استفاده می‌کنند. جامعه Rust تست‌ها را به دو دسته اصلی تقسیم می‌کند: تست‌های واحد و تست‌های یکپارچه. _تست‌های واحد_ کوچک و متمرکزتر هستند، یک ماژول را به طور جداگانه در یک زمان تست می‌کنند و می‌توانند رابط‌های خصوصی را تست کنند. _تست‌های یکپارچه_ کاملاً خارجی نسبت به کتابخانه شما هستند و از کد شما همانطور که هر کد خارجی دیگری استفاده می‌کند، تنها از طریق رابط عمومی استفاده می‌کنند و ممکن است چندین ماژول را در هر تست بررسی کنند.

نوشتن هر دو نوع تست برای اطمینان از اینکه قطعات کتابخانه شما به صورت جداگانه و با هم کار می‌کنند، مهم است.

### تست‌های واحد

هدف تست‌های واحد این است که هر واحد کد را به طور جداگانه از سایر کدها تست کنند تا به سرعت مشخص شود که کد کجا به درستی کار می‌کند و کجا نه. تست‌های واحد را در دایرکتوری _src_ در هر فایل با کدی که تست می‌کنند قرار می‌دهید. کنوانسیون این است که یک ماژول به نام `tests` در هر فایل ایجاد کنید تا توابع تست را در آن قرار دهید و ماژول را با `cfg(test)` حاشیه‌نویسی کنید.

#### ماژول تست‌ها و `#[cfg(test)]`

حاشیه‌نویسی `#[cfg(test)]` روی ماژول `tests` به Rust می‌گوید که کد تست فقط وقتی که `cargo test` اجرا شود کامپایل و اجرا شود، نه وقتی که `cargo build` اجرا شود. این باعث صرفه‌جویی در زمان کامپایل وقتی فقط می‌خواهید کتابخانه را بسازید می‌شود و فضای کمتری در نتیجه کامپایل‌شده می‌گیرد زیرا تست‌ها شامل نمی‌شوند. مشاهده خواهید کرد که چون تست‌های یکپارچه در یک دایرکتوری جداگانه قرار می‌گیرند، نیازی به حاشیه‌نویسی `#[cfg(test)]` ندارند. با این حال، چون تست‌های واحد در همان فایل‌هایی که کد قرار دارد قرار می‌گیرند، از `#[cfg(test)]` استفاده می‌کنید تا مشخص کنید که نباید در نتیجه کامپایل‌شده قرار گیرند.

به یاد بیاورید وقتی پروژه جدید `adder` را در بخش اول این فصل تولید کردیم، Cargo این کد را برای ما تولید کرد:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

روی ماژول `tests` که به طور خودکار تولید شده است، ویژگی `cfg` مخفف _پیکربندی_ است و به Rust می‌گوید که آیتم زیر فقط در صورت وجود یک گزینه پیکربندی مشخص گنجانده شود. در این مورد، گزینه پیکربندی `test` است، که توسط Rust برای کامپایل و اجرای تست‌ها ارائه می‌شود. با استفاده از ویژگی `cfg`، Cargo کد تست ما را فقط در صورتی که تست‌ها را به طور فعال با `cargo test` اجرا کنیم، کامپایل می‌کند. این شامل هر تابع کمکی که ممکن است در این ماژول باشد نیز می‌شود، علاوه بر توابعی که با `#[test]` حاشیه‌نویسی شده‌اند.

#### تست توابع خصوصی

در جامعه تست‌نویسی بحث‌هایی درباره اینکه آیا توابع خصوصی باید مستقیماً تست شوند یا نه وجود دارد، و برخی زبان‌ها تست کردن توابع خصوصی را دشوار یا غیرممکن می‌کنند. صرف نظر از اینکه از کدام ایدئولوژی تست‌نویسی پیروی می‌کنید، قوانین خصوصی‌سازی Rust به شما اجازه می‌دهند توابع خصوصی را تست کنید. کدی که در لیست ۱۱-۱۲ با تابع خصوصی `internal_adder` ارائه شده است را در نظر بگیرید.

<Listing number="11-12" file-name="src/lib.rs" caption="تست یک تابع خصوصی">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}
```

</Listing>

توجه داشته باشید که تابع `internal_adder` به‌صورت `pub` علامت‌گذاری نشده است.  
تست‌ها فقط کد Rust هستند و ماژول `tests` نیز یک ماژول عادی دیگر است.  
همان‌طور که در بخش [“مسیرها برای ارجاع به یک آیتم در درخت ماژول”][paths]<!-- ignore --> بحث کردیم،  
آیتم‌های ماژول‌های فرزند می‌توانند از آیتم‌های ماژول‌های والد خود استفاده کنند.  
در این تست، با استفاده از `use super::*` تمام آیتم‌های ماژول والد `tests` وارد حوزه می‌شوند،  
و سپس تست می‌تواند تابع `internal_adder` را فراخوانی کند.  
اگر فکر می‌کنید توابع خصوصی نباید تست شوند، در Rust هیچ اجباری برای انجام این کار وجود ندارد.

### تست‌های یکپارچه

در Rust، تست‌های یکپارچه کاملاً خارجی نسبت به کتابخانه شما هستند. آن‌ها از کتابخانه شما همانطور که هر کد دیگری استفاده می‌کند استفاده می‌کنند، که به این معنی است که فقط می‌توانند توابعی را که بخشی از رابط عمومی کتابخانه شما هستند فراخوانی کنند. هدف آن‌ها این است که بررسی کنند آیا قسمت‌های مختلف کتابخانه شما با یکدیگر به درستی کار می‌کنند یا نه. واحدهای کدی که به تنهایی به درستی کار می‌کنند می‌توانند هنگام یکپارچه‌سازی مشکل داشته باشند، بنابراین پوشش تست کد یکپارچه نیز مهم است. برای ایجاد تست‌های یکپارچه، ابتدا به یک دایرکتوری به نام _tests_ نیاز دارید.

#### دایرکتوری _tests_

ما یک دایرکتوری به نام _tests_ در سطح بالای دایرکتوری پروژه خود، در کنار _src_ ایجاد می‌کنیم. Cargo می‌داند که باید به دنبال فایل‌های تست یکپارچه در این دایرکتوری بگردد. سپس می‌توانیم به هر تعداد فایل تست که می‌خواهیم ایجاد کنیم، و Cargo هر یک از فایل‌ها را به عنوان یک crate جداگانه کامپایل می‌کند.

بیایید یک تست یکپارچه ایجاد کنیم. با کدی که هنوز در فایل _src/lib.rs_ از لیست ۱۱-۱۲ قرار دارد، یک دایرکتوری _tests_ ایجاد کنید و یک فایل جدید به نام _tests/integration_test.rs_ بسازید. ساختار دایرکتوری شما باید به این صورت باشد:

```text
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

کد موجود در لیست ۱۱-۱۳ را در فایل _tests/integration_test.rs_ وارد کنید.

<Listing number="11-13" file-name="tests/integration_test.rs" caption="یک تست یکپارچه برای تابعی در crate `adder`">

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}
```

</Listing>

هر فایل در دایرکتوری _tests_ یک crate جداگانه است، بنابراین باید کتابخانه خود را به دامنه هر crate تست وارد کنیم. به همین دلیل، در بالای کد `use adder::add_two;` را اضافه می‌کنیم، که در تست‌های واحد نیازی به آن نداشتیم.

نیازی نیست هیچ کدی در فایل _tests/integration_test.rs_ را با `#[cfg(test)]` علامت‌گذاری کنیم. Cargo دایرکتوری _tests_ را به طور خاص مدیریت می‌کند و فایل‌های موجود در این دایرکتوری را فقط زمانی که `cargo test` اجرا کنیم کامپایل می‌کند. اکنون `cargo test` را اجرا کنید:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
```

سه بخش خروجی شامل تست‌های واحد، تست یکپارچه، و تست‌های مستندات هستند. توجه داشته باشید که اگر هر تستی در یک بخش شکست بخورد، بخش‌های بعدی اجرا نخواهند شد. برای مثال، اگر یک تست واحد شکست بخورد، هیچ خروجی‌ای برای تست‌های یکپارچه و مستندات وجود نخواهد داشت زیرا آن تست‌ها فقط در صورتی اجرا می‌شوند که تمام تست‌های واحد پاس شوند.

بخش اول برای تست‌های واحد همان چیزی است که قبلاً دیده‌ایم: یک خط برای هر تست واحد (یکی به نام `internal` که در لیست ۱۱-۱۲ اضافه کردیم) و سپس یک خط خلاصه برای تست‌های واحد.

بخش تست‌های یکپارچه با خط `Running tests/integration_test.rs` شروع می‌شود. سپس یک خط برای هر تابع تست در آن تست یکپارچه و یک خط خلاصه برای نتایج تست یکپارچه دقیقاً قبل از شروع بخش `Doc-tests adder` وجود دارد.

هر فایل تست یکپارچه بخش خاص خود را دارد، بنابراین اگر فایل‌های بیشتری در دایرکتوری _tests_ اضافه کنیم، بخش‌های بیشتری برای تست‌های یکپارچه خواهیم داشت.

ما هنوز می‌توانیم یک تابع تست خاص در یکپارچه را با مشخص کردن نام تابع تست به عنوان یک آرگومان برای `cargo test` اجرا کنیم. برای اجرای تمام تست‌های یک فایل تست یکپارچه خاص، از آرگومان `--test` برای `cargo test` به همراه نام فایل استفاده کنید:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
```

این فرمان فقط تست‌های موجود در فایل _tests/integration_test.rs_ را اجرا می‌کند.

#### زیرماژول‌ها در تست‌های یکپارچه

با اضافه کردن تست‌های یکپارچه بیشتر، ممکن است بخواهید فایل‌های بیشتری در دایرکتوری _tests_ برای کمک به سازماندهی آن‌ها ایجاد کنید؛ برای مثال، می‌توانید توابع تست را بر اساس عملکردی که تست می‌کنند گروه‌بندی کنید. همانطور که قبلاً ذکر شد، هر فایل در دایرکتوری _tests_ به عنوان یک crate جداگانه کامپایل می‌شود، که برای ایجاد دامنه‌های جداگانه مفید است تا بیشتر شبیه نحوه استفاده کاربران نهایی از crate شما باشد. با این حال، این به این معنی است که فایل‌های موجود در دایرکتوری _tests_ رفتار یکسانی با فایل‌های موجود در _src_ ندارند، همانطور که در فصل ۷ درباره جدا کردن کد به ماژول‌ها و فایل‌ها آموختید.

این رفتار متفاوت فایل‌های دایرکتوری _tests_ بیشترین توجه را زمانی جلب می‌کند که مجموعه‌ای از توابع کمکی برای استفاده در چندین فایل تست یکپارچه دارید و سعی می‌کنید مراحل بخش [“جدا کردن ماژول‌ها به فایل‌های مختلف”][separating-modules-into-files]<!-- ignore --> در فصل ۷ را برای استخراج آن‌ها به یک ماژول مشترک دنبال کنید. برای مثال، اگر _tests/common.rs_ ایجاد کنیم و یک تابع به نام `setup` در آن قرار دهیم، می‌توانیم کدی به `setup` اضافه کنیم که می‌خواهیم از چندین تابع تست در چندین فایل تست فراخوانی کنیم:

<span class="filename">Filename: tests/common.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}
```

وقتی دوباره تست‌ها را اجرا می‌کنیم، یک بخش جدید در خروجی تست برای فایل _common.rs_ خواهیم دید، حتی اگر این فایل هیچ تابع تستی ندارد و تابع `setup` را از هیچ جایی فراخوانی نکرده‌ایم:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
```

داشتن `common` در نتایج تست با `running 0 tests` نمایش داده شده برای آن، چیزی نبود که می‌خواستیم. ما فقط می‌خواستیم برخی کدها را با دیگر فایل‌های تست یکپارچه به اشتراک بگذاریم. برای جلوگیری از نمایش `common` در خروجی تست، به جای ایجاد _tests/common.rs_، فایل _tests/common/mod.rs_ را ایجاد می‌کنیم. اکنون ساختار دایرکتوری پروژه به این شکل است:

```text
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

این روش نام‌گذاری قدیمی‌تر است که Rust نیز آن را می‌شناسد و در بخش [“مسیرهای فایل جایگزین”][alt-paths]<!-- ignore --> در فصل ۷ به آن اشاره کردیم.  
نام‌گذاری فایل به این صورت به Rust می‌گوید که ماژول `common` را به عنوان یک فایل تست یکپارچه (integration test) در نظر نگیرد.  
وقتی کد تابع `setup` را به فایل _tests/common/mod.rs_ منتقل کنیم و فایل _tests/common.rs_ را حذف کنیم،  
بخش مربوطه در خروجی تست دیگر ظاهر نخواهد شد.  
فایل‌های موجود در زیرشاخه‌های دایرکتوری _tests_ به صورت crateهای جداگانه کامپایل نمی‌شوند  
و در خروجی تست نیز بخش مجزایی ندارند.

پس از ایجاد _tests/common/mod.rs_، می‌توانیم از آن به عنوان یک ماژول در هر یک از فایل‌های تست یکپارچه استفاده کنیم. در اینجا یک مثال از فراخوانی تابع `setup` از تست `it_adds_two` در _tests/integration_test.rs_ آمده است:

<span class="filename">Filename: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}
```

توجه داشته باشید که اعلان `mod common;` مشابه اعلان ماژولی است که در لیست ۷-۲۱ نشان دادیم. سپس، در تابع تست، می‌توانیم تابع `common::setup()` را فراخوانی کنیم.

#### تست‌های یکپارچه برای crate‌های دودویی

اگر پروژه ما یک crate دودویی باشد که فقط شامل یک فایل _src/main.rs_ است و فایل _src/lib.rs_ ندارد، نمی‌توانیم تست‌های یکپارچه را در دایرکتوری _tests_ ایجاد کنیم و توابع تعریف‌شده در فایل _src/main.rs_ را با یک عبارت `use` به دامنه وارد کنیم. فقط crate‌های کتابخانه‌ای توابعی را که سایر crate‌ها می‌توانند استفاده کنند در معرض قرار می‌دهند؛ crate‌های دودویی برای اجرای مستقل طراحی شده‌اند.

این یکی از دلایلی است که پروژه‌های Rust که یک دودویی ارائه می‌دهند، معمولاً یک فایل _src/main.rs_ ساده دارند که به منطق موجود در فایل _src/lib.rs_ فراخوانی می‌کند. با استفاده از این ساختار، تست‌های یکپارچه می‌توانند crate کتابخانه‌ای را با `use` تست کنند تا قابلیت مهم را در دسترس قرار دهند. اگر قابلیت مهم کار کند، مقدار کمی کد در فایل _src/main.rs_ نیز کار خواهد کرد، و نیازی به تست آن مقدار کم از کد نیست.

## خلاصه

ویژگی‌های تست‌نویسی در Rust راهی برای مشخص کردن نحوه عملکرد کد فراهم می‌کنند تا اطمینان حاصل شود که کد همانطور که انتظار می‌رود کار می‌کند، حتی زمانی که تغییراتی در آن ایجاد می‌کنید. تست‌های واحد بخش‌های مختلف یک کتابخانه را به طور جداگانه آزمایش می‌کنند و می‌توانند جزئیات پیاده‌سازی خصوصی را تست کنند. تست‌های یکپارچه بررسی می‌کنند که آیا بخش‌های مختلف کتابخانه به درستی با یکدیگر کار می‌کنند یا نه، و از رابط عمومی کتابخانه برای تست کد به همان روشی که کد خارجی از آن استفاده می‌کند، استفاده می‌کنند. حتی با وجود اینکه سیستم نوع‌ها و قوانین مالکیت در Rust به جلوگیری از برخی انواع باگ‌ها کمک می‌کند، تست‌ها همچنان برای کاهش باگ‌های منطقی که به نحوه عملکرد مورد انتظار کد مربوط می‌شوند، مهم هستند.

بیایید دانش خود را که در این فصل و فصل‌های قبلی یاد گرفتید، ترکیب کرده و روی یک پروژه کار کنیم!

[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html  
[separating-modules-into-files]: ch07-05-separating-modules-into-different-files.html  
[alt-paths]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths  
