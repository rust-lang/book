## المستقبلات وصيغة Async

العناصر الأساسية للبرمجة غير المتزامنة في Rust هي _المستقبلات_ (futures) وكلمات `async` و `await` الأساسية في Rust.

_المستقبل_ (future) هو قيمة قد لا تكون جاهزة الآن ولكنها ستصبح جاهزة في وقت ما في المستقبل. (يظهر نفس المفهوم في العديد من اللغات، أحيانًا تحت أسماء أخرى مثل _task_ أو _promise_.) توفر Rust سِمَة `Future` كحجر بناء بحيث يمكن تنفيذ عمليات async مختلفة بهياكل بيانات مختلفة ولكن بواجهة مشتركة. في Rust، المستقبلات هي أنواع تنفذ سِمَة `Future`. كل مستقبل يحمل معلوماته الخاصة حول التقدم الذي تم إحرازه وما يعنيه "جاهز".

يمكنك تطبيق الكلمة الأساسية `async` على الكتل والدوال لتحديد أنه يمكن مقاطعتها واستئنافها. داخل كتلة async أو دالة async، يمكنك استخدام الكلمة الأساسية `await` لـ _انتظار مستقبل_ (await a future) (أي، انتظر حتى يصبح جاهزًا). أي نقطة تنتظر فيها مستقبلًا داخل كتلة async أو دالة async هي نقطة محتملة لتلك الكتلة أو الدالة للتوقف والاستئناف. عملية التحقق من مستقبل لمعرفة ما إذا كانت قيمته متاحة بعد تسمى _الاستطلاع_ (polling).

بعض اللغات الأخرى، مثل C# و JavaScript، تستخدم أيضًا الكلمات الأساسية `async` و `await` للبرمجة غير المتزامنة. إذا كنت على دراية بتلك اللغات، فقد تلاحظ بعض الاختلافات المهمة في كيفية تعامل Rust مع الصيغة. هذا لسبب وجيه، كما سنرى!

عند كتابة async في Rust، نستخدم الكلمات الأساسية `async` و `await` في معظم الأوقات. تقوم Rust بتجميعها إلى كود مكافئ باستخدام سِمَة `Future`، تمامًا كما تقوم بتجميع حلقات `for` إلى كود مكافئ باستخدام سِمَة `Iterator`. نظرًا لأن Rust توفر سِمَة `Future`، يمكنك أيضًا تنفيذها لأنواع البيانات الخاصة بك عندما تحتاج إلى ذلك. العديد من الدوال التي سنراها في هذا الفصل ترجع أنواعًا بتنفيذاتها الخاصة لـ `Future`. سنعود إلى تعريف السِمَة في نهاية الفصل ونتعمق أكثر في كيفية عملها، لكن هذا يكفي من التفاصيل لإبقائنا نتحرك للأمام.

قد يبدو كل هذا مجردًا بعض الشيء، لذلك لنكتب برنامجنا الأول غير المتزامن: أداة صغيرة لاستخراج بيانات الويب. سنمرر عنواني URL من سطر الأوامر، ونجلب كليهما بشكل متزامن، ونرجع نتيجة أيهما ينتهي أولاً. سيحتوي هذا المثال على قدر لا بأس به من الصيغة الجديدة، لكن لا تقلق - سنشرح كل ما تحتاج إلى معرفته أثناء المضي قدمًا.

## برنامجنا الأول غير المتزامن

للحفاظ على تركيز هذا الفصل على تعلم async بدلاً من التعامل مع أجزاء النظام البيئي، قمنا بإنشاء مكتبة `trpl` (`trpl` هو اختصار لـ "The Rust Programming Language"). تعيد تصدير جميع الأنواع والسِمات والدوال التي ستحتاجها، بشكل أساسي من مكتبتي [`futures`][futures-crate]<!-- ignore --> و [`tokio`][tokio]<!-- ignore -->. مكتبة `futures` هي موطن رسمي لتجارب Rust للكود غير المتزامن، وهي في الواقع المكان الذي تم فيه تصميم سِمَة `Future` في الأصل. Tokio هي بيئة التشغيل غير المتزامنة الأكثر استخدامًا في Rust اليوم، خاصة لتطبيقات الويب. هناك بيئات تشغيل رائعة أخرى، وقد تكون أكثر ملاءمة لأغراضك. نستخدم مكتبة `tokio` تحت الغطاء لـ `trpl` لأنها جيدة الاختبار ومستخدمة على نطاق واسع.

في بعض الحالات، تعيد `trpl` أيضًا تسمية أو تغليف واجهات برمجة التطبيقات الأصلية لإبقائك مركزًا على التفاصيل ذات الصلة بهذا الفصل. إذا كنت ترغب في فهم ما تفعله المكتبة، نشجعك على التحقق من [كودها المصدري][crate-source]. ستتمكن من رؤية من أي مكتبة يأتي كل إعادة تصدير، وقد تركنا تعليقات موسعة تشرح ما تفعله المكتبة.

أنشئ مشروع ثنائي جديد باسم `hello-async` وأضف مكتبة `trpl` كتبعية:

```console
$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
```

الآن يمكننا استخدام الأجزاء المختلفة التي توفرها `trpl` لكتابة برنامجنا الأول غير المتزامن. سنبني أداة سطر أوامر صغيرة تجلب صفحتي ويب، وتسحب عنصر `<title>` من كل منهما، وتطبع عنوان الصفحة التي تنتهي من العملية بأكملها أولاً.

### تعريف دالة page_title

لنبدأ بكتابة دالة تأخذ عنوان URL لصفحة واحدة كمعامل، وتقدم طلبًا لها، وترجع نص عنصر `<title>` (انظر القائمة 17-1).

<Listing number="17-1" file-name="src/main.rs" caption="تعريف دالة async للحصول على عنصر العنوان من صفحة HTML">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-01/src/main.rs:all}}
```

</Listing>

أولاً، نحدد دالة تسمى `page_title` ونضع عليها علامة بالكلمة الأساسية `async`. ثم نستخدم دالة `trpl::get` لجلب أي عنوان URL يتم تمريره ونضيف الكلمة الأساسية `await` لانتظار الاستجابة. للحصول على نص `response`، نستدعي طريقة `text` الخاصة به ونعيد انتظارها مرة أخرى بالكلمة الأساسية `await`. كلتا هاتين الخطوتين غير متزامنة. بالنسبة لدالة `get`، يجب أن ننتظر حتى يرسل الخادم الجزء الأول من استجابته، والذي سيتضمن رؤوس HTTP وملفات تعريف الارتباط وما إلى ذلك ويمكن تسليمه بشكل منفصل عن نص الاستجابة. خاصةً إذا كان النص كبيرًا جدًا، فقد يستغرق وصوله بالكامل بعض الوقت. نظرًا لأنه يجب علينا انتظار _كامل_ الاستجابة للوصول، فإن طريقة `text` أيضًا غير متزامنة.

يجب علينا انتظار كلا هذين المستقبلين بشكل صريح، لأن المستقبلات في Rust _كسولة_ (lazy): لا تفعل أي شيء حتى تطلب منها ذلك بالكلمة الأساسية `await`. (في الواقع، ستظهر Rust تحذير المصرِّف إذا لم تستخدم مستقبلًا.) قد يذكرك هذا بمناقشة المُكرِّرات (iterators) في قسم ["معالجة سلسلة من العناصر بالمكررات"][iterators-lazy]<!-- ignore --> في الفصل 13. لا تفعل المُكرِّرات شيئًا ما لم تستدعِ طريقة `next` الخاصة بها - سواء بشكل مباشر أو باستخدام حلقات `for` أو طرق مثل `map` التي تستخدم `next` تحت الغطاء. وبالمثل، لا تفعل المستقبلات شيئًا ما لم تطلب منها ذلك بشكل صريح. يسمح هذا الكسل لـ Rust بتجنب تشغيل الكود غير المتزامن حتى يكون هناك حاجة إليه فعليًا.

> ملاحظة: هذا يختلف عن السلوك الذي رأيناه عند استخدام `thread::spawn` في قسم ["إنشاء خيط جديد باستخدام spawn"][thread-spawn]<!-- ignore --> في الفصل 16، حيث بدأ الإغلاق الذي مررناه إلى خيط آخر في العمل على الفور. كما أنه مختلف عن كيفية تعامل العديد من اللغات الأخرى مع async. لكنه مهم لـ Rust لتتمكن من تقديم ضماناتها للأداء، تمامًا كما هو الحال مع المُكرِّرات.

بمجرد حصولنا على `response_text`، يمكننا تحليله إلى مثيل من نوع `Html` باستخدام `Html::parse`. بدلاً من سلسلة نصية خام، لدينا الآن نوع بيانات يمكننا استخدامه للعمل مع HTML كهيكل بيانات أغنى. على وجه الخصوص، يمكننا استخدام طريقة `select_first` للعثور على المثيل الأول لمحدد CSS معين. من خلال تمرير السلسلة `"title"`، سنحصل على أول عنصر `<title>` في المستند، إذا كان هناك واحد. نظرًا لأنه قد لا يكون هناك أي عنصر مطابق، تُرجع `select_first` `Option<ElementRef>`. أخيرًا، نستخدم طريقة `Option::map`، التي تتيح لنا العمل مع العنصر في `Option` إذا كان موجودًا، ولا تفعل شيئًا إذا لم يكن كذلك. (يمكننا أيضًا استخدام تعبير `match` هنا، لكن `map` أكثر اصطلاحية.) في نص الدالة التي نوفرها لـ `map`، نستدعي `inner_html` على `title` للحصول على محتواه، وهو `String`. عندما يتم كل شيء، لدينا `Option<String>`.

لاحظ أن الكلمة الأساسية `await` في Rust تأتي _بعد_ التعبير الذي تنتظره، وليس قبله. أي، إنها كلمة أساسية _لاحقة_ (postfix). قد يختلف هذا عن ما اعتدت عليه إذا كنت قد استخدمت `async` في لغات أخرى، ولكن في Rust يجعل سلاسل الطرق أكثر جمالاً للعمل معها. ونتيجة لذلك، يمكننا تغيير نص `page_title` لسلسلة استدعاءات دالتي `trpl::get` و `text` معًا مع `await` بينهما، كما هو موضح في القائمة 17-2.

<Listing number="17-2" file-name="src/main.rs" caption="التسلسل باستخدام الكلمة الأساسية `await`">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-02/src/main.rs:chaining}}
```

</Listing>

بذلك، نكون قد كتبنا بنجاح دالتنا الأولى غير المتزامنة! قبل أن نضيف بعض الكود في `main` لاستدعائها، دعنا نتحدث قليلاً عما كتبناه وما يعنيه.

عندما ترى Rust _كتلة_ محددة بالكلمة الأساسية `async`، فإنها تقوم بتجميعها في نوع بيانات فريد ومجهول ينفذ سِمَة `Future`. عندما ترى Rust _دالة_ محددة بـ `async`، فإنها تقوم بتجميعها إلى دالة غير async يكون نصها كتلة async. نوع إرجاع دالة async هو نوع البيانات المجهول الذي ينشئه المصرِّف لتلك الكتلة async.

وبالتالي، فإن كتابة `async fn` تعادل كتابة دالة ترجع _مستقبلًا_ (future) لنوع الإرجاع. بالنسبة للمصرِّف، تعريف دالة مثل `async fn page_title` في القائمة 17-1 يعادل تقريبًا دالة غير async محددة على النحو التالي:

```rust
# extern crate trpl; // مطلوب لاختبار mdbook
use std::future::Future;
use trpl::Html;

fn page_title(url: &str) -> impl Future<Output = Option<String>> {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
```

لنمر بكل جزء من النسخة المحولة:

- تستخدم صيغة `impl Trait` التي ناقشناها في الفصل 10 في قسم ["السِمات كمعاملات"][impl-trait]<!-- ignore -->.
- القيمة المرجعة تنفذ سِمَة `Future` مع نوع مرتبط `Output`. لاحظ أن نوع `Output` هو `Option<String>`، وهو نفس نوع الإرجاع الأصلي من نسخة `async fn` من `page_title`.
- يتم تغليف جميع الكود المستدعى في نص الدالة الأصلية في كتلة `async move`. تذكر أن الكتل هي تعبيرات. هذه الكتلة بأكملها هي التعبير المرجع من الدالة.
- تنتج هذه الكتلة async قيمة بنوع `Option<String>`، كما هو موضح للتو. تطابق تلك القيمة نوع `Output` في نوع الإرجاع. هذا تمامًا مثل الكتل الأخرى التي رأيتها.
- نص الدالة الجديد هو كتلة `async move` بسبب كيفية استخدامها لمعامل `url`. (سنتحدث كثيرًا عن `async` مقابل `async move` لاحقًا في الفصل.)

الآن يمكننا استدعاء `page_title` في `main`.

<!-- Old headings. Do not remove or links may break. -->

<a id ="determining-a-single-pages-title"></a>

### تنفيذ دالة Async باستخدام بيئة تشغيل

للبدء، سنحصل على العنوان لصفحة واحدة، كما هو موضح في القائمة 17-3. لسوء الحظ، هذا الكود لا يترجم بعد.

<Listing number="17-3" file-name="src/main.rs" caption="استدعاء دالة `page_title` من `main` بوسيطة مقدمة من المستخدم">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-03/src/main.rs:main}}
```

</Listing>

نتبع نفس النمط الذي استخدمناه للحصول على وسائط سطر الأوامر في قسم ["قبول وسائط سطر الأوامر"][cli-args]<!-- ignore --> في الفصل 12. ثم نمرر وسيطة URL إلى `page_title` وننتظر النتيجة. نظرًا لأن القيمة التي ينتجها المستقبل هي `Option<String>`، نستخدم تعبير `match` لطباعة رسائل مختلفة لحساب ما إذا كانت الصفحة تحتوي على `<title>`.

المكان الوحيد الذي يمكننا فيه استخدام الكلمة الأساسية `await` هو في الدوال أو الكتل غير المتزامنة، ولن تسمح لنا Rust بوضع علامة على دالة `main` الخاصة بأنها `async`.

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
انسخ خطأ المصرِّف فقط
-->

```text
error[E0752]: `main` function is not allowed to be `async`
 --> src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
```

السبب في أن `main` لا يمكن أن تكون محددة بـ `async` هو أن الكود غير المتزامن يحتاج إلى _بيئة تشغيل_ (runtime): مكتبة Rust تدير تفاصيل تنفيذ الكود غير المتزامن. يمكن لدالة `main` في البرنامج _تهيئة_ بيئة تشغيل، لكنها ليست بيئة تشغيل _بحد ذاتها_. (سنرى المزيد حول سبب ذلك لاحقًا.) كل برنامج Rust ينفذ كود async لديه مكان واحد على الأقل حيث يقوم بإعداد بيئة تشغيل تنفذ المستقبلات.

معظم اللغات التي تدعم async تجمع بيئة تشغيل، لكن Rust لا تفعل ذلك. بدلاً من ذلك، هناك العديد من بيئات التشغيل غير المتزامنة المختلفة المتاحة، كل منها يقدم مقايضات مختلفة مناسبة لحالة الاستخدام التي تستهدفها. على سبيل المثال، خادم ويب عالي الإنتاجية بنوى معالج متعددة وكمية كبيرة من ذاكرة الوصول العشوائي له احتياجات مختلفة تمامًا عن متحكم دقيق بنواة واحدة، وكمية صغيرة من ذاكرة الوصول العشوائي، ولا قدرة على تخصيص الذاكرة المؤقتة (heap). غالبًا ما توفر المكتبات التي توفر بيئات التشغيل تلك أيضًا إصدارات async من الوظائف الشائعة مثل ملف أو شبكة الإدخال/الإخراج.

هنا، وفي بقية هذا الفصل، سنستخدم دالة `block_on` من مكتبة `trpl`، التي تأخذ مستقبلًا كوسيطة وتحجب الخيط الحالي حتى يعمل هذا المستقبل حتى الاكتمال. خلف الكواليس، يقوم استدعاء `block_on` بإعداد بيئة تشغيل باستخدام مكتبة `tokio` التي تُستخدم لتشغيل المستقبل الذي يتم تمريره (سلوك `block_on` لمكتبة `trpl` مشابه لدوال `block_on` في مكتبات بيئة التشغيل الأخرى). بمجرد اكتمال المستقبل، يُرجع `block_on` أي قيمة أنتجها المستقبل.

يمكننا تمرير المستقبل المرجع بواسطة `page_title` مباشرة إلى `block_on`، وبمجرد اكتماله، يمكننا المطابقة على `Option<String>` الناتجة كما حاولنا القيام بذلك في القائمة 17-3. ومع ذلك، لمعظم الأمثلة في الفصل (ومعظم كود async في العالم الحقيقي)، سنقوم بأكثر من مجرد استدعاء دالة async واحدة، لذلك بدلاً من ذلك سنمرر كتلة `async` وننتظر بشكل صريح نتيجة استدعاء `page_title`، كما في القائمة 17-4.

<Listing number="17-4" caption="انتظار كتلة async باستخدام `trpl::block_on`" file-name="src/main.rs">

<!-- should_panic,noplayground because mdbook test does not pass args -->

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch17-async-await/listing-17-04/src/main.rs:run}}
```

</Listing>

عندما نقوم بتشغيل هذا الكود، نحصل على السلوك الذي توقعناه في البداية:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # تخطي كل ضجيج البناء
cargo run -- "https://www.rust-lang.org"
# انسخ الإخراج هنا
-->

```console
$ cargo run -- "https://www.rust-lang.org"
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
```

أخيرًا - لدينا بعض الكود غير المتزامن العامل! لكن قبل أن نضيف الكود للتسابق بين موقعين ضد بعضهما البعض، دعنا نوجه انتباهنا لفترة وجيزة إلى كيفية عمل المستقبلات.

كل _نقطة await_ - أي، كل مكان يستخدم فيه الكود الكلمة الأساسية `await` - تمثل مكانًا يتم فيه تسليم السيطرة مرة أخرى إلى بيئة التشغيل. لجعل ذلك يعمل، تحتاج Rust إلى تتبع الحالة المتضمنة في كتلة async بحيث يمكن لبيئة التشغيل بدء بعض الأعمال الأخرى ثم العودة عندما تكون جاهزة لمحاولة تقديم الأولى مرة أخرى. هذه آلة حالة غير مرئية، كما لو كنت قد كتبت enum مثل هذا لحفظ الحالة الحالية في كل نقطة await:

```rust
{{#rustdoc_include ../listings/ch17-async-await/no-listing-state-machine/src/lib.rs:enum}}
```

كتابة الكود للانتقال بين كل حالة يدويًا ستكون مملة وعرضة للخطأ، خاصةً عندما تحتاج إلى إضافة المزيد من الوظائف والمزيد من الحالات إلى الكود لاحقًا. لحسن الحظ، ينشئ مصرِّف Rust ويدير هياكل بيانات آلة الحالة للكود غير المتزامن تلقائيًا. لا تزال قواعد الاستعارة والملكية العادية حول هياكل البيانات سارية، ولحسن الحظ، يتعامل المصرِّف أيضًا مع التحقق من ذلك بالنسبة لنا ويوفر رسائل خطأ مفيدة. سنعمل من خلال القليل منها لاحقًا في الفصل.

في النهاية، يجب أن ينفذ شيء ما آلة الحالة هذه، وهذا الشيء هو بيئة تشغيل. (هذا هو السبب في أنك قد تصادف إشارات إلى _executors_ عند البحث في بيئات التشغيل: المنفذ (executor) هو جزء من بيئة التشغيل المسؤول عن تنفيذ الكود غير المتزامن.)

الآن يمكنك أن ترى لماذا أوقفنا المصرِّف من جعل `main` نفسها دالة async في القائمة 17-3. إذا كانت `main` دالة async، فسيحتاج شيء آخر إلى إدارة آلة الحالة لأي مستقبل ترجعه `main`، لكن `main` هي نقطة البداية للبرنامج! بدلاً من ذلك، استدعينا دالة `trpl::block_on` في `main` لإعداد بيئة تشغيل وتشغيل المستقبل المرجع بواسطة كتلة `async` حتى يتم ذلك.

> ملاحظة: توفر بعض بيئات التشغيل macros بحيث يمكنك _كتابة_ `main` غير متزامنة. تعيد تلك الماكرو كتابة `async fn main() { ... }` لتكون `fn main` عادية، والتي تقوم بنفس الشيء الذي قمنا به يدويًا في القائمة 17-4: استدعاء دالة تشغل مستقبلًا حتى الاكتمال بالطريقة التي يفعلها `trpl::block_on`.

الآن دعنا نجمع هذه القطع معًا ونرى كيف يمكننا كتابة كود متزامن.

<!-- Old headings. Do not remove or links may break. -->

<a id="racing-our-two-urls-against-each-other"></a>

### التسابق بين عنواني URL ضد بعضهما البعض بشكل متزامن

في القائمة 17-5، نستدعي `page_title` بعنواني URL مختلفين يتم تمريرهما من سطر الأوامر ونتسابق بينهما عن طريق اختيار أي مستقبل ينتهي أولاً.

<Listing number="17-5" caption="استدعاء `page_title` لعنواني URL لنرى أيهما يعود أولاً" file-name="src/main.rs">

<!-- should_panic,noplayground because mdbook does not pass args -->

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch17-async-await/listing-17-05/src/main.rs:all}}
```

</Listing>

نبدأ بالاتصال بـ `page_title` لكل من عناوين URL المقدمة من المستخدم. نحفظ المستقبلات الناتجة باسم `title_fut_1` و `title_fut_2`. تذكر، هذه لا تفعل أي شيء بعد، لأن المستقبلات كسولة ولم ننتظرها بعد. ثم نمرر المستقبلات إلى `trpl::select`، الذي يُرجع قيمة للإشارة إلى أي من المستقبلات الممررة إليه ينتهي أولاً.

> ملاحظة: تحت الغطاء، `trpl::select` مبني على دالة `select` أكثر عمومية محددة في مكتبة `futures`. يمكن لدالة `select` في مكتبة `futures` القيام بالكثير من الأشياء التي لا يمكن لدالة `trpl::select` القيام بها، لكن لديها أيضًا بعض التعقيد الإضافي الذي يمكننا تخطيه الآن.

يمكن لأي من المستقبلين "الفوز" بشكل شرعي، لذلك لا معنى لإرجاع `Result`. بدلاً من ذلك، يُرجع `trpl::select` نوعًا لم نره من قبل، `trpl::Either`. نوع `Either` يشبه إلى حد ما `Result` في أنه يحتوي على حالتين. ومع ذلك، على عكس `Result`، لا يوجد مفهوم للنجاح أو الفشل مدمج في `Either`. بدلاً من ذلك، يستخدم `Left` و `Right` للإشارة إلى "واحد أو الآخر":

```rust
enum Either<A, B> {
    Left(A),
    Right(B),
}
```

ترجع دالة `select` `Left` مع مخرجات ذلك المستقبل إذا فاز الوسيطة الأولى، و `Right` مع مخرجات وسيطة المستقبل الثانية إذا فاز _ذلك_. هذا يطابق ترتيب ظهور الوسائط عند استدعاء الدالة: الوسيطة الأولى على يسار الوسيطة الثانية.

نقوم أيضًا بتحديث `page_title` لإرجاع نفس عنوان URL الذي تم تمريره. بهذه الطريقة، إذا كانت الصفحة التي ترجع أولاً لا تحتوي على `<title>` يمكننا حلها، فلا يزال بإمكاننا طباعة رسالة ذات مغزى. مع توفر تلك المعلومات، ننتهي بتحديث إخراج `println!` للإشارة إلى كل من عنوان URL الذي انتهى أولاً وما هو، إن وجد، `<title>` لصفحة الويب على ذلك العنوان.

لديك الآن أداة صغيرة عاملة لاستخراج بيانات الويب! اختر زوجًا من عناوين URL وقم بتشغيل أداة سطر الأوامر. قد تكتشف أن بعض المواقع أسرع باستمرار من غيرها، بينما في حالات أخرى يختلف الموقع الأسرع من تشغيل إلى آخر. والأهم من ذلك، أنك تعلمت أساسيات العمل مع المستقبلات، حتى نتمكن الآن من التعمق أكثر في ما يمكننا القيام به مع async.

[impl-trait]: ch10-02-traits.html#traits-as-parameters
[iterators-lazy]: ch13-02-iterators.html
[thread-spawn]: ch16-01-threads.html#creating-a-new-thread-with-spawn
[cli-args]: ch12-01-accepting-command-line-arguments.html

<!-- TODO: map source link version to version of Rust? -->

[crate-source]: https://github.com/rust-lang/book/tree/main/packages/trpl
[futures-crate]: https://crates.io/crates/futures
[tokio]: https://tokio.rs
