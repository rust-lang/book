## معالجة سلسلة من العناصر باستخدام المُكرِّرات (Iterators)

يسمح لك نمط المُكرِّر (Iterator pattern) بأداء مهمة ما على سلسلة من العناصر بدورها. المُكرِّر (iterator) مسؤول عن منطق التكرار (iteration) على كل عنصر وتحديد متى انتهت السلسلة. عند استخدام المُكرِّرات، لا يتعين عليك إعادة تنفيذ هذا المنطق بنفسك.

في Rust، المُكرِّرات _كسولة_ (lazy)، مما يعني أنها لا يكون لها تأثير حتى تستدعي الدوال التي تستهلك المُكرِّر لاستخدامه. على سبيل المثال، الكود في القائمة 13-10 ينشئ مُكرِّرًا على العناصر في المتجه `v1` عن طريق استدعاء دالة `iter` المعرفة على `Vec<T>`. هذا الكود بحد ذاته لا يفعل أي شيء مفيد.

<Listing number="13-10" file-name="src/main.rs" caption="إنشاء مُكرِّر">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

</Listing>

يتم تخزين المُكرِّر في المتغيّر `v1_iter`. بمجرد إنشاء مُكرِّر، يمكننا استخدامه بطرق متنوعة. في القائمة 3-5، قمنا بالتكرار على مصفوفة باستخدام حلقة `for` لتنفيذ بعض الكود على كل من عناصرها. تحت الغطاء، أنشأ هذا ضمنيًا ثم استهلك مُكرِّرًا، لكننا تجاهلنا كيفية عمل ذلك بالضبط حتى الآن.

في المثال في القائمة 13-11، نفصل إنشاء المُكرِّر عن استخدام المُكرِّر في حلقة `for`. عندما يتم استدعاء حلقة `for` باستخدام المُكرِّر في `v1_iter`، يتم استخدام كل عنصر في المُكرِّر في تكرار واحد من الحلقة، مما يطبع كل قيمة.

<Listing number="13-11" file-name="src/main.rs" caption="استخدام مُكرِّر في حلقة `for`">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

</Listing>

في اللغات التي لا توفر مُكرِّرات من مكتباتها القياسية، من المحتمل أن تكتب نفس الوظيفة ببدء متغيّر عند المؤشر 0، واستخدام هذا المتغيّر للفهرسة في المتجه للحصول على قيمة، وزيادة قيمة المتغيّر في حلقة حتى تصل إلى العدد الإجمالي للعناصر في المتجه.

تتعامل المُكرِّرات مع كل هذا المنطق نيابة عنك، مما يقلل من الكود المتكرر الذي قد تخطئ فيه. تمنحك المُكرِّرات مزيدًا من المرونة لاستخدام نفس المنطق مع العديد من أنواع التسلسلات المختلفة، وليس فقط هياكل البيانات التي يمكنك الفهرسة فيها، مثل المتجهات. دعنا نفحص كيف تفعل المُكرِّرات ذلك.

### سِمَة `Iterator` ودالة `next`

تنفذ جميع المُكرِّرات سِمَة تسمى `Iterator` معرفة في المكتبة القياسية. يبدو تعريف السِمَة كالتالي:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

لاحظ أن هذا التعريف يستخدم بعض الصيغة الجديدة: `type Item` و `Self::Item`، والتي تعرف نوعًا مرتبطًا (associated type) بهذه السِمَة. سنتحدث عن الأنواع المرتبطة بعمق في الفصل 20. في الوقت الحالي، كل ما تحتاج إلى معرفته هو أن هذا الكود يقول إن تنفيذ سِمَة `Iterator` يتطلب منك أيضًا تعريف نوع `Item`، ويتم استخدام هذا النوع `Item` في نوع الإرجاع لدالة `next`. بعبارة أخرى، سيكون نوع `Item` هو النوع المعاد من المُكرِّر.

تتطلب سِمَة `Iterator` فقط من المنفذين تعريف دالة واحدة: دالة `next`، التي تعيد عنصرًا واحدًا من المُكرِّر في كل مرة، ملفوفًا في `Some`، وعندما ينتهي التكرار، تعيد `None`.

يمكننا استدعاء دالة `next` على المُكرِّرات مباشرة؛ توضح القائمة 13-12 القيم التي يتم إرجاعها من استدعاءات متكررة لـ `next` على المُكرِّر الذي تم إنشاؤه من المتجه.

<Listing number="13-12" file-name="src/lib.rs" caption="استدعاء دالة `next` على مُكرِّر">

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}
```

</Listing>

لاحظ أننا احتجنا إلى جعل `v1_iter` قابلاً للتغيير: استدعاء دالة `next` على مُكرِّر يغير الحالة الداخلية التي يستخدمها المُكرِّر لتتبع مكانه في السلسلة. بعبارة أخرى، هذا الكود _يستهلك_، أو يستخدم، المُكرِّر. كل استدعاء لـ `next` يستهلك عنصرًا من المُكرِّر. لم نكن بحاجة إلى جعل `v1_iter` قابلاً للتغيير عندما استخدمنا حلقة `for`، لأن الحلقة تولت ملكية `v1_iter` وجعلته قابلاً للتغيير خلف الكواليس.

لاحظ أيضًا أن القيم التي نحصل عليها من الاستدعاءات لـ `next` هي مَراجِع غير قابلة للتغيير إلى القيم في المتجه. تنتج دالة `iter` مُكرِّرًا على مَراجِع غير قابلة للتغيير. إذا أردنا إنشاء مُكرِّر يأخذ ملكية `v1` ويعيد قيمًا مملوكة، يمكننا استدعاء `into_iter` بدلاً من `iter`. وبالمثل، إذا أردنا التكرار على مَراجِع قابلة للتغيير، يمكننا استدعاء `iter_mut` بدلاً من `iter`.

### الدوال التي تستهلك المُكرِّر

سِمَة `Iterator` لديها عدد من الدوال المختلفة مع تنفيذات افتراضية توفرها المكتبة القياسية؛ يمكنك معرفة المزيد عن هذه الدوال من خلال النظر في توثيق API المكتبة القياسية لسِمَة `Iterator`. بعض هذه الدوال تستدعي دالة `next` في تعريفها، وهذا هو السبب في أنك مطالب بتنفيذ دالة `next` عند تنفيذ سِمَة `Iterator`.

الدوال التي تستدعي `next` تسمى _محولات مستهلكة_ (consuming adapters) لأن استدعاءها يستخدم المُكرِّر. أحد الأمثلة هو دالة `sum`، التي تأخذ ملكية المُكرِّر وتكرر عبر العناصر عن طريق الاستدعاء المتكرر لـ `next`، وبالتالي تستهلك (consume) المُكرِّر. أثناء التكرار (iteration)، تضيف كل عنصر إلى إجمالي تراكمي وتعيد الإجمالي عند اكتمال التكرار. تحتوي القائمة 13-13 على اختبار يوضح استخدام دالة `sum`.

<Listing number="13-13" file-name="src/lib.rs" caption="استدعاء دالة `sum` للحصول على المجموع الإجمالي لجميع العناصر في المُكرِّر">

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}
```

</Listing>

لا يُسمح لنا باستخدام `v1_iter` بعد الاستدعاء إلى `sum`، لأن `sum` تأخذ ملكية المُكرِّر الذي نستدعيه عليه.

### الدوال التي تنتج مُكرِّرات أخرى

_محولات المُكرِّرات_ (iterator adapters) هي دوال معرفة على سِمَة `Iterator` التي لا تستهلك المُكرِّر. بدلاً من ذلك، تنتج مُكرِّرات مختلفة عن طريق تغيير بعض جوانب المُكرِّر الأصلي.

تُظهر القائمة 13-14 مثالاً على استدعاء دالة محول المُكرِّر (iterator adapter) `map`، والتي تأخذ إغلاقًا (closure) للاستدعاء على كل عنصر أثناء التكرار عبر العناصر. تُعيد دالة `map` مُكرِّرًا جديدًا ينتج العناصر المعدلة. يُنشئ الإغلاق هنا مُكرِّرًا جديدًا يتم فيه زيادة كل عنصر من المتجه بمقدار 1.

<Listing number="13-14" file-name="src/main.rs" caption="استدعاء محول المُكرِّر `map` لإنشاء مُكرِّر جديد">

```rust,not_desired_behavior
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
```

</Listing>

ومع ذلك، ينتج هذا الكود تحذيرًا:

```console
{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
```

الكود في القائمة 13-14 لا يفعل أي شيء؛ الإغلاق الذي حددناه لا يتم استدعاؤه أبدًا. يذكرنا التحذير بالسبب: محولات المُكرِّرات كسولة (lazy)، ونحتاج إلى استهلاك المُكرِّر هنا.

لإصلاح هذا التحذير واستهلاك المُكرِّر، سنستخدم دالة `collect`، التي استخدمناها مع `env::args` في القائمة 12-1. تستهلك هذه الدالة المُكرِّر وتجمع القيم الناتجة في نوع بيانات مجموعة.

في القائمة 13-15، نجمع نتائج التكرار على المُكرِّر المعاد من الاستدعاء إلى `map` في متجه. سينتهي هذا المتجه بحمل كل عنصر من المتجه الأصلي، مزيدًا بمقدار 1.

<Listing number="13-15" file-name="src/main.rs" caption="استدعاء دالة `map` لإنشاء مُكرِّر جديد، ثم استدعاء دالة `collect` لاستهلاك المُكرِّر الجديد وإنشاء متجه">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
```

</Listing>

نظرًا لأن `map` تأخذ إغلاقًا، يمكننا تحديد أي عملية نريد تنفيذها على كل عنصر. هذا مثال رائع على كيفية السماح للإغلاقات بتخصيص بعض السلوك مع إعادة استخدام سلوك التكرار الذي توفره سِمَة `Iterator`.

يمكنك ربط استدعاءات متعددة لمحولات المُكرِّرات لأداء إجراءات معقدة بطريقة قابلة للقراءة. ولكن نظرًا لأن جميع المُكرِّرات كسولة، فيجب عليك استدعاء إحدى دوال المحول المستهلك للحصول على نتائج من استدعاءات محولات المُكرِّرات.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-closures-that-capture-their-environment"></a>

### الإغلاقات التي تلتقط بيئتها

تأخذ العديد من محولات المُكرِّرات إغلاقات كوسائط، وعادةً ما تكون الإغلاقات التي سنحددها كوسائط لمحولات المُكرِّرات إغلاقات تلتقط بيئتها.

في هذا المثال، سنستخدم دالة `filter` التي تأخذ إغلاقًا. يحصل الإغلاق على عنصر من المُكرِّر ويعيد `bool`. إذا أعاد الإغلاق `true`، فسيتم تضمين القيمة في التكرار الذي ينتجه `filter`. إذا أعاد الإغلاق `false`، فلن يتم تضمين القيمة.

في القائمة 13-16، نستخدم `filter` مع إغلاق يلتقط المتغيّر `shoe_size` من بيئته للتكرار على مجموعة من نُسخ بنية `Shoe`. سيعيد فقط الأحذية التي هي بالحجم المحدد.

<Listing number="13-16" file-name="src/lib.rs" caption="استخدام دالة `filter` مع إغلاق يلتقط `shoe_size`">

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}
```

</Listing>

تأخذ دالة `shoes_in_size` ملكية متجه من الأحذية وحجم الحذاء كمعاملات. تعيد متجهًا يحتوي فقط على الأحذية ذات الحجم المحدد.

في جسم `shoes_in_size`، نستدعي `into_iter` لإنشاء مُكرِّر يأخذ ملكية المتجه. ثم نستدعي `filter` لتكييف هذا المُكرِّر إلى مُكرِّر جديد يحتوي فقط على العناصر التي يعيد لها الإغلاق `true`.

يلتقط الإغلاق معامل `shoe_size` من البيئة ويقارن القيمة مع حجم كل حذاء، محتفظًا فقط بالأحذية ذات الحجم المحدد. أخيرًا، استدعاء `collect` يجمع القيم المعادة من المُكرِّر المكيّف في متجه يتم إرجاعه بواسطة الدالة.

يُظهر الاختبار أنه عندما نستدعي `shoes_in_size`، نحصل فقط على الأحذية التي لها نفس الحجم الذي حددناه.
