<!-- Old headings. Do not remove or links may break. -->

<a id="digging-into-the-traits-for-async"></a>

## نظرة أقرب على السِمات لـ Async

طوال الفصل، استخدمنا سِمات `Future` و `Stream` و `StreamExt` بطرق مختلفة. حتى الآن، تجنبنا الخوض بعيدًا في تفاصيل كيفية عملها أو كيفية تناسبها معًا، وهذا جيد في معظم الأوقات لعملك اليومي في Rust. ومع ذلك، في بعض الأحيان ستواجه مواقف تحتاج فيها إلى فهم المزيد من تفاصيل هذه السِمات، إلى جانب نوع `Pin` وسِمَة `Unpin`. في هذا القسم، سنتعمق بما يكفي للمساعدة في تلك السيناريوهات، لكن لا نزال نترك الغوص _العميق حقًا_ للوثائق الأخرى.

<!-- Old headings. Do not remove or links may break. -->

<a id="future"></a>

### سِمَة `Future`

لنبدأ بإلقاء نظرة أقرب على كيفية عمل سِمَة `Future`. إليك كيف تحددها Rust:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

يتضمن تعريف السِمَة هذا مجموعة من الأنواع الجديدة وأيضًا بعض الصيغة التي لم نشاهدها من قبل، لذلك دعنا نمر عبر التعريف جزءًا جزءًا.

أولاً، النوع المرتبط `Output` لـ `Future` يقول ما الذي يتحول إليه المستقبل. هذا مشابه للنوع المرتبط `Item` لسِمَة `Iterator`. ثانيًا، لدى `Future` طريقة `poll`، التي تأخذ مرجعًا خاصًا `Pin` لمعامل `self` الخاص بها ومرجعًا قابلاً للتغيير إلى نوع `Context`، وتُرجع `Poll<Self::Output>`. سنتحدث أكثر عن `Pin` و `Context` بعد لحظة. الآن، دعنا نركز على ما ترجعه الطريقة، نوع `Poll`:

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

نوع `Poll` هذا يشبه `Option`. لديه متغير واحد له قيمة، `Ready(T)`، وواحد ليس لديه، `Pending`. ومع ذلك، فإن `Poll` يعني شيئًا مختلفًا تمامًا عن `Option`! يشير متغير `Pending` إلى أن المستقبل لا يزال لديه عمل للقيام به، لذلك سيحتاج المتصل إلى التحقق مرة أخرى لاحقًا. يشير متغير `Ready` إلى أن `Future` أنهى عمله وأن قيمة `T` متاحة.

> ملاحظة: من النادر أن تحتاج إلى استدعاء `poll` مباشرة، ولكن إذا احتجت إلى ذلك، ضع في اعتبارك أنه مع معظم المستقبلات، لا يجب على المتصل استدعاء `poll` مرة أخرى بعد أن يُرجع المستقبل `Ready`. ستحدث العديد من المستقبلات ذعرًا إذا تم استطلاعها مرة أخرى بعد أن تصبح جاهزة. المستقبلات الآمنة لاستطلاعها مرة أخرى ستقول ذلك بوضوح في وثائقها. هذا مشابه لكيفية تصرف `Iterator::next`.

عندما ترى كودًا يستخدم `await`، تقوم Rust بتجميعه تحت الغطاء إلى كود يستدعي `poll`. إذا نظرت مرة أخرى إلى القائمة 17-4، حيث طبعنا عنوان الصفحة لعنوان URL واحد بمجرد حله، تقوم Rust بتجميعه إلى شيء نوع (وإن لم يكن تمامًا) مثل هذا:

```rust,ignore
match page_title(url).poll() {
    Ready(page_title) => match page_title {
        Some(title) => println!("The title for {url} was {title}"),
        None => println!("{url} had no title"),
    }
    Pending => {
        // لكن ماذا يحدث هنا؟
    }
}
```

ماذا يجب أن نفعل عندما يكون المستقبل لا يزال `Pending`؟ نحتاج إلى طريقة ما للمحاولة مرة أخرى، ومرة أخرى، ومرة أخرى، حتى يصبح المستقبل جاهزًا في النهاية. بعبارة أخرى، نحتاج إلى حلقة:

```rust,ignore
let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) => match page_title {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
        Pending => {
            // استمر
        }
    }
}
```

إذا جمعت Rust بالضبط إلى ذلك الكود، فإن كل `await` سيكون حجبًا - بالضبط عكس ما كنا نسعى إليه! بدلاً من ذلك، تضمن Rust أن الحلقة يمكنها تسليم التحكم إلى شيء يمكنه إيقاف العمل على هذا المستقبل مؤقتًا للعمل على مستقبلات أخرى ثم التحقق من هذا مرة أخرى لاحقًا. كما رأينا، هذا الشيء هو بيئة تشغيل async، وهذا العمل من الجدولة والتنسيق هو إحدى وظائفها الرئيسية.

في قسم ["إرسال البيانات بين مهمتين باستخدام تمرير الرسائل"][message-passing]<!-- ignore -->، وصفنا الانتظار على `rx.recv`. استدعاء `recv` يُرجع مستقبلًا، وانتظار المستقبل يستطلعه. لاحظنا أن بيئة التشغيل ستوقف المستقبل مؤقتًا حتى يصبح جاهزًا إما بـ `Some(message)` أو `None` عند إغلاق القناة. مع فهمنا الأعمق لسِمَة `Future`، وتحديدًا `Future::poll`، يمكننا أن نرى كيف يعمل ذلك. تعرف بيئة التشغيل أن المستقبل ليس جاهزًا عندما يُرجع `Poll::Pending`. على العكس من ذلك، تعرف بيئة التشغيل أن المستقبل _جاهز_ وتقدمه عندما يُرجع `poll` `Poll::Ready(Some(message))` أو `Poll::Ready(None)`.

التفاصيل الدقيقة لكيفية قيام بيئة التشغيل بذلك تتجاوز نطاق هذا الكتاب، لكن المفتاح هو رؤية الميكانيكا الأساسية للمستقبلات: بيئة تشغيل _تستطلع_ كل مستقبل مسؤولة عنه، وتعيد المستقبل إلى النوم عندما لا يكون جاهزًا بعد.

<!-- Old headings. Do not remove or links may break. -->

<a id="pinning-and-the-pin-and-unpin-traits"></a>
<a id="the-pin-and-unpin-traits"></a>

### نوع `Pin` وسِمَة `Unpin`

في القائمة 17-13، استخدمنا ماكرو `trpl::join!` لانتظار ثلاثة مستقبلات. ومع ذلك، من الشائع أن يكون لديك مجموعة مثل vector تحتوي على عدد من المستقبلات لن يكون معروفًا حتى وقت التشغيل. دعنا نغير القائمة 17-13 إلى الكود في القائمة 17-23 الذي يضع المستقبلات الثلاثة في vector ويستدعي دالة `trpl::join_all` بدلاً من ذلك، والتي لن تترجم بعد.

<Listing number="17-23" caption="انتظار المستقبلات في مجموعة"  file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-23/src/main.rs:here}}
```

</Listing>

نضع كل مستقبل داخل `Box` لجعلها _كائنات سِمة_ (trait objects)، تمامًا كما فعلنا في قسم "إرجاع الأخطاء من `run`" في الفصل 12. (سنغطي كائنات السِمة بالتفصيل في الفصل 18.) يتيح استخدام كائنات السِمة معاملة كل من المستقبلات المجهولة التي تنتجها هذه الأنواع كنفس النوع، لأنها جميعًا تنفذ سِمَة `Future`.

قد يكون هذا مفاجئًا. بعد كل شيء، لا تُرجع أي من كتل async أي شيء، لذلك كل واحدة تنتج `Future<Output = ()>`. تذكر أن `Future` هي سِمَة، وأن المصرِّف ينشئ enum فريدًا لكل كتلة async، حتى عندما يكون لها أنواع ناتجة متطابقة. تمامًا كما لا يمكنك وضع هيكلين مختلفين مكتوبين يدويًا في `Vec`، لا يمكنك مزج enums التي يولدها المصرِّف.

ثم نمرر مجموعة المستقبلات إلى دالة `trpl::join_all` وننتظر النتيجة. ومع ذلك، هذا لا يترجم؛ إليك الجزء ذي الصلة من رسائل الخطأ.

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23
cargo build
انسخ *فقط* كتلة `error` النهائية من الأخطاء
-->

```text
error[E0277]: `dyn Future<Output = ()>` cannot be unpinned
  --> src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = ()>`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<dyn Future<Output = ()>>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
```

تخبرنا الملاحظة في رسالة الخطأ هذه أنه يجب علينا استخدام ماكرو `pin!` لـ _تثبيت_ (pin) القيم، مما يعني وضعها داخل نوع `Pin` الذي يضمن عدم نقل القيم في الذاكرة. تقول رسالة الخطأ أن التثبيت مطلوب لأن `dyn Future<Output = ()>` يحتاج إلى تنفيذ سِمَة `Unpin` ولا يفعل ذلك حاليًا.

تُرجع دالة `trpl::join_all` هيكلاً يسمى `JoinAll`. هذا الهيكل عام على نوع `F`، والذي مقيد بتنفيذ سِمَة `Future`. يؤدي انتظار مستقبل مباشرة باستخدام `await` إلى تثبيت المستقبل ضمنيًا. لهذا السبب لا نحتاج إلى استخدام `pin!` في كل مكان نريد فيه انتظار المستقبلات.

ومع ذلك، نحن لا ننتظر مستقبلاً مباشرة هنا. بدلاً من ذلك، نبني مستقبلاً جديدًا، JoinAll، عن طريق تمرير مجموعة من المستقبلات إلى دالة `join_all`. يتطلب توقيع `join_all` أن تنفذ أنواع العناصر في المجموعة جميعها سِمَة `Future`، و `Box<T>` ينفذ `Future` فقط إذا كان `T` الذي يغلفه مستقبلاً ينفذ سِمَة `Unpin`.

هذا كثير لاستيعابه! لفهمه حقًا، دعنا نتعمق قليلاً أكثر في كيفية عمل سِمَة `Future` بالفعل، خاصة فيما يتعلق بالتثبيت. انظر مرة أخرى إلى تعريف سِمَة `Future`:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // الطريقة المطلوبة
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

معامل `cx` ونوع `Context` الخاص به هما مفتاح كيفية معرفة بيئة التشغيل متى يجب التحقق من أي مستقبل معين مع الاستمرار في الكسل. مرة أخرى، تفاصيل كيفية عمل ذلك تتجاوز نطاق هذا الفصل، وعمومًا تحتاج فقط إلى التفكير في هذا عند كتابة تنفيذ `Future` مخصص. سنركز بدلاً من ذلك على النوع لـ `self`، حيث أن هذه هي المرة الأولى التي نرى فيها طريقة حيث يكون لـ `self` تعليق توضيحي للنوع. يعمل تعليق توضيحي للنوع لـ `self` مثل تعليقات توضيحية للنوع لمعاملات الدوال الأخرى ولكن مع فرقين رئيسيين:

- يخبر Rust بنوع `self` الذي يجب أن يكون حتى يتم استدعاء الطريقة.
- لا يمكن أن يكون أي نوع فقط. إنه مقيد بالنوع الذي تم تنفيذ الطريقة عليه، أو مرجع أو مؤشر ذكي إلى هذا النوع، أو `Pin` يغلف مرجعًا إلى هذا النوع.

سنرى المزيد حول هذه الصيغة في [الفصل 18][ch-18]<!-- ignore -->. الآن، يكفي معرفة أننا إذا أردنا استطلاع مستقبل للتحقق مما إذا كان `Pending` أو `Ready(Output)`، فنحن نحتاج إلى مرجع قابل للتغيير مغلف بـ `Pin` للنوع.

`Pin` هو غلاف لأنواع شبيهة بالمؤشر مثل `&`، `&mut`، `Box`، و `Rc`. (تقنيًا، `Pin` يعمل مع الأنواع التي تنفذ سِمات `Deref` أو `DerefMut`، لكن هذا يعادل بشكل فعال العمل فقط مع المراجع والمؤشرات الذكية.) `Pin` ليس مؤشرًا بحد ذاته وليس له أي سلوك خاص به مثل `Rc` و `Arc` مع عد المراجع؛ إنه مجرد أداة يمكن للمصرِّف استخدامها لفرض قيود على استخدام المؤشر.

يبدأ تذكر أن `await` يتم تنفيذه من حيث استدعاءات `poll` في شرح رسالة الخطأ التي رأيناها سابقًا، لكن ذلك كان من حيث `Unpin`، وليس `Pin`. إذن كيف يرتبط `Pin` بالضبط بـ `Unpin`، ولماذا يحتاج `Future` إلى أن يكون `self` في نوع `Pin` لاستدعاء `poll`؟

تذكر من وقت سابق في هذا الفصل أن سلسلة من نقاط await في مستقبل يتم ترجمتها في آلة حالة، وأن المصرِّف يتأكد من أن آلة الحالة تتبع جميع قواعد Rust العادية حول الأمان، بما في ذلك الاستعارة والملكية. لجعل ذلك يعمل، تنظر Rust إلى البيانات المطلوبة بين نقطة await واحدة وإما نقطة await التالية أو نهاية كتلة async. ثم تنشئ متغيرًا مطابقًا في آلة الحالة المُترجَمة. يحصل كل متغير على الوصول الذي يحتاجه إلى البيانات التي ستُستخدم في هذا القسم من الكود المصدري، سواء من خلال الحصول على ملكية تلك البيانات أو من خلال الحصول على مرجع قابل أو غير قابل للتغيير لها.

حتى الآن، كل شيء على ما يرام: إذا حصلنا على أي شيء خاطئ حول الملكية أو المراجع في كتلة async معينة، فسيخبرنا مدقق الاستعارة. عندما نريد نقل المستقبل الذي يتوافق مع تلك الكتلة - مثل نقله إلى `Vec` لتمريره إلى `join_all` - تصبح الأمور أكثر صعوبة.

عندما ننقل مستقبلاً - سواء عن طريق دفعه إلى هيكل بيانات لاستخدامه كمكرر مع `join_all` أو عن طريق إرجاعه من دالة - فهذا يعني في الواقع نقل آلة الحالة التي تنشئها Rust لنا. وعلى عكس معظم الأنواع الأخرى في Rust، يمكن أن تنتهي المستقبلات التي تنشئها Rust لكتل async بمراجع لنفسها في حقول أي متغير معين، كما هو موضح في الرسم التوضيحي المبسط في الشكل 17-4.

<figure>

<img alt="جدول ذو عمود واحد وثلاثة صفوف يمثل مستقبلاً، fut1، الذي يحتوي على قيم بيانات 0 و 1 في الصفين الأولين وسهم يشير من الصف الثالث إلى الصف الثاني، يمثل مرجعًا داخليًا داخل المستقبل." src="img/trpl17-04.svg" class="center" />

<figcaption>الشكل 17-4: نوع بيانات مرجعي ذاتي</figcaption>

</figure>

افتراضيًا، أي كائن له مرجع لنفسه غير آمن للنقل، لأن المراجع دائمًا تشير إلى عنوان الذاكرة الفعلي لأي شيء تشير إليه (انظر الشكل 17-5). إذا نقلت هيكل البيانات نفسه، فستترك تلك المراجع الداخلية تشير إلى الموقع القديم. ومع ذلك، عنوان الذاكرة ذلك غير صالح الآن. أولاً، لن يتم تحديث قيمته عندما تجري تغييرات على هيكل البيانات. الأهم من ذلك، أن الكمبيوتر الآن حر في إعادة استخدام تلك الذاكرة لأغراض أخرى! يمكن أن تنتهي بقراءة بيانات غير ذات صلة تمامًا لاحقًا.

<figure>

<img alt="جدولان، يصوران مستقبلين، fut1 و fut2، كل منهما يحتوي على عمود واحد وثلاثة صفوف، يمثلان نتيجة نقل مستقبل من fut1 إلى fut2. الأول، fut1، باللون الرمادي، مع علامة استفهام في كل فهرس، تمثل ذاكرة غير معروفة. الثاني، fut2، يحتوي على 0 و 1 في الصفين الأول والثاني وسهم يشير من صفه الثالث إلى الصف الثاني من fut1، يمثل مؤشرًا يشير إلى الموقع القديم في الذاكرة للمستقبل قبل نقله." src="img/trpl17-05.svg" class="center" />

<figcaption>الشكل 17-5: النتيجة غير الآمنة لنقل نوع بيانات مرجعي ذاتي</figcaption>

</figure>

نظريًا، يمكن لمصرِّف Rust محاولة تحديث كل مرجع لكائن كلما تم نقله، لكن ذلك يمكن أن يضيف الكثير من النفقات العامة للأداء، خاصة إذا كان هناك شبكة كاملة من المراجع تحتاج إلى التحديث. إذا تمكنا بدلاً من ذلك من التأكد من أن هيكل البيانات المعني _لا ينتقل في الذاكرة_، فلن نحتاج إلى تحديث أي مراجع. هذا بالضبط ما هو مدقق الاستعارة في Rust من أجله: في الكود الآمن، يمنعك من نقل أي عنصر به مرجع نشط إليه.

يبني `Pin` على ذلك لمنحنا الضمان الدقيق الذي نحتاجه. عندما _نثبت_ قيمة عن طريق تغليف مؤشر إلى تلك القيمة في `Pin`، لم يعد بإمكانها الانتقال. وبالتالي، إذا كان لديك `Pin<Box<SomeType>>`، فأنت تثبت فعليًا قيمة `SomeType`، _وليس_ مؤشر `Box`. يوضح الشكل 17-6 هذه العملية.

<figure>

<img alt="ثلاثة صناديق موضوعة جنبًا إلى جنب. الأول موسوم بـ "Pin"، والثاني "b1"، والثالث "pinned". داخل "pinned" يوجد جدول موسوم بـ "fut"، بعمود واحد؛ إنه يمثل مستقبلاً بخلايا لكل جزء من هيكل البيانات. خليته الأولى لها القيمة "0"، وخليته الثانية بها سهم يخرج منها ويشير إلى الخلية الرابعة والنهائية، التي بها القيمة "1"، والخلية الثالثة بها خطوط منقطة وعلامة حذف للإشارة إلى أنه قد تكون هناك أجزاء أخرى لهيكل البيانات. معًا، يمثل جدول "fut" مستقبلاً مرجعيًا ذاتيًا. سهم يترك الصندوق الموسوم بـ "Pin"، يمر عبر الصندوق الموسوم بـ "b1" وينتهي داخل صندوق "pinned" في جدول "fut"." src="img/trpl17-06.svg" class="center" />

<figcaption>الشكل 17-6: تثبيت `Box` يشير إلى نوع مستقبل مرجعي ذاتي</figcaption>

</figure>

في الواقع، يمكن لمؤشر `Box` أن ينتقل بحرية. تذكر: نهتم بالتأكد من أن البيانات المشار إليها في النهاية تبقى في مكانها. إذا تحرك المؤشر، _لكن البيانات التي يشير إليها_ في نفس المكان، كما في الشكل 17-7، لا توجد مشكلة محتملة. (كتمرين مستقل، انظر إلى الوثائق للأنواع بالإضافة إلى وحدة `std::pin` وحاول معرفة كيف ستفعل ذلك بـ `Pin` يغلف `Box`.) المفتاح هو أن النوع المرجعي الذاتي نفسه لا يمكن أن ينتقل، لأنه لا يزال مثبتًا.

<figure>

<img alt="أربعة صناديق موضوعة في ثلاثة أعمدة تقريبًا، متطابقة مع الرسم التخطيطي السابق مع تغيير في العمود الثاني. الآن هناك صندوقان في العمود الثاني، موسومان بـ "b1" و "b2"، "b1" باللون الرمادي، والسهم من "Pin" يمر عبر "b2" بدلاً من "b1"، مما يشير إلى أن المؤشر قد انتقل من "b1" إلى "b2"، لكن البيانات في "pinned" لم تتحرك." src="img/trpl17-07.svg" class="center" />

<figcaption>الشكل 17-7: نقل `Box` يشير إلى نوع مستقبل مرجعي ذاتي</figcaption>

</figure>

ومع ذلك، فإن معظم الأنواع آمنة تمامًا للنقل حولها، حتى لو كانت خلف مؤشر `Pin`. نحتاج فقط إلى التفكير في التثبيت عندما يكون للعناصر مراجع داخلية. القيم البدائية مثل الأرقام و Booleans آمنة، لأنها من الواضح أنها لا تحتوي على أي مراجع داخلية. لا تحتوي معظم الأنواع التي تعمل معها عادة في Rust أيضًا على ذلك. يمكنك نقل `Vec`، على سبيل المثال، دون القلق. بالنظر إلى ما رأيناه حتى الآن، إذا كان لديك `Pin<Vec<String>>`، فسيتعين عليك القيام بكل شيء عبر واجهات برمجة التطبيقات الآمنة ولكن المقيدة التي يوفرها `Pin`، حتى على الرغم من أن `Vec<String>` دائمًا آمن للنقل إذا لم تكن هناك مراجع أخرى له. نحتاج إلى طريقة لإخبار المصرِّف أنه من الجيد نقل العناصر في حالات مثل هذه - وهنا يأتي دور `Unpin`.

`Unpin` هي سِمَة علامة، مشابهة لسِمات `Send` و `Sync` التي رأيناها في الفصل 16، وبالتالي ليس لها وظائف خاصة بها. تُوجد سِمات العلامة فقط لإخبار المصرِّف أنه من الآمن استخدام النوع الذي ينفذ سِمَة معينة في سياق معين. `Unpin` تُبلغ المصرِّف أن نوعًا معينًا _لا_ يحتاج إلى الالتزام بأي ضمانات حول ما إذا كان من الآمن نقل القيمة المعنية.

<!--
  الكود `<code>` المضمّن في الكتلة التالية هو للسماح بـ `<em>` المضمّن بداخله،
  مطابقًا لما تفعله NoStarch من ناحية الأسلوب، والتأكيد داخل النص هنا
  أنه شيء مميز عن النوع العادي.
-->

تمامًا كما هو الحال مع `Send` و `Sync`، ينفذ المصرِّف `Unpin` تلقائيًا لجميع الأنواع حيث يمكنه إثبات أنه آمن. الحالة الخاصة، مشابهة مرة أخرى لـ `Send` و `Sync`، هي حيث _لا_ يتم تنفيذ `Unpin` للنوع. التدوين لهذا هو <code>impl !Unpin for <em>SomeType</em></code>، حيث <code><em>SomeType</em></code> هو اسم النوع الذي _يحتاج_ إلى الالتزام بتلك الضمانات لتكون آمنة كلما تم استخدام مؤشر لهذا النوع في `Pin`.

بعبارة أخرى، هناك شيئان يجب وضعهما في الاعتبار حول العلاقة بين `Pin` و `Unpin`. أولاً، `Unpin` هي الحالة "العادية"، و `!Unpin` هي الحالة الخاصة. ثانيًا، ما إذا كان النوع ينفذ `Unpin` أو `!Unpin` _فقط_ مهم عندما تستخدم مؤشرًا مثبتًا لهذا النوع مثل <code>Pin<&mut <em>SomeType</em>></code>.

لجعل ذلك ملموسًا، فكر في `String`: لديها طول وأحرف Unicode التي تشكلها. يمكننا تغليف `String` في `Pin`، كما هو موضح في الشكل 17-8. ومع ذلك، `String` تنفذ تلقائيًا `Unpin`، كما تفعل معظم الأنواع الأخرى في Rust.

<figure>

<img alt="صندوق موسوم بـ "Pin" على اليسار بسهم ينطلق منه إلى صندوق موسوم بـ "String" على اليمين. يحتوي صندوق "String" على البيانات 5usize، يمثل طول السلسلة، والأحرف "h" و "e" و "l" و "l" و "o" يمثل أحرف السلسلة "hello" المخزنة في مثيل String هذا. مستطيل منقط يحيط بصندوق "String" وتسميته، لكن ليس صندوق "Pin"." src="img/trpl17-08.svg" class="center" />

<figcaption>الشكل 17-8: تثبيت `String`؛ الخط المنقط يشير إلى أن `String` تنفذ سِمَة `Unpin` وبالتالي لم يتم تثبيتها</figcaption>

</figure>

نتيجة لذلك، يمكننا القيام بأشياء ستكون غير قانونية إذا نفذت `String` `!Unpin` بدلاً من ذلك، مثل استبدال سلسلة واحدة بأخرى في نفس الموقع بالضبط في الذاكرة كما في الشكل 17-9. هذا لا ينتهك عقد `Pin`، لأن `String` ليس لديها مراجع داخلية تجعلها غير آمنة للنقل حولها. هذا بالضبط لماذا تنفذ `Unpin` بدلاً من `!Unpin`.

<figure>

<img alt="بيانات السلسلة "hello" نفسها من المثال السابق، الآن موسومة بـ "s1" وباللون الرمادي. صندوق "Pin" من المثال السابق يشير الآن إلى مثيل String مختلف، موسوم بـ "s2"، صالح، بطول 7usize، ويحتوي على أحرف السلسلة "goodbye". s2 محاط بمستطيل منقط لأنه أيضًا ينفذ سِمَة Unpin." src="img/trpl17-09.svg" class="center" />

<figcaption>الشكل 17-9: استبدال `String` بـ `String` مختلف تمامًا في الذاكرة</figcaption>

</figure>

الآن نعرف ما يكفي لفهم الأخطاء المبلغ عنها لهذا الاستدعاء `join_all` من القائمة 17-23. حاولنا في الأصل نقل المستقبلات التي تنتجها كتل async إلى `Vec<Box<dyn Future<Output = ()>>>`، لكن كما رأينا، قد تحتوي هذه المستقبلات على مراجع داخلية، لذلك لا تنفذ تلقائيًا `Unpin`. بمجرد تثبيتها، يمكننا تمرير نوع `Pin` الناتج إلى `Vec`، واثقين من أن البيانات الأساسية في المستقبلات _لن_ يتم نقلها. توضح القائمة 17-24 كيفية إصلاح الكود من خلال استدعاء ماكرو `pin!` حيث يتم تعريف كل من المستقبلات الثلاثة وضبط نوع كائن السِمَة.

<Listing number="17-24" caption="تثبيت المستقبلات لتمكين نقلها إلى vector">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-24/src/main.rs:here}}
```

</Listing>

يترجم هذا المثال الآن ويعمل، ويمكننا إضافة أو إزالة المستقبلات من vector في وقت التشغيل وضمها جميعًا.

`Pin` و `Unpin` مهمان في الغالب لبناء مكتبات ذات مستوى أدنى، أو عند بناء بيئة تشغيل نفسها، بدلاً من كود Rust اليومي. ومع ذلك، عندما ترى هذه السِمات في رسائل الخطأ، ستحصل الآن على فكرة أفضل عن كيفية إصلاح الكود الخاص بك!

> ملاحظة: هذا المزيج من `Pin` و `Unpin` يجعل من الممكن تنفيذ فئة كاملة من الأنواع المعقدة في Rust بأمان والتي كانت ستثبت تحديًا بطريقة أخرى لأنها مرجعية ذاتية. الأنواع التي تتطلب `Pin` تظهر بشكل أكثر شيوعًا في Rust غير المتزامن اليوم، لكن كل فترة، قد تراها في سياقات أخرى أيضًا.
>
> تمت تغطية تفاصيل كيفية عمل `Pin` و `Unpin`، والقواعد المطلوب عليهما الالتزام بها، بشكل موسع في وثائق واجهة برمجة التطبيقات لـ `std::pin`، لذلك إذا كنت مهتمًا بتعلم المزيد، فهذا مكان رائع للبدء.
>
> إذا كنت تريد فهم كيفية عمل الأشياء تحت الغطاء بمزيد من التفاصيل، فانظر الفصول [2][under-the-hood]<!-- ignore --> و [4][pinning]<!-- ignore --> من [_البرمجة غير المتزامنة في Rust_][async-book].

### سِمَة `Stream`

الآن بعد أن أصبح لديك فهم أعمق لسِمات `Future` و `Pin` و `Unpin`، يمكننا تحويل انتباهنا إلى سِمَة `Stream`. كما تعلمت سابقًا في الفصل، التدفقات مشابهة للمكررات غير المتزامنة. على عكس `Iterator` و `Future`، ومع ذلك، ليس لدى `Stream` تعريف في المكتبة القياسية في وقت كتابة هذا، لكن هناك تعريف شائع جدًا من مكتبة `futures` يُستخدم في جميع أنحاء النظام البيئي.

دعنا نراجع تعريفات سِمات `Iterator` و `Future` قبل النظر في كيف يمكن لسِمَة `Stream` دمجهما معًا. من `Iterator`، لدينا فكرة التسلسل: طريقة `next` الخاصة بها توفر `Option<Self::Item>`. من `Future`، لدينا فكرة الجاهزية بمرور الوقت: طريقة `poll` الخاصة بها توفر `Poll<Self::Output>`. لتمثيل تسلسل من العناصر التي تصبح جاهزة بمرور الوقت، نحدد سِمَة `Stream` التي تجمع هذه الميزات معًا:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>
    ) -> Poll<Option<Self::Item>>;
}
```

تحدد سِمَة `Stream` نوعًا مرتبطًا يسمى `Item` لنوع العناصر التي ينتجها التدفق. هذا مشابه لـ `Iterator`، حيث قد يكون هناك من صفر إلى عديد من العناصر، وعلى عكس `Future`، حيث يوجد دائمًا `Output` واحد، حتى لو كان نوع الوحدة `()`.

يحدد `Stream` أيضًا طريقة للحصول على تلك العناصر. نسميها `poll_next`، لتوضيح أنها تستطلع بنفس الطريقة التي يفعلها `Future::poll` وتنتج تسلسلاً من العناصر بنفس الطريقة التي يفعلها `Iterator::next`. نوع الإرجاع الخاص بها يجمع `Poll` مع `Option`. النوع الخارجي هو `Poll`، لأنه يجب فحصه للجاهزية، تمامًا كما يفعل المستقبل. النوع الداخلي هو `Option`، لأنه يحتاج إلى الإشارة إلى ما إذا كانت هناك المزيد من الرسائل، تمامًا كما يفعل المكرر.

شيء مشابه جدًا لهذا التعريف من المحتمل أن ينتهي كجزء من مكتبة Rust القياسية. في غضون ذلك، إنها جزء من مجموعة أدوات معظم بيئات التشغيل، لذلك يمكنك الاعتماد عليها، وكل شيء نغطيه بعد ذلك يجب أن ينطبق بشكل عام!

في الأمثلة التي رأيناها في قسم ["التدفقات: المستقبلات في تسلسل"][streams]<!-- ignore -->، لم نستخدم `poll_next` _أو_ `Stream`، بل استخدمنا `next` و `StreamExt` بدلاً من ذلك. _يمكننا_ العمل مباشرة من حيث واجهة برمجة التطبيقات `poll_next` من خلال كتابة آلات حالة `Stream` الخاصة بنا يدويًا، بالطبع، تمامًا كما _يمكننا_ العمل مع المستقبلات مباشرة عبر طريقة `poll` الخاصة بها. ومع ذلك، يعد استخدام `await` أجمل بكثير، وتوفر سِمَة `StreamExt` طريقة `next` حتى نتمكن من فعل ذلك تمامًا:

```rust
{{#rustdoc_include ../listings/ch17-async-await/no-listing-stream-ext/src/lib.rs:here}}
```

<!--
TODO: تحديث هذا إذا/عندما تقوم tokio/إلخ بتحديث MSRV الخاصة بها والتبديل إلى استخدام دوال async
في السِمات، حيث أن عدم وجود ذلك هو السبب في أنهم لم يفعلوا ذلك بعد.
-->

> ملاحظة: التعريف الفعلي الذي استخدمناه سابقًا في الفصل يبدو مختلفًا قليلاً عن هذا، لأنه يدعم إصدارات Rust التي لم تدعم بعد استخدام دوال async في السِمات. نتيجة لذلك، يبدو مثل هذا:
>
> ```rust,ignore
> fn next(&mut self) -> Next<'_, Self> where Self: Unpin;
> ```
>
> هذا النوع `Next` هو `struct` ينفذ `Future` ويسمح لنا بتسمية عمر المرجع إلى `self` بـ `Next<'_, Self>`، بحيث يمكن لـ `await` العمل مع هذه الطريقة.

سِمَة `StreamExt` هي أيضًا موطن جميع الطرق المثيرة المتاحة لاستخدامها مع التدفقات. يتم تنفيذ `StreamExt` تلقائيًا لكل نوع ينفذ `Stream`، لكن هذه السِمات محددة بشكل منفصل لتمكين المجتمع من التكرار على واجهات برمجة التطبيقات الملائمة دون التأثير على السِمَة الأساسية.

في نسخة `StreamExt` المستخدمة في مكتبة `trpl`، لا تحدد السِمَة طريقة `next` فحسب، بل توفر أيضًا تنفيذًا افتراضيًا لـ `next` يتعامل بشكل صحيح مع تفاصيل استدعاء `Stream::poll_next`. هذا يعني أنه حتى عندما تحتاج إلى كتابة نوع بيانات التدفق الخاص بك، _عليك فقط_ تنفيذ `Stream`، ثم يمكن لأي شخص يستخدم نوع بياناتك استخدام `StreamExt` وطرقها معه تلقائيًا.

هذا كل ما سنغطيه من التفاصيل منخفضة المستوى على هذه السِمات. لإنهاء، دعنا نفكر في كيفية تناسب المستقبلات (بما في ذلك التدفقات) والمهام والخيوط جميعًا معًا!

[message-passing]: ch17-02-concurrency-with-async.md#sending-data-between-two-tasks-using-message-passing
[ch-18]: ch18-00-oop.html
[async-book]: https://rust-lang.github.io/async-book/
[under-the-hood]: https://rust-lang.github.io/async-book/02_execution/01_chapter.html
[pinning]: https://rust-lang.github.io/async-book/04_pinning/01_chapter.html
[first-async]: ch17-01-futures-and-syntax.html#our-first-async-program
[any-number-futures]: ch17-03-more-futures.html#working-with-any-number-of-futures
[streams]: ch17-04-streams.html
