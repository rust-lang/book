## الدوال

الدوال منتشرة بكثرة في كود Rust. لقد رأيت بالفعل واحدة من أهم الدوال في اللغة: دالة `main`، والتي تمثل نقطة الدخول للعديد من البرامج. كما رأيت أيضًا الكلمة المفتاحية `fn`، والتي تسمح لك بتعريف دوال جديدة.

يستخدم كود Rust _نمط الثعبان_ (snake case) كأسلوب تقليدي لأسماء الدوال والمتغيرات، حيث تكون جميع الحروف صغيرة وتُفصل الكلمات بواسطة شرطات سفلية. إليك برنامج يحتوي على مثال لتعريف دالة:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

نعرّف دالة في Rust بإدخال `fn` متبوعة باسم الدالة ومجموعة من الأقواس. تخبر الأقواس المعقوفة المصرِّف بمكان بداية ونهاية جسم الدالة.

يمكننا استدعاء أي دالة قمنا بتعريفها بإدخال اسمها متبوعًا بمجموعة من الأقواس. نظرًا لأن `another_function` معرّفة في البرنامج، يمكن استدعاؤها من داخل دالة `main`. لاحظ أننا عرّفنا `another_function` _بعد_ دالة `main` في الكود المصدري؛ كان يمكننا تعريفها قبلها أيضًا. لا تهتم Rust بمكان تعريف الدوال، بل فقط بأنها معرّفة في مكان ما في نطاق يمكن للمستدعي رؤيته.

لنبدأ مشروع ثنائي جديد باسم _functions_ لاستكشاف الدوال بشكل أعمق. ضع مثال `another_function` في _src/main.rs_ وقم بتشغيله. يجب أن ترى الناتج التالي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

تُنفّذ الأسطر بالترتيب الذي تظهر به في دالة `main`. أولاً تُطبع رسالة "Hello, world!"، ثم يتم استدعاء `another_function` وتُطبع رسالتها.

### المعاملات

يمكننا تعريف دوال تحتوي على _معاملات_ (parameters)، وهي متغيرات خاصة تشكل جزءًا من توقيع الدالة. عندما تحتوي دالة على معاملات، يمكنك تزويدها بقيم محددة لتلك المعاملات. من الناحية التقنية، تُسمى القيم المحددة _وسائط_ (arguments)، ولكن في المحادثات العادية، يميل الناس إلى استخدام كلمتي _معامل_ و_وسيطة_ بشكل متبادل سواء للمتغيرات في تعريف الدالة أو للقيم المحددة الممررة عند استدعاء الدالة.

في هذا الإصدار من `another_function` نضيف معاملًا:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

جرب تشغيل هذا البرنامج؛ يجب أن تحصل على الناتج التالي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

تعريف `another_function` يحتوي على معامل واحد يُسمى `x`. نوع `x` محدد بأنه `i32`. عندما نمرر `5` إلى `another_function`، يضع الماكرو `println!` قيمة `5` حيث كان زوج الأقواس المعقوفة الذي يحتوي على `x` في سلسلة التنسيق.

في توقيعات الدوال، _يجب_ أن تعلن عن نوع كل معامل. هذا قرار متعمد في تصميم Rust: يعني طلب تعليقات النوع في تعاريف الدوال أن المصرِّف لا يحتاج تقريبًا أبدًا إلى استخدامها في مكان آخر في الكود لمعرفة النوع الذي تعنيه. كما أن المصرِّف قادر على تقديم رسائل خطأ أكثر إفادة إذا كان يعرف الأنواع التي تتوقعها الدالة.

عند تعريف معاملات متعددة، افصل تعريفات المعاملات بفواصل، هكذا:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

هذا المثال ينشئ دالة باسم `print_labeled_measurement` بمعاملين. المعامل الأول يُسمى `value` وهو من نوع `i32`. المعامل الثاني يُسمى `unit_label` وهو من نوع `char`. تطبع الدالة بعد ذلك نصًا يحتوي على كل من `value` و`unit_label`.

لنجرب تشغيل هذا الكود. استبدل البرنامج الموجود حاليًا في ملف _src/main.rs_ الخاص بمشروع _functions_ بالمثال السابق وقم بتشغيله باستخدام `cargo run`:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

نظرًا لأننا استدعينا الدالة بقيمة `5` لـ `value` وقيمة `'h'` لـ `unit_label`، يحتوي ناتج البرنامج على تلك القيم.

### العبارات والتعبيرات

تتكون أجسام الدوال من سلسلة من العبارات تنتهي اختياريًا بتعبير. حتى الآن، لم تتضمن الدوال التي غطيناها تعبيرًا نهائيًا، لكنك رأيت تعبيرًا كجزء من عبارة. نظرًا لأن Rust لغة قائمة على التعبيرات، فهذا تمييز مهم يجب فهمه. اللغات الأخرى ليس لديها نفس التمييزات، لذا دعنا ننظر إلى ماهية العبارات والتعبيرات وكيف تؤثر اختلافاتهما على أجسام الدوال.

- _العبارات_ هي تعليمات تنفذ إجراءً ما ولا تُرجع قيمة.
- _التعبيرات_ تُقيّم لتنتج قيمة ناتجة.

لنلقِ نظرة على بعض الأمثلة.

لقد استخدمنا بالفعل العبارات والتعبيرات. إنشاء متغير وتعيين قيمة له باستخدام الكلمة المفتاحية `let` هو عبارة. في القائمة 3-1، `let y = 6;` هي عبارة.

<Listing number="3-1" file-name="src/main.rs" caption="تعريف دالة `main` يحتوي على عبارة واحدة">

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

</Listing>

تعريفات الدوال هي أيضًا عبارات؛ المثال السابق بأكمله هو عبارة في حد ذاته. (كما سنرى قريبًا، استدعاء دالة ليس عبارة، رغم ذلك.)

العبارات لا تُرجع قيمًا. لذلك، لا يمكنك تعيين عبارة `let` إلى متغير آخر، كما يحاول الكود التالي القيام به؛ ستحصل على خطأ:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

عند تشغيل هذا البرنامج، سيبدو الخطأ الذي ستحصل عليه كالتالي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

عبارة `let y = 6` لا تُرجع قيمة، لذلك لا يوجد شيء يمكن ربط `x` به. هذا يختلف عما يحدث في لغات أخرى، مثل C وRuby، حيث يُرجع التعيين قيمة التعيين. في تلك اللغات، يمكنك كتابة `x = y = 6` ويكون لكل من `x` و`y` القيمة `6`؛ هذا ليس هو الحال في Rust.

التعبيرات تُقيّم لتنتج قيمة وتشكل معظم بقية الكود الذي ستكتبه في Rust. ضع في اعتبارك عملية رياضية، مثل `5 + 6`، وهي تعبير يُقيّم إلى القيمة `11`. يمكن أن تكون التعبيرات جزءًا من العبارات: في القائمة 3-1، الرقم `6` في عبارة `let y = 6;` هو تعبير يُقيّم إلى القيمة `6`. استدعاء دالة هو تعبير. استدعاء ماكرو هو تعبير. كتلة نطاق جديدة تُنشأ بأقواس معقوفة هي تعبير، على سبيل المثال:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

هذا التعبير:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

هو كتلة، في هذه الحالة، تُقيّم إلى `4`. تلك القيمة تُربط بـ `y` كجزء من عبارة `let`. لاحظ السطر `x + 1` بدون فاصلة منقوطة في النهاية، وهو على عكس معظم الأسطر التي رأيتها حتى الآن. التعبيرات لا تتضمن فواصل منقوطة في النهاية. إذا أضفت فاصلة منقوطة في نهاية تعبير، فإنك تحوّله إلى عبارة، وبالتالي لن تُرجع قيمة. ضع هذا في اعتبارك بينما تستكشف قيم الإرجاع للدوال والتعبيرات في القسم التالي.

### الدوال التي تُرجع قيمًا

يمكن للدوال إرجاع قيم إلى الكود الذي يستدعيها. لا نُسمي قيم الإرجاع، لكن يجب أن نعلن عن نوعها بعد سهم (`->`). في Rust، قيمة إرجاع الدالة مرادفة لقيمة التعبير النهائي في كتلة جسم الدالة. يمكنك العودة مبكرًا من دالة باستخدام الكلمة المفتاحية `return` وتحديد قيمة، لكن معظم الدوال تُرجع التعبير الأخير ضمنيًا. إليك مثالاً على دالة تُرجع قيمة:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

لا توجد استدعاءات دوال أو ماكروهات أو حتى عبارات `let` في دالة `five`—فقط الرقم `5` بمفرده. هذه دالة صحيحة تمامًا في Rust. لاحظ أن نوع إرجاع الدالة محدد أيضًا، بصيغة `-> i32`. جرب تشغيل هذا الكود؛ يجب أن يبدو الناتج كالتالي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

الرقم `5` في `five` هو قيمة إرجاع الدالة، ولهذا السبب نوع الإرجاع هو `i32`. لنفحص هذا بمزيد من التفصيل. هناك نقطتان مهمتان: أولاً، السطر `let x = five();` يوضح أننا نستخدم قيمة إرجاع دالة لتهيئة متغير. نظرًا لأن الدالة `five` تُرجع `5`، فإن ذلك السطر هو نفسه التالي:

```rust
let x = 5;
```

ثانيًا، دالة `five` ليس لديها معاملات وتعرّف نوع قيمة الإرجاع، لكن جسم الدالة هو رقم `5` وحيد بدون فاصلة منقوطة لأنه تعبير نريد إرجاع قيمته.

لنلقِ نظرة على مثال آخر:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

سيطبع تشغيل هذا الكود `The value of x is: 6`. لكن ماذا يحدث إذا وضعنا فاصلة منقوطة في نهاية السطر الذي يحتوي على `x + 1`، محوّلين إياه من تعبير إلى عبارة؟

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

سيؤدي ترجمة هذا الكود إلى خطأ، كما يلي:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

رسالة الخطأ الرئيسية، `mismatched types`، تكشف عن المشكلة الأساسية في هذا الكود. تعريف الدالة `plus_one` يقول إنها ستُرجع `i32`، لكن العبارات لا تُقيّم لتنتج قيمة، وهو ما يُعبر عنه بـ `()`، وهو نوع الوحدة. لذلك، لا يتم إرجاع أي شيء، وهو ما يتناقض مع تعريف الدالة ويؤدي إلى خطأ. في هذا الناتج، تقدم Rust رسالة للمساعدة في تصحيح هذه المشكلة: تقترح إزالة الفاصلة المنقوطة، والتي من شأنها إصلاح الخطأ.
