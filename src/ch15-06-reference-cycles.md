## دورات المراجع يمكن أن تسرب الذاكرة

ضمانات أمان الذاكرة في Rust تجعل من الصعب، ولكن ليس من المستحيل، إنشاء ذاكرة لا يتم تنظيفها أبدًا (المعروفة باسم _تسرب الذاكرة_ memory leak). منع تسرب الذاكرة بالكامل ليس أحد ضمانات Rust، مما يعني أن تسربات الذاكرة آمنة للذاكرة في Rust. يمكننا أن نرى أن Rust تسمح بتسرب الذاكرة باستخدام `Rc<T>` و `RefCell<T>`: من الممكن إنشاء مراجع حيث تشير العناصر إلى بعضها البعض في دورة. هذا ينشئ تسربات ذاكرة لأن عدد المراجع لكل عنصر في الدورة لن يصل أبدًا إلى 0، ولن يتم إسقاط القيم أبدًا.

### إنشاء دورة مرجع

دعنا ننظر في كيف يمكن أن تحدث دورة مرجع وكيفية منعها، بدءًا من تعريف enum `List` ووسيلة `tail` في القائمة 15-25.

<Listing number="15-25" file-name="src/main.rs" caption="تعريف قائمة cons يحتفظ بـ `RefCell<T>` بحيث يمكننا تعديل ما يشير إليه متغير `Cons`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-25/src/main.rs:here}}
```

</Listing>

نستخدم تنويعة أخرى من تعريف `List` من القائمة 15-5. العنصر الثاني في متغير `Cons` هو الآن `RefCell<Rc<List>>`، مما يعني أنه بدلاً من القدرة على تعديل قيمة `i32` كما فعلنا في القائمة 15-24، نريد تعديل قيمة `List` التي يشير إليها متغير `Cons`. نضيف أيضًا وسيلة `tail` لجعل الوصول إلى العنصر الثاني مريحًا لنا إذا كان لدينا متغير `Cons`.

في القائمة 15-26، نضيف دالة `main` تستخدم التعريفات في القائمة 15-25. هذا الكود ينشئ قائمة في `a` وقائمة في `b` تشير إلى القائمة في `a`. بعد ذلك، يعدل القائمة في `a` لتشير إلى `b`، مما ينشئ دورة مرجع. هناك عبارات `println!` على طول الطريق لإظهار ما هي أعداد المراجع في نقاط مختلفة في هذه العملية.

<Listing number="15-26" file-name="src/main.rs" caption="إنشاء دورة مرجع من قيمتي `List` تشيران إلى بعضهما البعض">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-26/src/main.rs:here}}
```

</Listing>

ننشئ نسخة `Rc<List>` تحتفظ بقيمة `List` في المتغير `a` مع قائمة أولية من `5, Nil`. بعد ذلك ننشئ نسخة `Rc<List>` تحتفظ بقيمة `List` أخرى في المتغير `b` تحتوي على القيمة `10` وتشير إلى القائمة في `a`.

نعدل `a` بحيث تشير إلى `b` بدلاً من `Nil`، مما ينشئ دورة. نقوم بذلك باستخدام وسيلة `tail` للحصول على مرجع إلى `RefCell<Rc<List>>` في `a`، والتي نضعها في المتغير `link`. بعد ذلك، نستخدم وسيلة `borrow_mut` على `RefCell<Rc<List>>` لتغيير القيمة داخل من `Rc<List>` التي تحتفظ بقيمة `Nil` إلى `Rc<List>` في `b`.

عندما نشغل هذا الكود، مع إبقاء آخر `println!` معلقة التعليق في الوقت الحالي، سنحصل على هذا المخرج:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-26/output.txt}}
```

عدد المراجع لنسخ `Rc<List>` في كل من `a` و `b` هو 2 بعد أن نغير القائمة في `a` لتشير إلى `b`. في نهاية `main`، تسقط Rust المتغير `b`، مما يقلل عدد المراجع لنسخة `b` `Rc<List>` من 2 إلى 1. لن يتم إسقاط الذاكرة التي لدى `Rc<List>` على الكومة في هذه النقطة لأن عدد مراجعها هو 1، وليس 0. بعد ذلك، تسقط Rust `a`، مما يقلل عدد المراجع لنسخة `a` `Rc<List>` من 2 إلى 1 أيضًا. لا يمكن إسقاط ذاكرة هذه النسخة أيضًا، لأن نسخة `Rc<List>` الأخرى لا تزال تشير إليها. ستبقى الذاكرة المخصصة للقائمة غير مجموعة إلى الأبد. لتصور هذه الدورة المرجعية، أنشأنا المخطط في الشكل 15-4.

<img alt="A rectangle labeled 'a' that points to a rectangle containing the integer 5. A rectangle labeled 'b' that points to a rectangle containing the integer 10. The rectangle containing 5 points to the rectangle containing 10, and the rectangle containing 10 points back to the rectangle containing 5, creating a cycle." src="img/trpl15-04.svg" class="center" />

<span class="caption">الشكل 15-4: دورة مرجع من القوائم `a` و `b` تشير إلى بعضها البعض</span>

إذا ألغيت تعليق آخر `println!` وشغلت البرنامج، ستحاول Rust طباعة هذه الدورة مع `a` تشير إلى `b` تشير إلى `a` وهكذا حتى تتدفق المكدس.

بالمقارنة مع برنامج في العالم الحقيقي، عواقب إنشاء دورة مرجع في هذا المثال ليست خطيرة جدًا: مباشرة بعد إنشاء دورة المرجع، ينتهي البرنامج. ومع ذلك، إذا خصص برنامج أكثر تعقيدًا الكثير من الذاكرة في دورة واحتفظ بها لفترة طويلة، سيستخدم البرنامج ذاكرة أكثر مما يحتاج وقد يطغى على النظام، مما يتسبب في نفاد الذاكرة المتاحة.

إنشاء دورات مراجع ليس سهلاً، ولكنه ليس مستحيلاً أيضًا. إذا كان لديك قيم `RefCell<T>` تحتوي على قيم `Rc<T>` أو مجموعات متداخلة مماثلة من الأنواع ذات القابلية للتغيير الداخلية وعد المراجع، يجب عليك التأكد من أنك لا تنشئ دورات؛ لا يمكنك الاعتماد على Rust لاكتشافها. إنشاء دورة مرجع سيكون خطأ منطقيًا في برنامجك يجب عليك استخدام الاختبارات الآلية، ومراجعات الكود، وممارسات تطوير البرمجيات الأخرى لتقليله.

حل آخر لتجنب دورات المراجع هو إعادة تنظيم هياكل البيانات الخاصة بك بحيث تعبر بعض المراجع عن الملكية وبعض المراجع لا تعبر عنها. نتيجة لذلك، يمكن أن يكون لديك دورات مكونة من بعض علاقات الملكية وبعض العلاقات غير الملكية، وفقط علاقات الملكية تؤثر على ما إذا كان يمكن إسقاط قيمة أم لا. في القائمة 15-25، نريد دائمًا أن تمتلك متغيرات `Cons` قائمتها، لذلك إعادة تنظيم هيكل البيانات غير ممكنة. دعنا ننظر في مثال باستخدام الرسوم البيانية المكونة من عقد أبوية وعقد فرعية لمعرفة متى تكون العلاقات غير الملكية طريقة مناسبة لمنع دورات المراجع.

<!-- Old headings. Do not remove or links may break. -->

<a id="preventing-reference-cycles-turning-an-rct-into-a-weakt"></a>

### منع دورات المراجع باستخدام `Weak<T>`

حتى الآن، أظهرنا أن استدعاء `Rc::clone` يزيد `strong_count` لنسخة `Rc<T>`، ويتم تنظيف نسخة `Rc<T>` فقط إذا كان `strong_count` الخاص بها هو 0. يمكنك أيضًا إنشاء مرجع ضعيف إلى القيمة داخل نسخة `Rc<T>` عن طريق استدعاء `Rc::downgrade` وتمرير مرجع إلى `Rc<T>`. *المراجع القوية* (Strong references) هي كيفية مشاركة ملكية نسخة `Rc<T>`. *المراجع الضعيفة* (Weak references) لا تعبر عن علاقة ملكية، وعددها لا يؤثر على وقت تنظيف نسخة `Rc<T>`. لن تتسبب في دورة مرجع، لأن أي دورة تتضمن بعض المراجع الضعيفة ستُكسر بمجرد أن يكون عدد المراجع القوية للقيم المعنية هو 0.

عندما تستدعي `Rc::downgrade`، تحصل على مؤشر ذكي من نوع `Weak<T>`. بدلاً من زيادة `strong_count` في نسخة `Rc<T>` بمقدار 1، يزيد استدعاء `Rc::downgrade` `weak_count` بمقدار 1. يستخدم نوع `Rc<T>` `weak_count` لتتبع عدد مراجع `Weak<T>` الموجودة، على غرار `strong_count`. الفرق هو أن `weak_count` لا يحتاج إلى أن يكون 0 لكي يتم تنظيف نسخة `Rc<T>`.

لأن القيمة التي يشير إليها `Weak<T>` قد تكون قد أُسقطت، للقيام بأي شيء مع القيمة التي يشير إليها `Weak<T>`، يجب عليك التأكد من أن القيمة لا تزال موجودة. قم بذلك عن طريق استدعاء وسيلة `upgrade` على نسخة `Weak<T>`، والتي ستعيد `Option<Rc<T>>`. ستحصل على نتيجة `Some` إذا لم يتم إسقاط قيمة `Rc<T>` بعد ونتيجة `None` إذا تم إسقاط قيمة `Rc<T>`. لأن `upgrade` تعيد `Option<Rc<T>>`، ستضمن Rust أنه سيتم التعامل مع حالة `Some` وحالة `None`، ولن يكون هناك مؤشر غير صالح.

كمثال، بدلاً من استخدام قائمة تعرف عناصرها فقط العنصر التالي، سننشئ شجرة تعرف عناصرها عن عناصرها الفرعية _و_ عناصرها الأبوية.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-a-tree-data-structure-a-node-with-child-nodes"></a>

#### إنشاء هيكل بيانات شجرة

للبدء، سنبني شجرة مع عقد تعرف عن عقدها الفرعية. سننشئ struct باسم `Node` يحتفظ بقيمة `i32` الخاصة به بالإضافة إلى مراجع إلى قيم `Node` الفرعية الخاصة به:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:here}}
```

نريد أن تمتلك `Node` أطفالها، ونريد مشاركة هذه الملكية مع المتغيرات بحيث يمكننا الوصول إلى كل `Node` في الشجرة مباشرة. للقيام بذلك، نعرّف عناصر `Vec<T>` لتكون قيمًا من نوع `Rc<Node>`. نريد أيضًا تعديل العقد التي هي أطفال لعقدة أخرى، لذلك لدينا `RefCell<T>` في `children` حول `Vec<Rc<Node>>`.

بعد ذلك، سنستخدم تعريف struct الخاص بنا وننشئ نسخة `Node` واحدة باسم `leaf` بالقيمة `3` وبدون أطفال، ونسخة أخرى باسم `branch` بالقيمة `5` و `leaf` كأحد أطفالها، كما هو موضح في القائمة 15-27.

<Listing number="15-27" file-name="src/main.rs" caption="إنشاء عقدة `leaf` بدون أطفال وعقدة `branch` مع `leaf` كأحد أطفالها">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:there}}
```

</Listing>

نستنسخ `Rc<Node>` في `leaf` ونخزن ذلك في `branch`، مما يعني أن `Node` في `leaf` لديه الآن مالكان: `leaf` و `branch`. يمكننا الوصول من `branch` إلى `leaf` من خلال `branch.children`، لكن لا توجد طريقة للوصول من `leaf` إلى `branch`. السبب هو أن `leaf` ليس لديه مرجع إلى `branch` ولا يعرف أنهما مرتبطان. نريد أن تعرف `leaf` أن `branch` هي والدها. سنفعل ذلك بعد ذلك.

#### إضافة مرجع من طفل إلى والده

لجعل العقدة الفرعية على دراية بوالدها، نحتاج إلى إضافة حقل `parent` إلى تعريف struct `Node` الخاص بنا. المشكلة في تحديد ما يجب أن يكون نوع `parent`. نعلم أنه لا يمكن أن يحتوي على `Rc<T>`، لأن ذلك سينشئ دورة مرجع مع `leaf.parent` تشير إلى `branch` و `branch.children` تشير إلى `leaf`، مما سيتسبب في أن قيم `strong_count` الخاصة بهم لن تكون أبدًا 0.

التفكير في العلاقات بطريقة أخرى، يجب أن تمتلك العقدة الأبوية أطفالها: إذا تم إسقاط عقدة أبوية، يجب أيضًا إسقاط عقدها الفرعية. ومع ذلك، يجب ألا يمتلك الطفل والده: إذا أسقطنا عقدة فرعية، يجب أن يبقى الوالد موجودًا. هذه حالة للمراجع الضعيفة!

لذلك، بدلاً من `Rc<T>`، سنجعل نوع `parent` يستخدم `Weak<T>`، على وجه التحديد `RefCell<Weak<Node>>`. الآن تعريف struct `Node` الخاص بنا يبدو كالتالي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:here}}
```

ستكون العقدة قادرة على الإشارة إلى عقدتها الأبوية لكنها لا تمتلك والدها. في القائمة 15-28، نحدّث `main` لاستخدام هذا التعريف الجديد بحيث يكون لعقدة `leaf` طريقة للإشارة إلى والدها، `branch`.

<Listing number="15-28" file-name="src/main.rs" caption="عقدة `leaf` مع مرجع ضعيف لعقدتها الأبوية، `branch`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:there}}
```

</Listing>

إنشاء عقدة `leaf` يبدو مشابهًا للقائمة 15-27 باستثناء حقل `parent`: تبدأ `leaf` بدون والد، لذلك ننشئ نسخة `Weak<Node>` جديدة فارغة.

في هذه المرحلة، عندما نحاول الحصول على مرجع لوالد `leaf` باستخدام وسيلة `upgrade`، نحصل على قيمة `None`. نرى هذا في المخرج من عبارة `println!` الأولى:

```text
leaf parent = None
```

عندما ننشئ عقدة `branch`، سيكون لديها أيضًا مرجع `Weak<Node>` جديد في حقل `parent` لأن `branch` ليس لديها عقدة أبوية. لا تزال لدينا `leaf` كأحد أطفال `branch`. بمجرد أن يكون لدينا نسخة `Node` في `branch`، يمكننا تعديل `leaf` لإعطائها مرجع `Weak<Node>` لوالدها. نستخدم وسيلة `borrow_mut` على `RefCell<Weak<Node>>` في حقل `parent` من `leaf`، ثم نستخدم دالة `Rc::downgrade` لإنشاء مرجع `Weak<Node>` لـ `branch` من `Rc<Node>` في `branch`.

عندما نطبع والد `leaf` مرة أخرى، هذه المرة سنحصل على متغير `Some` يحتفظ بـ `branch`: الآن يمكن لـ `leaf` الوصول إلى والدها! عندما نطبع `leaf`، نتجنب أيضًا الدورة التي انتهت في النهاية بتدفق المكدس كما حدث في القائمة 15-26؛ يتم طباعة مراجع `Weak<Node>` كـ `(Weak)`:

```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```

عدم وجود مخرج لا نهائي يشير إلى أن هذا الكود لم ينشئ دورة مرجع. يمكننا أيضًا معرفة ذلك من خلال النظر في القيم التي نحصل عليها من استدعاء `Rc::strong_count` و `Rc::weak_count`.

#### تصور التغييرات في `strong_count` و `weak_count`

دعنا ننظر في كيفية تغيير قيم `strong_count` و `weak_count` لنسخ `Rc<Node>` من خلال إنشاء نطاق داخلي جديد ونقل إنشاء `branch` إلى هذا النطاق. من خلال القيام بذلك، يمكننا أن نرى ما يحدث عند إنشاء `branch` ثم إسقاطها عندما تخرج عن النطاق. التعديلات موضحة في القائمة 15-29.

<Listing number="15-29" file-name="src/main.rs" caption="إنشاء `branch` في نطاق داخلي وفحص أعداد المراجع القوية والضعيفة">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-29/src/main.rs:here}}
```

</Listing>

بعد إنشاء `leaf`، لدى `Rc<Node>` الخاص بها عدد قوي من 1 وعدد ضعيف من 0. في النطاق الداخلي، ننشئ `branch` ونربطها بـ `leaf`، عند هذه النقطة عندما نطبع الأعداد، سيكون لدى `Rc<Node>` في `branch` عدد قوي من 1 وعدد ضعيف من 1 (لـ `leaf.parent` التي تشير إلى `branch` مع `Weak<Node>`). عندما نطبع الأعداد في `leaf`، سنرى أنها ستكون لديها عدد قوي من 2 لأن `branch` لديها الآن نسخة من `Rc<Node>` من `leaf` مخزنة في `branch.children` لكن سيكون لديها عدد ضعيف من 0.

عندما ينتهي النطاق الداخلي، تخرج `branch` عن النطاق وينخفض العدد القوي لـ `Rc<Node>` إلى 0، لذلك يتم إسقاط `Node` الخاص بها. العدد الضعيف 1 من `leaf.parent` ليس له تأثير على ما إذا كان سيتم إسقاط `Node` أم لا، لذلك لا نحصل على أي تسربات ذاكرة!

إذا حاولنا الوصول إلى والد `leaf` بعد نهاية النطاق، سنحصل على `None` مرة أخرى. في نهاية البرنامج، لدى `Rc<Node>` في `leaf` عدد قوي من 1 وعدد ضعيف من 0 لأن المتغير `leaf` هو الآن المرجع الوحيد لـ `Rc<Node>` مرة أخرى.

كل المنطق الذي يدير الأعداد وإسقاط القيمة مدمج في `Rc<T>` و `Weak<T>` وتنفيذاتهما لسِمة `Drop`. من خلال تحديد أن العلاقة من طفل إلى والده يجب أن تكون مرجع `Weak<T>` في تعريف `Node`، فإنك قادر على جعل العقد الأبوية تشير إلى العقد الفرعية والعكس بالعكس دون إنشاء دورة مرجع وتسربات ذاكرة.

## الملخص

يغطي هذا الفصل كيفية استخدام المؤشرات الذكية لتقديم ضمانات ومقايضات مختلفة عن تلك التي تقدمها Rust افتراضيًا بالمراجع العادية. نوع `Box<T>` له حجم معروف ويشير إلى البيانات المخصصة على الكومة. يتتبع نوع `Rc<T>` عدد المراجع للبيانات على الكومة بحيث يمكن أن يكون للبيانات مالكون متعددون. نوع `RefCell<T>` مع قابليته للتغيير الداخلية يمنحنا نوعًا يمكننا استخدامه عندما نحتاج إلى نوع غير قابل للتغيير ولكننا بحاجة لتغيير قيمة داخلية لهذا النوع؛ كما يفرض قواعد الاستعارة في وقت التشغيل بدلاً من وقت الترجمة.

تمت مناقشة سِمتي `Deref` و `Drop` أيضًا، اللتان تتيحان الكثير من وظائف المؤشرات الذكية. استكشفنا دورات المراجع التي يمكن أن تتسبب في تسربات ذاكرة وكيفية منعها باستخدام `Weak<T>`.

إذا أثار هذا الفصل اهتمامك وتريد تنفيذ مؤشراتك الذكية الخاصة، راجع ["The Rustonomicon"][nomicon] لمزيد من المعلومات المفيدة.

بعد ذلك، سنتحدث عن التزامن في Rust. ستتعلم حتى عن بعض المؤشرات الذكية الجديدة.

[nomicon]: ../nomicon/index.html
