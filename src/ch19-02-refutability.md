## قابلية الدحض: ما إذا كان النمط قد يفشل في المطابقة

تأتي الأنماط في شكلين: قابلة للدحض (refutable) وغير قابلة للدحض (irrefutable). الأنماط التي ستطابق أي قيمة ممكنة يتم تمريرها هي _غير قابلة للدحض_ (irrefutable). مثال على ذلك هو `x` في التعليمة `let x = 5;` لأن `x` تطابق أي شيء وبالتالي لا يمكن أن تفشل في المطابقة. الأنماط التي يمكن أن تفشل في المطابقة لبعض القيم الممكنة هي _قابلة للدحض_ (refutable). مثال على ذلك سيكون `Some(x)` في التعبير `if let Some(x) = a_value` لأنه إذا كانت القيمة في المتغير `a_value` هي `None` بدلاً من `Some`، فإن النمط `Some(x)` لن يطابق.

معاملات الدوال وتعليمات `let` وحلقات `for` يمكنها فقط قبول الأنماط غير القابلة للدحض لأن البرنامج لا يمكنه فعل أي شيء ذي معنى عندما لا تطابق القيم. تعبيرات `if let` و `while let` وتعليمة `let...else` تقبل الأنماط القابلة للدحض وغير القابلة للدحض، لكن المصرِّف يحذر من الأنماط غير القابلة للدحض لأنها، بحكم التعريف، مخصصة للتعامل مع الفشل المحتمل: وظيفة الشرط هي في قدرته على الأداء بشكل مختلف اعتمادًا على النجاح أو الفشل.

بشكل عام، لا يجب أن تقلق بشأن التمييز بين الأنماط القابلة للدحض وغير القابلة للدحض؛ ومع ذلك، تحتاج إلى أن تكون على دراية بمفهوم قابلية الدحض (refutability) حتى تتمكن من الرد عندما ترى ذلك في رسالة خطأ. في تلك الحالات، ستحتاج إلى تغيير إما النمط أو البنية التي تستخدم النمط معها، اعتمادًا على السلوك المقصود للكود.

لننظر إلى مثال على ما يحدث عندما نحاول استخدام نمط قابل للدحض حيث يتطلب Rust نمطًا غير قابل للدحض والعكس بالعكس. توضح القائمة 19-8 تعليمة `let`، ولكن بالنسبة للنمط، حددنا `Some(x)`، وهو نمط قابل للدحض. كما قد تتوقع، لن يتم ترجمة هذا الكود.

<Listing number="19-8" caption="محاولة استخدام نمط قابل للدحض مع `let`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-08/src/main.rs:here}}
```

</Listing>

إذا كانت `some_option_value` قيمة `None`، فإنها ستفشل في مطابقة النمط `Some(x)`، مما يعني أن النمط قابل للدحض. ومع ذلك، يمكن لتعليمة `let` قبول نمط غير قابل للدحض فقط لأنه لا يوجد شيء صالح يمكن للكود القيام به بقيمة `None`. في وقت الترجمة، سيشكو Rust من أننا حاولنا استخدام نمط قابل للدحض حيث يتطلب نمط غير قابل للدحض:

```console
{{#include ../listings/ch19-patterns-and-matching/listing-19-08/output.txt}}
```

لأننا لم نغط (ولا يمكننا تغطية!) كل قيمة صالحة بالنمط `Some(x)`، ينتج Rust بحق خطأ في المصرِّف.

إذا كان لدينا نمط قابل للدحض حيث يلزم نمط غير قابل للدحض، فيمكننا إصلاحه عن طريق تغيير الكود الذي يستخدم النمط: بدلاً من استخدام `let`، يمكننا استخدام `let else`. بعد ذلك، إذا لم يطابق النمط، فسيتخطى الكود فقط الكود في الأقواس المجعدة، مما يمنحه طريقة لمتابعة بشكل صالح. توضح القائمة 19-9 كيفية إصلاح الكود في القائمة 19-8.

<Listing number="19-9" caption="استخدام `let...else` وكتلة مع الأنماط القابلة للدحض بدلاً من `let`">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-09/src/main.rs:here}}
```

</Listing>

لقد أعطينا الكود مخرجًا! هذا الكود صالح تمامًا، على الرغم من أنه يعني أننا لا نستطيع استخدام نمط غير قابل للدحض بدون تلقي تحذير. إذا أعطينا `let...else` نمطًا سيطابق دائمًا، مثل `x`، كما هو موضح في القائمة 19-10، فسيعطي المصرِّف تحذيرًا.

<Listing number="19-10" caption="محاولة استخدام نمط غير قابل للدحض مع `let...else`">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-10/src/main.rs:here}}
```

</Listing>

يشتكي Rust من أنه لا معنى لاستخدام `let...else` مع نمط غير قابل للدحض:

```console
{{#include ../listings/ch19-patterns-and-matching/listing-19-10/output.txt}}
```

لهذا السبب، يجب أن تستخدم أذرع المطابقة أنماطًا قابلة للدحض، باستثناء الذراع الأخير، الذي يجب أن يطابق أي قيم متبقية بنمط غير قابل للدحض. يسمح لنا Rust باستخدام نمط غير قابل للدحض في `match` بذراع واحد فقط، ولكن هذا البناء الجملي ليس مفيدًا بشكل خاص ويمكن استبداله بتعليمة `let` أبسط.

الآن بعد أن عرفت أين تستخدم الأنماط والفرق بين الأنماط القابلة للدحض وغير القابلة للدحض، لنتطرق إلى جميع بناء الجملة التي يمكننا استخدامها لإنشاء الأنماط.
