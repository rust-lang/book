## نوع الشريحة (Slice Type)

_الشرائح (slices)_ تتيح لك الإشارة إلى تسلسل متصل من العناصر في
[مجموعة](ch08-00-common-collections.md)<!-- ignore -->. الشريحة (slice) هي نوع
من المرجع (reference)، لذلك ليس لها ملكية (ownership).

إليك مشكلة برمجية صغيرة: اكتب دالة تأخذ سلسلة نصية من
الكلمات المفصولة بمسافات وتعيد الكلمة الأولى التي تجدها في تلك السلسلة.
إذا لم تجد الدالة مسافة في السلسلة، فإن السلسلة بأكملها يجب أن تكون
كلمة واحدة، لذا يجب إرجاع السلسلة بأكملها.

> ملاحظة: لأغراض تقديم الشرائح، نفترض ASCII فقط في
> هذا القسم؛ مناقشة أكثر شمولاً لمعالجة UTF-8 موجودة في قسم
> [«تخزين نص مشفر بـ UTF-8 باستخدام السلاسل النصية»][strings]<!-- ignore -->
> من الفصل 8.

دعنا نعمل على كيفية كتابة توقيع هذه الدالة بدون استخدام
الشرائح، لفهم المشكلة التي ستحلها الشرائح:

```rust,ignore
fn first_word(s: &String) -> ?
```

دالة `first_word` لها معامل من نوع `&String`. لا نحتاج إلى
الملكية، لذا هذا جيد. (في Rust الاصطلاحية، لا تأخذ الدوال ملكية
وسائطها ما لم تحتاج إلى ذلك، والأسباب لذلك ستصبح
واضحة مع استمرارنا.) ولكن ماذا يجب أن نعيد؟ ليس لدينا حقاً طريقة
للتحدث عن _جزء_ من سلسلة نصية. ومع ذلك، يمكننا إرجاع فهرس نهاية
الكلمة، المشار إليه بمسافة. دعنا نجرب ذلك، كما هو موضح في القائمة 4-7.

<Listing number="4-7" file-name="src/main.rs" caption="دالة `first_word` التي تعيد قيمة فهرس البايت في معامل `String`">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
```

</Listing>

لأننا بحاجة إلى المرور عبر `String` عنصراً بعنصر والتحقق مما إذا كانت
القيمة مسافة، سنحول `String` إلى مصفوفة من البايتات باستخدام
طريقة `as_bytes`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}
```

بعد ذلك، ننشئ مكرراً عبر مصفوفة البايتات باستخدام طريقة `iter`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}
```

سنناقش المُكرِّرات بمزيد من التفصيل في [الفصل 13][ch13]<!-- ignore -->.
في الوقت الحالي، اعلم أن `iter` هي طريقة تعيد كل عنصر في مجموعة
وأن `enumerate` تغلف نتيجة `iter` وتعيد كل عنصر كجزء
من tuple بدلاً من ذلك. العنصر الأول من tuple المعاد من
`enumerate` هو الفهرس، والعنصر الثاني هو مرجع للعنصر.
هذا أكثر ملاءمة قليلاً من حساب الفهرس بأنفسنا.

لأن طريقة `enumerate` تعيد tuple، يمكننا استخدام الأنماط لتفكيك
ذلك الـ tuple. سنناقش الأنماط أكثر في [الفصل
6][ch6]<!-- ignore -->. في حلقة `for`، نحدد نمطاً له `i`
للفهرس في tuple و `&item` للبايت الواحد في tuple.
لأننا نحصل على مرجع للعنصر من `.iter().enumerate()`، نستخدم
`&` في النمط.

داخل حلقة `for`، نبحث عن البايت الذي يمثل المسافة باستخدام
صيغة البايت الحرفية. إذا وجدنا مسافة، نعيد الموضع.
وإلا، نعيد طول السلسلة باستخدام `s.len()`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}
```

لدينا الآن طريقة لمعرفة فهرس نهاية الكلمة الأولى في
السلسلة، ولكن هناك مشكلة. نحن نعيد `usize` بمفردها، لكنها
رقم ذو معنى فقط في سياق `&String`. بمعنى آخر،
لأنها قيمة منفصلة عن `String`، ليس هناك ضمان أنها
ستظل صالحة في المستقبل. اعتبر البرنامج في القائمة 4-8 الذي
يستخدم دالة `first_word` من القائمة 4-7.

<Listing number="4-8" file-name="src/main.rs" caption="تخزين النتيجة من استدعاء دالة `first_word` ثم تغيير محتويات `String`">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
```

</Listing>

يُترجم هذا البرنامج بدون أي أخطاء وسيفعل ذلك أيضاً إذا استخدمنا `word`
بعد استدعاء `s.clear()`. لأن `word` ليست متصلة بحالة `s`
على الإطلاق، لا تزال `word` تحتوي على القيمة `5`. يمكننا استخدام تلك القيمة `5` مع
المتغير `s` لمحاولة استخراج الكلمة الأولى، لكن هذا سيكون خطأ
لأن محتويات `s` تغيرت منذ أن حفظنا `5` في `word`.

الاضطرار إلى القلق بشأن فقدان الفهرس في `word` للتزامن مع البيانات في
`s` أمر ممل وعرضة للخطأ! إدارة هذه الفهارس أكثر هشاشة إذا
كتبنا دالة `second_word`. يجب أن يبدو توقيعها هكذا:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

الآن نتتبع فهرساً _للبداية_ والنهاية، ولدينا المزيد من
القيم التي تم حسابها من البيانات في حالة معينة ولكنها غير مرتبطة
بتلك الحالة على الإطلاق. لدينا ثلاثة متغيرات غير مرتبطة تطفو حولها تحتاج
إلى أن تبقى متزامنة.

لحسن الحظ، لدى Rust حل لهذه المشكلة: شرائح السلاسل النصية (string slices).

### شرائح السلاسل النصية (String Slices)

_شريحة السلسلة النصية (string slice)_ هي مرجع إلى تسلسل متصل من عناصر
`String`، وتبدو هكذا:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
```

بدلاً من مرجع إلى `String` بأكملها، `hello` هو مرجع إلى
جزء من `String`، محدد في الجزء الإضافي `[0..5]`. ننشئ الشرائح
باستخدام نطاق (range) داخل أقواس مربعة بتحديد
`[starting_index..ending_index]`، حيث _`starting_index`_ هو الموضع الأول
في الشريحة و _`ending_index`_ هو أكثر من الموضع الأخير بواحد
في الشريحة. داخلياً، يخزن هيكل بيانات الشريحة موضع البداية
وطول الشريحة، والذي يقابل _`ending_index`_ ناقص
_`starting_index`_. لذا، في حالة `let world = &s[6..11];`، ستكون `world`
شريحة تحتوي على مؤشر (pointer) إلى البايت في الفهرس 6 من `s` مع قيمة طول
`5`.

الشكل 4-7 يوضح هذا في مخطط.

<img alt="ثلاثة جداول: جدول يمثل بيانات المكدس لـ s، والذي يشير
إلى البايت في الفهرس 0 في جدول من بيانات السلسلة &quot;hello world&quot; على
الكومة. الجدول الثالث يمثل بيانات المكدس للشريحة world، والتي
لها قيمة طول 5 وتشير إلى البايت 6 من جدول بيانات الكومة."
src="img/trpl04-07.svg" class="center" style="width: 50%;" />

<span class="caption">الشكل 4-7: شريحة سلسلة نصية تشير إلى جزء من
`String`</span>

مع صيغة نطاق `..` في Rust، إذا كنت تريد البدء من الفهرس 0، يمكنك حذف
القيمة قبل النقطتين. بمعنى آخر، هذه متساوية:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

بالمثل، إذا كانت شريحتك تتضمن البايت الأخير من `String`، يمكنك
حذف الرقم الزائد. وهذا يعني أن هذه متساوية:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

يمكنك أيضاً حذف كلا القيمتين لأخذ شريحة من السلسلة بأكملها. لذا، هذه
متساوية:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> ملاحظة: يجب أن تحدث فهارس نطاق شريحة السلسلة النصية عند حدود أحرف UTF-8 صالحة.
> إذا حاولت إنشاء شريحة سلسلة نصية في منتصف
> حرف متعدد البايتات، سيخرج برنامجك بخطأ.

مع كل هذه المعلومات في الاعتبار، دعنا نعيد كتابة `first_word` لإرجاع
شريحة. النوع الذي يشير إلى «شريحة السلسلة النصية» مكتوب كـ `&str`:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
```

</Listing>

نحصل على فهرس نهاية الكلمة بنفس الطريقة التي فعلناها في القائمة 4-7، من خلال
البحث عن أول ظهور لمسافة. عندما نجد مسافة، نعيد
شريحة سلسلة نصية باستخدام بداية السلسلة وفهرس المسافة كفهارس
البداية والنهاية.

الآن عندما نستدعي `first_word`، نحصل على قيمة واحدة مرتبطة بالبيانات
الأساسية. تتكون القيمة من مرجع إلى نقطة البداية
للشريحة وعدد العناصر في الشريحة.

إرجاع شريحة سيعمل أيضاً لدالة `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

لدينا الآن واجهة برمجة تطبيقات مباشرة يصعب كثيراً إفسادها لأن
المصرِّف سيضمن أن المراجع (references) إلى `String` تظل صالحة.
تذكر الخطأ في البرنامج في القائمة 4-8، عندما حصلنا على الفهرس لنهاية
الكلمة الأولى ولكن بعد ذلك مسحنا السلسلة فأصبح فهرسنا غير صالح؟
كان هذا الكود غير صحيح منطقياً لكنه لم يظهر أي أخطاء فورية.
ستظهر المشاكل لاحقاً إذا استمررنا في محاولة استخدام فهرس الكلمة الأولى مع
سلسلة فارغة. تجعل الشرائح هذا الخطأ مستحيلاً وتخبرنا بشكل أسرع بكثير
أن لدينا مشكلة في كودنا. استخدام نسخة الشريحة من `first_word`
سيطرح خطأ وقت الترجمة:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}
```

</Listing>

إليك خطأ المصرِّف:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
```

تذكر من قواعد الاستعارة (borrowing) أنه إذا كان لدينا مرجع غير قابل للتعديل (immutable reference) لشيء
ما، لا يمكننا أيضاً أخذ مرجع قابل للتعديل (mutable reference). لأن `clear` تحتاج إلى
اقتطاع `String`، فإنها تحتاج إلى الحصول على مرجع قابل للتعديل. تستخدم `println!`
بعد الاستدعاء لـ `clear` المرجع في `word`، لذا يجب أن يكون المرجع غير القابل للتعديل
لا يزال نشطاً في تلك النقطة. لا تسمح Rust بالمرجع القابل للتعديل
في `clear` والمرجع غير القابل للتعديل في `word` من الوجود في
نفس الوقت، ويفشل الترجمة. لم تجعل Rust واجهة برمجة التطبيقات الخاصة بنا أسهل في الاستخدام فحسب،
بل أزالت أيضاً فئة كاملة من الأخطاء في وقت الترجمة!

<!-- Old headings. Do not remove or links may break. -->

<a id="string-literals-are-slices"></a>

#### السلاسل النصية الحرفية كشرائح (String Literals as Slices)

تذكر أننا تحدثنا عن تخزين السلاسل النصية الحرفية داخل الملف الثنائي. الآن
بعد أن نعرف عن الشرائح، يمكننا فهم السلاسل النصية الحرفية بشكل صحيح:

```rust
let s = "Hello, world!";
```

نوع `s` هنا هو `&str`: إنها شريحة (slice) تشير إلى تلك النقطة المحددة من
الملف الثنائي. هذا أيضاً لماذا السلاسل النصية الحرفية غير قابلة للتعديل؛ `&str` هو
مرجع غير قابل للتعديل.

#### شرائح السلاسل النصية كمعاملات (String Slices as Parameters)

معرفة أنه يمكنك أخذ شرائح من الحرفيات وقيم `String` تقودنا إلى
تحسين آخر على `first_word`، وهو توقيعها:

```rust,ignore
fn first_word(s: &String) -> &str {
```

سيكتب Rustacean أكثر خبرة التوقيع الموضح في القائمة 4-9
بدلاً من ذلك لأنه يسمح لنا باستخدام نفس الدالة على قيم `&String`
وقيم `&str`.

<Listing number="4-9" caption="تحسين دالة `first_word` باستخدام شريحة سلسلة نصية (string slice) لنوع معامل `s`">

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}
```

</Listing>

إذا كان لدينا شريحة سلسلة نصية (string slice)، يمكننا تمريرها مباشرة. إذا كان لدينا `String`، يمكننا
تمرير شريحة من `String` أو مرجع إلى `String`. تستفيد هذه
المرونة من إكراهات deref، وهي ميزة سنغطيها في
قسم [«استخدام إكراهات Deref في الدوال والطرق»][deref-coercions]<!--
ignore --> من الفصل 15.

تعريف دالة لأخذ شريحة سلسلة نصية (string slice) بدلاً من مرجع إلى `String`
يجعل واجهة برمجة التطبيقات الخاصة بنا أكثر عمومية وفائدة دون فقدان أي وظائف:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
```

</Listing>

### شرائح أخرى (Other Slices)

شرائح السلاسل النصية (string slices)، كما قد تتخيل، خاصة بالسلاسل النصية. ولكن هناك
نوع شريحة (slice) أكثر عمومية أيضاً. اعتبر هذا المصفوفة:

```rust
let a = [1, 2, 3, 4, 5];
```

تماماً كما قد نريد الإشارة إلى جزء من سلسلة نصية، قد نريد الإشارة إلى
جزء من مصفوفة. سنفعل ذلك هكذا:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

لهذه الشريحة النوع `&[i32]`. تعمل بنفس الطريقة التي تعمل بها شرائح السلاسل النصية، من خلال
تخزين مرجع إلى العنصر الأول وطول. ستستخدم هذا النوع من
الشريحة لجميع أنواع المجموعات الأخرى. سنناقش هذه المجموعات في
التفاصيل عندما نتحدث عن المتجهات في الفصل 8.

## الخلاصة

مفاهيم الملكية (ownership) والاستعارة (borrowing) والشرائح (slices) تضمن أمان الذاكرة (memory) في برامج Rust
في وقت الترجمة. تمنحك لغة Rust السيطرة على استخدامك للذاكرة
بنفس الطريقة التي تفعلها لغات برمجة الأنظمة الأخرى. ولكن امتلاك
مالك البيانات يقوم تلقائياً بتنظيف تلك البيانات عندما يخرج المالك عن النطاق (scope)
يعني أنك لست مضطراً لكتابة وتصحيح كود إضافي للحصول على هذه السيطرة.

تؤثر الملكية على كيفية عمل الكثير من الأجزاء الأخرى في Rust، لذا سنتحدث عن
هذه المفاهيم أكثر في جميع أنحاء بقية الكتاب. دعنا ننتقل إلى
الفصل 5 وننظر في ترجمة أجزاء من البيانات معاً في `struct`.

[ch13]: ch13-02-iterators.html
[ch6]: ch06-02-match.html#patterns-that-bind-to-values
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[deref-coercions]: ch15-02-deref.html#using-deref-coercions-in-functions-and-methods
