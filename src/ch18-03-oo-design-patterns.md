## تنفيذ نمط تصميم كائني التوجه

_نمط الحالة_ (state pattern) هو نمط تصميم (design pattern) كائني التوجه. جوهر النمط هو أننا نعرّف مجموعة من الحالات التي يمكن أن تكون لدى القيمة داخليًا. يتم تمثيل الحالات بمجموعة من _كائنات الحالة_ (state objects)، ويتغير سلوك القيمة بناءً على حالتها. سنعمل من خلال مثال لبنية منشور مدونة لها حقل لتخزين حالتها، والتي ستكون كائن حالة من المجموعة "مسودة" أو "مراجعة" أو "منشورة".

كائنات الحالة تشترك في الوظائف: في Rust، بالطبع، نستخدم البُنى والسِمات بدلاً من الكائنات والوراثة. كل كائن حالة مسؤول عن سلوكه الخاص وعن التحكم في متى يجب أن يتغير إلى حالة أخرى. القيمة التي تحتوي على كائن حالة لا تعرف شيئًا عن السلوك المختلف للحالات أو متى يجب الانتقال بين الحالات.

ميزة استخدام نمط الحالة هي أنه عندما تتغير متطلبات العمل للبرنامج، لن نحتاج إلى تغيير كود القيمة التي تحتوي على الحالة أو الكود الذي يستخدم القيمة. سنحتاج فقط إلى تحديث الكود داخل أحد كائنات الحالة لتغيير قواعدها أو ربما إضافة المزيد من كائنات الحالة.

أولاً، سنقوم بتنفيذ نمط الحالة بطريقة كائنية التوجه أكثر تقليدية. بعد ذلك، سنستخدم نهجًا أكثر طبيعية قليلاً في Rust. دعونا نتعمق في تنفيذ سير عمل منشور مدونة تدريجيًا باستخدام نمط الحالة.

ستبدو الوظيفة النهائية كما يلي:

1. يبدأ منشور المدونة كمسودة فارغة.
1. عندما تكتمل المسودة، يُطلب مراجعة للمنشور.
1. عندما تتم الموافقة على المنشور، يتم نشره.
1. فقط منشورات المدونة المنشورة تُرجع محتوى للطباعة بحيث لا يمكن نشر المنشورات غير المعتمدة عن طريق الخطأ.

أي تغييرات أخرى يتم محاولتها على منشور يجب ألا يكون لها تأثير. على سبيل المثال، إذا حاولنا الموافقة على مسودة منشور مدونة قبل أن نطلب مراجعة، يجب أن يظل المنشور مسودة غير منشورة.

<!-- Old headings. Do not remove or links may break. -->

<a id="a-traditional-object-oriented-attempt"></a>

### محاولة الأسلوب الكائني التوجه التقليدي

هناك طرق لا نهائية لهيكلة الكود لحل نفس المشكلة، ولكل منها مفاضلات مختلفة. تنفيذ هذا القسم هو أكثر من نمط كائني التوجه تقليدي، والذي يمكن كتابته في Rust، لكنه لا يستفيد من بعض نقاط قوة Rust. في وقت لاحق، سنعرض حلاً مختلفًا لا يزال يستخدم نمط التصميم الكائني التوجه ولكنه منظم بطريقة قد تبدو أقل مألوفة للمبرمجين ذوي الخبرة الكائنية التوجه. سنقارن الحلين لتجربة المفاضلات في تصميم كود Rust بشكل مختلف عن الكود في اللغات الأخرى.

القائمة 18-11 توضح سير العمل هذا في شكل كود: هذا مثال على استخدام واجهة برمجة التطبيقات التي سننفذها في صندوق مكتبة باسم `blog`. لن يتم تصريف هذا بعد لأننا لم ننفذ صندوق `blog` بعد.

<Listing number="18-11" file-name="src/main.rs" caption="الكود الذي يوضح السلوك المطلوب الذي نريد أن يكون لصندوق `blog` الخاص بنا">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-oop/listing-18-11/src/main.rs:all}}
```

</Listing>

نريد أن نسمح للمستخدم بإنشاء منشور مدونة مسودة جديد باستخدام `Post::new`. نريد السماح بإضافة نص إلى منشور المدونة. إذا حاولنا الحصول على محتوى المنشور فورًا، قبل الموافقة، يجب ألا نحصل على أي نص لأن المنشور لا يزال مسودة. لقد أضفنا `assert_eq!` في الكود لأغراض العرض. اختبار وحدة ممتاز لهذا سيكون التأكيد على أن منشور المدونة المسودة يُرجع سلسلة نصية فارغة من دالة `content`، لكننا لن نكتب اختبارات لهذا المثال.

بعد ذلك، نريد تمكين طلب مراجعة للمنشور، ونريد أن يُرجع `content` سلسلة نصية فارغة أثناء انتظار المراجعة. عندما يحصل المنشور على الموافقة، يجب نشره، مما يعني أن نص المنشور سيُرجع عند استدعاء `content`.

لاحظ أن النوع الوحيد الذي نتفاعل معه من الصندوق هو نوع `Post`. سيستخدم هذا النوع نمط الحالة وسيحتوي على قيمة ستكون واحدة من ثلاثة كائنات حالة تمثل الحالات المختلفة التي يمكن أن يكون المنشور فيها—مسودة، مراجعة، أو منشورة. ستتم إدارة التغيير من حالة إلى أخرى داخليًا ضمن نوع `Post`. تتغير الحالات استجابة للدوال المستدعاة من قبل مستخدمي مكتبتنا على نسخة `Post`، لكن ليس عليهم إدارة تغييرات الحالة مباشرة. أيضًا، لا يمكن للمستخدمين ارتكاب خطأ في الحالات، مثل نشر منشور قبل مراجعته.

<!-- Old headings. Do not remove or links may break. -->

<a id="defining-post-and-creating-a-new-instance-in-the-draft-state"></a>

#### تعريف `Post` وإنشاء نسخة جديدة

لنبدأ في تنفيذ المكتبة! نعلم أننا بحاجة إلى بنية `Post` عامة تحتوي على بعض المحتوى، لذا سنبدأ بتعريف البنية ودالة `new` عامة مرتبطة لإنشاء نسخة من `Post`، كما هو موضح في القائمة 18-12. سنقوم أيضًا بإنشاء سِمة `State` خاصة ستعرّف السلوك الذي يجب أن تمتلكه جميع كائنات الحالة لـ `Post`.

بعد ذلك، ستحتوي `Post` على كائن سِمة من `Box<dyn State>` داخل `Option<T>` في حقل خاص باسم `state` لتخزين كائن الحالة. ستفهم سبب ضرورة `Option<T>` بعد قليل.

<Listing number="18-12" file-name="src/lib.rs" caption="تعريف بنية `Post` ودالة `new` التي تنشئ نسخة `Post` جديدة، وسِمة `State`، وبنية `Draft`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-12/src/lib.rs}}
```

</Listing>

السِمة `State` تعرّف السلوك المشترك بين حالات المنشورات المختلفة. كائنات الحالة هي `Draft` و`PendingReview` و`Published`, وسينفذون جميعًا السِمة `State`. في الوقت الحالي، لا تحتوي السِمة على أي دوال، وسنبدأ بتعريف حالة `Draft` فقط لأن هذه هي الحالة التي نريد أن يبدأ بها المنشور.

عندما نقوم بإنشاء `Post` جديد، نقوم بتعيين حقل `state` الخاص به إلى قيمة `Some` تحتوي على `Box`. يشير هذا `Box` إلى نسخة جديدة من بنية `Draft`. هذا يضمن أنه كلما أنشأنا نسخة جديدة من `Post`، ستبدأ كمسودة. نظرًا لأن حقل `state` لـ `Post` خاص، لا توجد طريقة لإنشاء `Post` في أي حالة أخرى! في دالة `Post::new`، نقوم بتعيين حقل `content` إلى `String` فارغ جديد.

#### تخزين نص محتوى المنشور

رأينا في القائمة 18-11 أننا نريد أن نتمكن من استدعاء دالة باسم `add_text` وتمريرها `&str` يتم إضافتها بعد ذلك كمحتوى نصي لمنشور المدونة. ننفذ هذا كدالة، بدلاً من الكشف عن حقل `content` كـ `pub`، بحيث يمكننا لاحقًا تنفيذ دالة ستتحكم في كيفية قراءة بيانات حقل `content`. دالة `add_text` بسيطة للغاية، لذا دعونا نضيف التنفيذ في القائمة 18-13 إلى كتلة `impl Post`.

<Listing number="18-13" file-name="src/lib.rs" caption="تنفيذ دالة `add_text` لإضافة نص إلى `content` المنشور">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-13/src/lib.rs:here}}
```

</Listing>

تأخذ دالة `add_text` مرجعًا قابلاً للتغيير لـ `self` لأننا نقوم بتغيير نسخة `Post` التي نستدعي عليها `add_text`. ثم نستدعي `push_str` على `String` في `content` ونمرر معامل `text` لإضافته إلى `content` المحفوظ. لا يعتمد هذا السلوك على الحالة التي يكون فيها المنشور، لذا فهو ليس جزءًا من نمط الحالة. لا تتفاعل دالة `add_text` مع حقل `state` على الإطلاق، لكنها جزء من السلوك الذي نريد دعمه.

<!-- Old headings. Do not remove or links may break. -->

<a id="ensuring-the-content-of-a-draft-post-is-empty"></a>

#### التأكد من أن محتوى منشور المسودة فارغ

حتى بعد استدعاء `add_text` وإضافة بعض المحتوى إلى منشورنا، لا نزال نريد أن تُرجع دالة `content` شريحة سلسلة نصية فارغة لأن المنشور لا يزال في حالة المسودة، كما هو موضح في أول `assert_eq!` في القائمة 18-11. في الوقت الحالي، دعونا ننفذ دالة `content` بأبسط شيء سيفي بهذا المتطلب: إرجاع شريحة سلسلة نصية فارغة دائمًا. سنغير هذا لاحقًا بمجرد تنفيذ القدرة على تغيير حالة المنشور بحيث يمكن نشره. حتى الآن، يمكن للمنشورات أن تكون في حالة المسودة فقط، لذا يجب أن يكون محتوى المنشور فارغًا دائمًا. القائمة 18-14 توضح هذا التنفيذ المؤقت.

<Listing number="18-14" file-name="src/lib.rs" caption="إضافة تنفيذ مؤقت لدالة `content` على `Post` تُرجع دائمًا شريحة سلسلة نصية فارغة">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-14/src/lib.rs:here}}
```

</Listing>

مع دالة `content` المضافة هذه، كل شيء في القائمة 18-11 حتى أول `assert_eq!` يعمل كما هو مقصود.

<!-- Old headings. Do not remove or links may break. -->

<a id="requesting-a-review-of-the-post-changes-its-state"></a>
<a id="requesting-a-review-changes-the-posts-state"></a>

#### طلب مراجعة، والذي يغير حالة المنشور

بعد ذلك، نحتاج إلى إضافة وظيفة لطلب مراجعة لمنشور، والتي يجب أن تغير حالته من `Draft` إلى `PendingReview`. القائمة 18-15 توضح هذا الكود.

<Listing number="18-15" file-name="src/lib.rs" caption="تنفيذ دوال `request_review` على `Post` والسِمة `State`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-15/src/lib.rs:here}}
```

</Listing>

نعطي `Post` دالة عامة باسم `request_review` ستأخذ مرجعًا قابلاً للتغيير لـ `self`. ثم نستدعي دالة `request_review` داخلية على الحالة الحالية لـ `Post`، وهذه الدالة `request_review` الثانية تستهلك الحالة الحالية وتُرجع حالة جديدة.

نضيف دالة `request_review` إلى السِمة `State`؛ جميع الأنواع التي تُنفذ السِمة ستحتاج الآن إلى تنفيذ دالة `request_review`. لاحظ أنه بدلاً من وجود `self` أو `&self` أو `&mut self` كمعامل أول للدالة، لدينا `self: Box<Self>`. تعني هذه الصياغة أن الدالة صالحة فقط عند استدعائها على `Box` يحتوي على النوع. تأخذ هذه الصياغة ملكية (ownership) `Box<Self>`، مما يُبطل الحالة القديمة بحيث يمكن أن تتحول قيمة الحالة لـ `Post` إلى حالة جديدة.

لاستهلاك الحالة القديمة، تحتاج دالة `request_review` إلى أخذ ملكية قيمة الحالة. هنا يأتي دور `Option` في حقل `state` لـ `Post`: نستدعي دالة `take` لأخذ قيمة `Some` من حقل `state` وترك `None` في مكانه لأن Rust لا يسمح لنا بوجود حقول غير مملوءة في البُنى. هذا يتيح لنا نقل قيمة `state` خارج `Post` بدلاً من استعارتها. بعد ذلك، سنقوم بتعيين قيمة `state` للمنشور إلى نتيجة هذه العملية.

نحتاج إلى تعيين `state` إلى `None` مؤقتًا بدلاً من تعيينه مباشرة بكود مثل `self.state = self.state.request_review();` للحصول على ملكية قيمة `state`. هذا يضمن أن `Post` لا يمكنها استخدام قيمة `state` القديمة بعد أن قمنا بتحويلها إلى حالة جديدة.

دالة `request_review` على `Draft` تُرجع نسخة جديدة ومُحزمة من بنية `PendingReview` جديدة، والتي تمثل الحالة عندما يكون المنشور في انتظار المراجعة. تُنفذ بنية `PendingReview` أيضًا دالة `request_review` لكنها لا تقوم بأي تحويلات. بدلاً من ذلك، تُرجع نفسها لأنه عندما نطلب مراجعة على منشور في حالة `PendingReview` بالفعل، يجب أن يبقى في حالة `PendingReview`.

الآن يمكننا البدء في رؤية مزايا نمط الحالة: دالة `request_review` على `Post` هي نفسها بغض النظر عن قيمة `state` الخاصة بها. كل حالة مسؤولة عن قواعدها الخاصة.

سنترك دالة `content` على `Post` كما هي، تُرجع شريحة سلسلة نصية فارغة. يمكن أن يكون لدينا الآن `Post` في حالة `PendingReview` وكذلك في حالة `Draft`، لكننا نريد نفس السلوك في حالة `PendingReview`. القائمة 18-11 الآن تعمل حتى ثاني `assert_eq!`!

<!-- Old headings. Do not remove or links may break. -->

<a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a>
<a id="adding-approve-to-change-the-behavior-of-content"></a>

#### إضافة `approve` لتغيير سلوك `content`

ستكون دالة `approve` مشابهة لدالة `request_review`: ستقوم بتعيين `state` إلى القيمة التي تقول الحالة الحالية أنها يجب أن تكون عليها عند الموافقة على تلك الحالة، كما هو موضح في القائمة 18-16.

<Listing number="18-16" file-name="src/lib.rs" caption="تنفيذ دالة `approve` على `Post` والسِمة `State`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-16/src/lib.rs:here}}
```

</Listing>

نضيف دالة `approve` إلى السِمة `State` ونضيف بنية جديدة تُنفذ `State`، وهي حالة `Published`.

على غرار طريقة عمل `request_review` على `PendingReview`، إذا استدعينا دالة `approve` على `Draft`، لن يكون لها أي تأثير لأن `approve` ستُرجع `self`. عندما نستدعي `approve` على `PendingReview`، تُرجع نسخة جديدة ومُحزمة من بنية `Published`. تُنفذ بنية `Published` السِمة `State`، ولكل من دالة `request_review` ودالة `approve`، تُرجع نفسها لأن المنشور يجب أن يبقى في حالة `Published` في تلك الحالات.

الآن نحتاج إلى تحديث دالة `content` على `Post`. نريد أن تعتمد القيمة المُرجعة من `content` على الحالة الحالية لـ `Post`، لذا سنجعل `Post` تُفوّض إلى دالة `content` معرّفة على `state` الخاصة بها، كما هو موضح في القائمة 18-17.

<Listing number="18-17" file-name="src/lib.rs" caption="تحديث دالة `content` على `Post` للتفويض إلى دالة `content` على `State`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-oop/listing-18-17/src/lib.rs:here}}
```

</Listing>

نظرًا لأن الهدف هو الحفاظ على جميع هذه القواعد داخل البُنى التي تُنفذ `State`، نستدعي دالة `content` على القيمة في `state` ونمرر نسخة المنشور (أي `self`) كمعامل. بعد ذلك، نُرجع القيمة التي يتم إرجاعها من استخدام دالة `content` على قيمة `state`.

نستدعي دالة `as_ref` على `Option` لأننا نريد مرجعًا إلى القيمة داخل `Option` بدلاً من ملكية القيمة. نظرًا لأن `state` هو `Option<Box<dyn State>>`، عندما نستدعي `as_ref`، يتم إرجاع `Option<&Box<dyn State>>`. إذا لم نستدعِ `as_ref`، فسنحصل على خطأ لأننا لا نستطيع نقل `state` خارج `&self` المُستعارة لمعامل الدالة.

ثم نستدعي دالة `unwrap`، والتي نعلم أنها لن تُسبب ذعرًا (panic) أبدًا لأننا نعلم أن الدوال على `Post` تضمن أن `state` ستحتوي دائمًا على قيمة `Some` عندما تنتهي تلك الدوال. هذه إحدى الحالات التي تحدثنا عنها في قسم ["عندما يكون لديك معلومات أكثر من المُصرف"][more-info-than-rustc]<!-- ignore --> في الفصل 9 عندما نعلم أن قيمة `None` غير ممكنة أبدًا، على الرغم من أن المُصرف غير قادر على فهم ذلك.

في هذه المرحلة، عندما نستدعي `content` على `&Box<dyn State>`، ستحدث إكراه فك المرجع (deref coercion) على `&` و`Box` بحيث ستُستدعى دالة `content` في النهاية على النوع الذي يُنفذ السِمة `State`. وهذا يعني أننا بحاجة إلى إضافة `content` إلى تعريف السِمة `State`، وهنا سنضع المنطق للمحتوى الذي يجب إرجاعه اعتمادًا على الحالة التي لدينا، كما هو موضح في القائمة 18-18.

<Listing number="18-18" file-name="src/lib.rs" caption="إضافة دالة `content` إلى السِمة `State`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-18/src/lib.rs:here}}
```

</Listing>

نضيف تنفيذًا افتراضيًا لدالة `content` التي تُرجع شريحة سلسلة نصية فارغة. وهذا يعني أننا لا نحتاج إلى تنفيذ `content` على بنيتي `Draft` و`PendingReview`. ستتجاوز بنية `Published` دالة `content` وتُرجع القيمة في `post.content`. بينما يكون هذا مريحًا، فإن وجود دالة `content` على `State` لتحديد محتوى `Post` يُطمس الخطوط بين مسؤولية `State` ومسؤولية `Post`.

لاحظ أننا بحاجة إلى تعليقات توضيحية لمدة الحياة (lifetime annotations) على هذه الدالة، كما ناقشنا في الفصل 10. نأخذ مرجعًا إلى `post` كمعامل ونُرجع مرجعًا إلى جزء من ذلك `post`، لذا فإن مدة حياة المرجع المُرجع مرتبطة بمدة حياة معامل `post`.

وقد انتهينا—كل القائمة 18-11 الآن تعمل! لقد نفذنا نمط الحالة مع قواعد سير عمل منشور المدونة. المنطق المتعلق بالقواعد يعيش في كائنات الحالة بدلاً من أن يكون مبعثرًا في جميع أنحاء `Post`.

> ### لماذا لا تعداد؟
>
> ربما كنت تتساءل لماذا لم نستخدم تعدادًا مع حالات المنشور المختلفة المحتملة كمتغيرات. هذا بالتأكيد حل محتمل؛ جربه وقارن النتائج النهائية لترى أيهما تفضل! أحد عيوب استخدام تعداد هو أن كل مكان يتحقق من قيمة التعداد سيحتاج إلى تعبير `match` أو ما شابه للتعامل مع كل متغير محتمل. قد يصبح هذا أكثر تكرارًا من حل كائن السِمة هذا.

<!-- Old headings. Do not remove or links may break. -->

<a id="trade-offs-of-the-state-pattern"></a>

#### تقييم نمط الحالة

لقد أظهرنا أن Rust قادرة على تنفيذ نمط الحالة الكائني التوجه لتغليف الأنواع المختلفة من السلوك التي يجب أن يمتلكها المنشور في كل حالة. الدوال على `Post` لا تعرف شيئًا عن السلوكيات المختلفة. بسبب الطريقة التي نظمنا بها الكود، يتعين علينا النظر في مكان واحد فقط لمعرفة الطرق المختلفة التي يمكن أن يتصرف بها منشور منشور: تنفيذ السِمة `State` على بنية `Published`.

إذا كنا سننشئ تنفيذًا بديلاً لا يستخدم نمط الحالة، فقد نستخدم بدلاً من ذلك تعبيرات `match` في الدوال على `Post` أو حتى في كود `main` الذي يتحقق من حالة المنشور ويغير السلوك في تلك الأماكن. وهذا يعني أننا سنضطر إلى النظر في عدة أماكن لفهم جميع آثار كون المنشور في حالة النشر.

مع نمط الحالة، لا تحتاج دوال `Post` والأماكن التي نستخدم فيها `Post` إلى تعبيرات `match`، ولإضافة حالة جديدة، سنحتاج فقط إلى إضافة بنية جديدة وتنفيذ دوال السِمة على تلك البنية في مكان واحد.

التنفيذ باستخدام نمط الحالة سهل التوسيع لإضافة المزيد من الوظائف. لرؤية بساطة صيانة الكود الذي يستخدم نمط الحالة، جرب بعض هذه الاقتراحات:

- أضف دالة `reject` تغير حالة المنشور من `PendingReview` مرة أخرى إلى `Draft`.
- تتطلب استدعائين لـ `approve` قبل أن يمكن تغيير الحالة إلى `Published`.
- السماح للمستخدمين بإضافة محتوى نصي فقط عندما يكون المنشور في حالة `Draft`. تلميح: اجعل كائن الحالة مسؤولاً عما قد يتغير بشأن المحتوى ولكن ليس مسؤولاً عن تعديل `Post`.

أحد عيوب نمط الحالة هو أنه نظرًا لأن الحالات تُنفذ الانتقالات بين الحالات، فإن بعض الحالات مقترنة ببعضها البعض. إذا أضفنا حالة أخرى بين `PendingReview` و`Published`، مثل `Scheduled`، فسيتعين علينا تغيير الكود في `PendingReview` للانتقال إلى `Scheduled` بدلاً من ذلك. سيكون العمل أقل إذا لم تكن `PendingReview` بحاجة إلى التغيير مع إضافة حالة جديدة، لكن ذلك سيعني التبديل إلى نمط تصميم آخر.

عيب آخر هو أننا كررنا بعض المنطق. للقضاء على بعض التكرار، قد نحاول إنشاء تنفيذات افتراضية لدوال `request_review` و`approve` على السِمة `State` التي تُرجع `self`. ومع ذلك، لن ينجح هذا: عند استخدام `State` ككائن سِمة، لا تعرف السِمة ما سيكون `self` المحدد بالضبط، لذا فإن نوع الإرجاع غير معروف في وقت التصريف. (هذه إحدى قواعد توافق dyn المذكورة سابقًا.)

التكرار الآخر يتضمن التنفيذات المتشابهة لدوال `request_review` و`approve` على `Post`. كلتا الدالتين تستخدمان `Option::take` مع حقل `state` لـ `Post`، وإذا كان `state` هو `Some`، تُفوّضان إلى تنفيذ القيمة المُغلفة لنفس الدالة وتُعيّنان القيمة الجديدة لحقل `state` إلى النتيجة. إذا كان لدينا الكثير من الدوال على `Post` التي تتبع هذا النمط، فقد نفكر في تعريف ماكرو للقضاء على التكرار (انظر قسم ["الماكرو"][macros]<!-- ignore --> في الفصل 20).

من خلال تنفيذ نمط الحالة بالضبط كما هو معرف للغات الكائنية التوجه، لا نستفيد من نقاط قوة Rust بشكل كامل كما يمكننا. دعونا ننظر إلى بعض التغييرات التي يمكننا إجراؤها على صندوق `blog` والتي يمكن أن تجعل الحالات والانتقالات غير الصالحة أخطاء في وقت التصريف.

### ترميز الحالات والسلوك كأنواع

سنوضح لك كيفية إعادة التفكير في نمط الحالة للحصول على مجموعة مختلفة من المفاضلات. بدلاً من تغليف الحالات والانتقالات تمامًا بحيث لا يكون للكود الخارجي معرفة بها، سنقوم بترميز الحالات في أنواع مختلفة. وبالتالي، سيمنع نظام التحقق من النوع في Rust محاولات استخدام منشورات المسودة حيث يُسمح فقط بالمنشورات المنشورة من خلال إصدار خطأ مُصرف.

دعونا ننظر في الجزء الأول من `main` في القائمة 18-11:

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-18-11/src/main.rs:here}}
```

</Listing>

لا نزال نُمكّن إنشاء منشورات جديدة في حالة المسودة باستخدام `Post::new` والقدرة على إضافة نص إلى محتوى المنشور. لكن بدلاً من وجود دالة `content` على منشور المسودة تُرجع سلسلة نصية فارغة، سنجعل منشورات المسودة لا تحتوي على دالة `content` على الإطلاق. بهذه الطريقة، إذا حاولنا الحصول على محتوى منشور المسودة، فسنحصل على خطأ مُصرف يخبرنا أن الدالة غير موجودة. نتيجة لذلك، سيكون من المستحيل لنا أن نعرض عن طريق الخطأ محتوى منشور المسودة في الإنتاج لأن هذا الكود لن يُصرّف حتى. القائمة 18-19 توضح تعريف بنية `Post` وبنية `DraftPost`، وكذلك الدوال على كل منهما.

<Listing number="18-19" file-name="src/lib.rs" caption="`Post` مع دالة `content` و`DraftPost` بدون دالة `content`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-19/src/lib.rs}}
```

</Listing>

كلتا بنيتي `Post` و`DraftPost` لديهما حقل `content` خاص يخزن نص منشور المدونة. لم تعد البُنى تحتوي على حقل `state` لأننا ننقل ترميز الحالة إلى أنواع البُنى. ستمثل بنية `Post` منشورًا منشورًا، ولديها دالة `content` تُرجع `content`.

لا يزال لدينا دالة `Post::new`، لكن بدلاً من إرجاع نسخة من `Post`، تُرجع نسخة من `DraftPost`. نظرًا لأن `content` خاص ولا توجد دوال تُرجع `Post`، فليس من الممكن إنشاء نسخة من `Post` الآن.

بنية `DraftPost` لديها دالة `add_text`، لذا يمكننا إضافة نص إلى `content` كما كان من قبل، لكن لاحظ أن `DraftPost` لا تحتوي على دالة `content` معرّفة! لذا الآن يضمن البرنامج أن جميع المنشورات تبدأ كمنشورات مسودة، ولا يوجد محتوى متاح لمنشورات المسودة للعرض. أي محاولة للتحايل على هذه القيود ستؤدي إلى خطأ مُصرف.

<!-- Old headings. Do not remove or links may break. -->

<a id="implementing-transitions-as-transformations-into-different-types"></a>

إذن، كيف نحصل على منشور منشور؟ نريد فرض القاعدة بأن منشور المسودة يجب أن يتم مراجعته والموافقة عليه قبل أن يمكن نشره. منشور في حالة المراجعة المعلقة يجب ألا يعرض أي محتوى. دعونا ننفذ هذه القيود عن طريق إضافة بنية أخرى، `PendingReviewPost`، وتعريف دالة `request_review` على `DraftPost` لإرجاع `PendingReviewPost` وتعريف دالة `approve` على `PendingReviewPost` لإرجاع `Post`، كما هو موضح في القائمة 18-20.

<Listing number="18-20" file-name="src/lib.rs" caption="`PendingReviewPost` الذي يتم إنشاؤه باستدعاء `request_review` على `DraftPost` ودالة `approve` التي تُحوّل `PendingReviewPost` إلى `Post` منشور">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-20/src/lib.rs:here}}
```

</Listing>

دالتا `request_review` و`approve` تأخذان ملكية `self`، وبالتالي تستهلكان نسخ `DraftPost` و`PendingReviewPost` وتُحوّلانهما إلى `PendingReviewPost` و`Post` منشور، على التوالي. بهذه الطريقة، لن يكون لدينا أي نسخ `DraftPost` باقية بعد أن نستدعي `request_review` عليها، وهكذا. لا تحتوي بنية `PendingReviewPost` على دالة `content` معرّفة عليها، لذا فإن محاولة قراءة محتواها تؤدي إلى خطأ مُصرف، كما هو الحال مع `DraftPost`. نظرًا لأن الطريقة الوحيدة للحصول على نسخة `Post` منشورة لها دالة `content` معرّفة هي استدعاء دالة `approve` على `PendingReviewPost`، والطريقة الوحيدة للحصول على `PendingReviewPost` هي استدعاء دالة `request_review` على `DraftPost`، فقد قمنا الآن بترميز سير عمل منشور المدونة في نظام الأنواع.

لكن يتعين علينا أيضًا إجراء بعض التغييرات الصغيرة على `main`. دالتا `request_review` و`approve` تُرجعان نسخًا جديدة بدلاً من تعديل البنية التي يتم استدعاؤهما عليها، لذا نحتاج إلى إضافة المزيد من تعيينات إخفاء `let post =` (shadowing) لحفظ النسخ المُرجعة. كما لا يمكننا أن نمتلك التأكيدات حول محتويات منشورات المسودة والمراجعة المعلقة كونها سلاسل نصية فارغة، ولا نحتاج إليها: لا يمكننا تصريف كود يحاول استخدام محتوى المنشورات في تلك الحالات بعد الآن. الكود المُحدّث في `main` موضح في القائمة 18-21.

<Listing number="18-21" file-name="src/main.rs" caption="التعديلات على `main` لاستخدام التنفيذ الجديد لسير عمل منشور المدونة">

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-18-21/src/main.rs}}
```

</Listing>

التغييرات التي كان علينا إجراؤها على `main` لإعادة تعيين `post` تعني أن هذا التنفيذ لا يتبع نمط الحالة الكائني التوجه بالضبط بعد الآن: لم تعد التحويلات بين الحالات مُغلّفة بالكامل داخل تنفيذ `Post`. ومع ذلك، فإن مكسبنا هو أن الحالات غير الصالحة الآن مستحيلة بسبب نظام الأنواع والتحقق من النوع الذي يحدث في وقت التصريف! هذا يضمن اكتشاف أخطاء معينة، مثل عرض محتوى منشور غير منشور، قبل وصولها إلى الإنتاج.

جرب المهام المقترحة في بداية هذا القسم على صندوق `blog` كما هو بعد القائمة 18-21 لترى ما تعتقده حول تصميم هذا الإصدار من الكود. لاحظ أن بعض المهام قد تكون قد اكتملت بالفعل في هذا التصميم.

لقد رأينا أنه على الرغم من أن Rust قادرة على تنفيذ أنماط التصميم الكائنية التوجه، فإن أنماطًا أخرى، مثل ترميز الحالة في نظام الأنواع، متاحة أيضًا في Rust. هذه الأنماط لها مفاضلات مختلفة. على الرغم من أنك قد تكون على دراية كبيرة بالأنماط الكائنية التوجه، فإن إعادة التفكير في المشكلة للاستفادة من ميزات Rust يمكن أن توفر فوائد، مثل منع بعض الأخطاء في وقت التصريف. لن تكون الأنماط الكائنية التوجه دائمًا أفضل حل في Rust بسبب ميزات معينة، مثل الملكية (ownership)، التي لا تمتلكها اللغات الكائنية التوجه.

## الخلاصة

بغض النظر عما إذا كنت تعتقد أن Rust هي لغة كائنية التوجه بعد قراءة هذا الفصل، فأنت تعلم الآن أنه يمكنك استخدام كائنات السِمة للحصول على بعض ميزات البرمجة الكائنية التوجه في Rust. يمكن أن يمنح الإرسال الديناميكي كودك بعض المرونة مقابل القليل من أداء وقت التشغيل. يمكنك استخدام هذه المرونة لتنفيذ أنماط كائنية التوجه يمكن أن تساعد في قابلية صيانة كودك. لدى Rust أيضًا ميزات أخرى، مثل الملكية، التي لا تمتلكها اللغات الكائنية التوجه. لن يكون النمط الكائني التوجه دائمًا أفضل طريقة للاستفادة من نقاط قوة Rust، لكنه خيار متاح.

بعد ذلك، سننظر إلى الأنماط (patterns)، وهي ميزة أخرى من ميزات Rust التي تُمكّن الكثير من المرونة. لقد نظرنا إليها بإيجاز في جميع أنحاء الكتاب لكننا لم نرَ قدرتها الكاملة بعد. لنذهب!

[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler
[macros]: ch20-05-macros.html#macros
