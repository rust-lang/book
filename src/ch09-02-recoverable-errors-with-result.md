## الأخطاء القابلة للاسترداد مع `Result`

معظم الأخطاء ليست خطيرة بما يكفي لتتطلب إيقاف البرنامج بالكامل.
في بعض الأحيان عندما تفشل دالة، يكون ذلك لسبب يمكنك تفسيره بسهولة
والاستجابة له. على سبيل المثال، إذا حاولت فتح ملف وفشلت تلك العملية
لأن الملف غير موجود، قد ترغب في إنشاء الملف بدلاً من
إنهاء العملية.

تذكر من ["معالجة الفشل المحتمل مع `Result`"][handle_failure]<!--
ignore --> في الفصل 2 أن enum `Result` معرّف بأن له متغيرين
هما `Ok` و `Err`، كما يلي:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` و `E` هما معاملات نوع عامة: سنناقش الأنواع العامة بمزيد من
التفاصيل في الفصل 10. ما تحتاج إلى معرفته الآن هو أن `T` يمثل
نوع القيمة التي سيتم إرجاعها في حالة النجاح ضمن متغير `Ok`،
و `E` يمثل نوع الخطأ الذي سيتم إرجاعه في
حالة الفشل ضمن متغير `Err`. ولأن `Result` لديه هذه المعاملات
العامة، يمكننا استخدام نوع `Result` والدوال المعرفة عليه في
العديد من الحالات المختلفة حيث قد تختلف قيمة النجاح وقيمة الخطأ التي نريد
إرجاعها.

لنستدعِ دالة تُرجع قيمة `Result` لأن الدالة قد
تفشل. في القائمة 9-3، نحاول فتح ملف.

<Listing number="9-3" file-name="src/main.rs" caption="فتح ملف">

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
```

</Listing>

نوع الإرجاع لـ `File::open` هو `Result<T, E>`. المعامل العام `T`
تم ملؤه من قبل تطبيق `File::open` بنوع قيمة
النجاح، وهو `std::fs::File`، الذي يمثل معالج ملف. نوع `E` المستخدم في
قيمة الخطأ هو `std::io::Error`. يعني نوع الإرجاع هذا أن الاستدعاء لـ
`File::open` قد ينجح ويُرجع معالج ملف يمكننا القراءة منه أو
الكتابة إليه. قد تفشل استدعاء الدالة أيضًا: على سبيل المثال، قد لا يكون الملف
موجودًا، أو قد لا يكون لدينا إذن للوصول إلى الملف. تحتاج دالة `File::open`
إلى طريقة لإخبارنا بنجاحها أو فشلها وفي
نفس الوقت تعطينا إما معالج الملف أو معلومات الخطأ. هذه
المعلومات هي بالضبط ما ينقله enum `Result`.

في الحالة التي ينجح فيها `File::open`، ستكون القيمة في المتغير
`greeting_file_result` نسخة من `Ok` تحتوي على معالج ملف.
في الحالة التي يفشل فيها، ستكون القيمة في `greeting_file_result`
نسخة من `Err` تحتوي على مزيد من المعلومات حول نوع الخطأ الذي
حدث.

نحتاج إلى إضافة إلى الكود في القائمة 9-3 لاتخاذ إجراءات مختلفة اعتمادًا
على القيمة التي يُرجعها `File::open`. تُظهر القائمة 9-4 طريقة واحدة للتعامل مع
`Result` باستخدام أداة أساسية، وهي تعبير `match` الذي ناقشناه في
الفصل 6.

<Listing number="9-4" file-name="src/main.rs" caption="استخدام تعبير `match` للتعامل مع متغيرات `Result` التي قد يتم إرجاعها">

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}
```

</Listing>

لاحظ أنه، مثل enum `Option`، تم إحضار enum `Result` ومتغيراته
إلى النطاق بواسطة الprelude، لذا لسنا بحاجة إلى تحديد `Result::`
قبل متغيري `Ok` و `Err` في أذرع `match`.

عندما تكون النتيجة `Ok`، سيُرجع هذا الكود قيمة `file` الداخلية من
متغير `Ok`، ثم نعيّن قيمة معالج الملف تلك إلى المتغير
`greeting_file`. بعد `match`، يمكننا استخدام معالج الملف للقراءة أو
الكتابة.

الذراع الآخر من `match` يتعامل مع الحالة التي نحصل فيها على قيمة `Err` من
`File::open`. في هذا المثال، اخترنا استدعاء ماكرو `panic!`. إذا
لم يكن هناك ملف باسم _hello.txt_ في دليلنا الحالي وشغّلنا هذا
الكود، سنرى المخرجات التالية من ماكرو `panic!`:

```console
{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
```

كالعادة، يخبرنا هذا المخرج بالضبط بما حدث من خطأ.

### المطابقة على أخطاء مختلفة

الكود في القائمة 9-4 سيستدعي `panic!` بغض النظر عن سبب فشل `File::open`.
ومع ذلك، نريد اتخاذ إجراءات مختلفة لأسباب فشل مختلفة. إذا
فشل `File::open` لأن الملف غير موجود، نريد إنشاء الملف
وإرجاع المعالج إلى الملف الجديد. إذا فشل `File::open` لأي سبب
آخر—على سبيل المثال، لأننا لم يكن لدينا إذن لفتح الملف—نريد ما زلنا
أن يستدعي الكود `panic!` بنفس الطريقة التي كان يفعلها في القائمة 9-4. لهذا، نضيف
تعبير `match` داخلي، كما هو موضح في القائمة 9-5.

<Listing number="9-5" file-name="src/main.rs" caption="معالجة أنواع مختلفة من الأخطاء بطرق مختلفة">

<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}
```

</Listing>

نوع القيمة التي يُرجعها `File::open` داخل متغير `Err` هو
`io::Error`، وهو struct مقدم من المكتبة القياسية. يحتوي هذا struct
على method يُسمى `kind`، يمكننا استدعاؤه للحصول على قيمة `io::ErrorKind`. ال
enum `io::ErrorKind` مقدم من المكتبة القياسية وله متغيرات
تمثل الأنواع المختلفة من الأخطاء التي قد تنتج عن عملية `io`.
المتغير الذي نريد استخدامه هو `ErrorKind::NotFound`، الذي يشير إلى
أن الملف الذي نحاول فتحه غير موجود بعد. لذا، نطابق على
`greeting_file_result`، ولكن لدينا أيضًا match داخلي على `error.kind()`.

الشرط الذي نريد التحقق منه في ال match الداخلي هو ما إذا كانت القيمة المُرجعة
من `error.kind()` هي متغير `NotFound` من enum `ErrorKind`. إذا كانت كذلك،
نحاول إنشاء الملف باستخدام `File::create`. ومع ذلك، لأن `File::create`
قد يفشل أيضًا، نحتاج إلى ذراع ثانٍ في تعبير `match` الداخلي. عندما لا يمكن
إنشاء الملف، تُطبع رسالة خطأ مختلفة. الذراع الثاني من
`match` الخارجي يبقى كما هو، لذا يحدث panic في البرنامج عند أي خطأ بخلاف
خطأ الملف المفقود.

> #### بدائل لاستخدام `match` مع `Result<T, E>`
>
> هذا الكثير من `match`! تعبير `match` مفيد جدًا ولكنه أيضًا
> بدائي للغاية. في الفصل 13، ستتعلم عن closures، والتي تُستخدم
> مع العديد من الدوال المعرفة على `Result<T, E>`. يمكن أن تكون هذه الدوال أكثر
> إيجازًا من استخدام `match` عند التعامل مع قيم `Result<T, E>` في كودك.
>
> على سبيل المثال، إليك طريقة أخرى لكتابة نفس المنطق الموضح في القائمة
> 9-5، هذه المرة باستخدام closures ودالة `unwrap_or_else`:
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {error:?}");
>             })
>         } else {
>             panic!("Problem opening the file: {error:?}");
>         }
>     });
> }
> ```
>
> على الرغم من أن هذا الكود له نفس السلوك مثل القائمة 9-5، إلا أنه لا يحتوي
> على أي تعبيرات `match` وأنظف للقراءة. عد إلى هذا المثال
> بعد قراءة الفصل 13 وابحث عن دالة `unwrap_or_else` في
> وثائق المكتبة القياسية. العديد من هذه الدوال يمكن أن تنظف تعبيرات `match`
> الكبيرة والمتداخلة عند التعامل مع الأخطاء.

<!-- Old headings. Do not remove or links may break. -->

<a id="shortcuts-for-panic-on-error-unwrap-and-expect"></a>

### اختصارات لـ Panic عند الخطأ: `unwrap` و `expect`

استخدام `match` يعمل بشكل جيد، لكنه قد يكون مطولاً بعض الشيء ولا ينقل النية
دائمًا بشكل جيد. نوع `Result<T, E>` لديه العديد من الدوال المساعدة المعرفة
عليه للقيام بمهام متنوعة وأكثر تحديدًا. دالة `unwrap` هي دالة
اختصار تُنفذ تمامًا مثل تعبير `match` الذي كتبناه في القائمة 9-4. إذا كانت
قيمة `Result` هي متغير `Ok`، سترجع `unwrap` القيمة داخل `Ok`. إذا
كان `Result` هو متغير `Err`، ستستدعي `unwrap` ماكرو `panic!` لنا.
إليك مثال على `unwrap` في العمل:

<Listing file-name="src/main.rs">

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}
```

</Listing>

إذا شغّلنا هذا الكود بدون ملف _hello.txt_، سنرى رسالة خطأ من استدعاء `panic!`
الذي تقوم به دالة `unwrap`:

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->

```text
thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

بالمثل، تتيح لنا دالة `expect` أيضًا اختيار رسالة خطأ `panic!`. استخدام
`expect` بدلاً من `unwrap` وتوفير رسائل خطأ جيدة يمكن أن ينقل نيتك ويجعل
تتبع مصدر ال panic أسهل. تبدو صياغة `expect` كما يلي:

<Listing file-name="src/main.rs">

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}
```

</Listing>

نستخدم `expect` بنفس طريقة `unwrap`: لإرجاع معالج الملف أو استدعاء
ماكرو `panic!`. رسالة الخطأ المستخدمة من قبل `expect` في استدعائها لـ `panic!`
ستكون المعامل الذي نمرره إلى `expect`، بدلاً من رسالة `panic!` الافتراضية
التي تستخدمها `unwrap`. إليك كيف تبدو:

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->

```text
thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

في كود production-quality، يختار معظم Rustaceans `expect` بدلاً من `unwrap`
ويعطون مزيدًا من السياق حول سبب توقع العملية للنجاح دائمًا. بهذه الطريقة، إذا
تبين أن افتراضاتك خاطئة، لديك معلومات أكثر لاستخدامها في التصحيح.

### نشر الأخطاء

عندما تفشل تطبيق دالة، بدلاً من معالجة الخطأ داخل الدالة
نفسها، يمكنك إرجاع الخطأ إلى الكود الذي يستدعيها حتى يتمكن من تقرير ما يجب
فعله. هذا يُعرف بـ *نشر* الخطأ ويعطي مزيدًا من التحكم للكود المستدعي،
حيث قد يكون هناك معلومات أو منطق أكثر يملي كيفية التعامل مع الخطأ
مما هو متاح في سياق كودك.

على سبيل المثال، القائمة 9-6 توضح دالة تقرأ اسم مستخدم من ملف. إذا
لم يكن الملف موجودًا أو لا يمكن قراءته، ستُرجع هذه الدالة تلك الأخطاء
إلى الكود الذي استدعى الدالة.

<Listing number="9-6" file-name="src/main.rs" caption="دالة تُرجع الأخطاء إلى الكود المستدعي باستخدام `match`">

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}
```

</Listing>

يمكن كتابة هذه الدالة بطريقة أقصر بكثير، لكننا سنبدأ بالقيام بالكثير
منها يدويًا من أجل استكشاف معالجة الأخطاء؛ في النهاية، سنعرض الطريقة
الأقصر. لننظر إلى نوع الإرجاع للدالة أولاً: `Result<String,
io::Error>`. هذا يعني أن الدالة تُرجع قيمة من النوع `Result<T, E>`
حيث المعامل العام `T` تم ملؤه بالنوع الملموس `String`، والنوع العام
`E` تم ملؤه بالنوع الملموس `io::Error`.

إذا نجحت هذه الدالة بدون أي مشاكل، سيحصل الكود الذي يستدعي هذه
الدالة على قيمة `Ok` تحتوي على `String`—اسم المستخدم الذي قرأته
هذه الدالة من الملف. إذا واجهت هذه الدالة أي مشاكل، سيحصل الكود
المستدعي على قيمة `Err` تحتوي على نسخة من `io::Error` التي تحتوي
على مزيد من المعلومات حول ماهية المشاكل. اخترنا `io::Error` كنوع
الإرجاع لهذه الدالة لأنه يصادف أن يكون نوع قيمة الخطأ
المُرجعة من كلتا العمليتين اللتين نستدعيهما في جسم هذه الدالة والتي قد
تفشل: دالة `File::open` ودالة `read_to_string`.

يبدأ جسم الدالة باستدعاء دالة `File::open`. ثم نتعامل مع قيمة
`Result` بـ `match` مشابه لـ `match` في القائمة 9-4. إذا كان `File::open`
ناجحًا، يصبح معالج الملف في متغير النمط `file` القيمة في
المتغير القابل للتغيير `username_file`، وتستمر الدالة. في حالة `Err`،
بدلاً من استدعاء `panic!`، نستخدم الكلمة المفتاحية `return` للخروج من الدالة
مبكرًا تمامًا ونمرر قيمة الخطأ من `File::open`، الموجودة الآن في متغير النمط
`e`، مرة أخرى إلى الكود المستدعي كقيمة خطأ لهذه الدالة.

لذا إذا كان لدينا معالج ملف في `username_file`، تُنشئ الدالة بعد ذلك
`String` جديد في المتغير `username` وتستدعي دالة `read_to_string` على
معالج الملف في `username_file` لقراءة محتويات الملف إلى `username`. دالة
`read_to_string` ترجع أيضًا `Result` لأنها قد تفشل، حتى لو
نجح `File::open`. لذا نحتاج إلى `match` آخر للتعامل مع ذلك `Result`: إذا
نجح `read_to_string`، فإن دالتنا نجحت، ونُرجع اسم المستخدم من الملف
الموجود الآن في `username` مُغلفًا في `Ok`. إذا فشل `read_to_string`، نُرجع
قيمة الخطأ بنفس الطريقة التي أرجعنا بها قيمة الخطأ في `match` الذي
عالج قيمة الإرجاع من `File::open`. ومع ذلك، لسنا بحاجة إلى قول `return`
بشكل صريح، لأن هذا هو التعبير الأخير في الدالة.

الكود الذي يستدعي هذا الكود سيتعامل بعد ذلك مع الحصول على قيمة `Ok`
تحتوي على اسم مستخدم أو قيمة `Err` تحتوي على `io::Error`. الأمر متروك
للكود المستدعي لتقرير ما يجب فعله بتلك القيم. إذا حصل الكود المستدعي على
قيمة `Err`، فقد يستدعي `panic!` ويتسبب في تعطل البرنامج، أو يستخدم اسم مستخدم
افتراضي، أو يبحث عن اسم المستخدم من مكان آخر غير ملف، على سبيل المثال. ليس
لدينا معلومات كافية عما يحاول الكود المستدعي فعله بالفعل، لذا ننشر
جميع معلومات النجاح أو الخطأ للأعلى ليتعامل معها بشكل مناسب.

نمط نشر الأخطاء هذا شائع جدًا في Rust لدرجة أن Rust توفر
علامة الاستفهام `?` لجعل هذا أسهل.

#### اختصار لنشر الأخطاء: مشغل `?`

القائمة 9-7 توضح تطبيقًا لـ `read_username_from_file` له نفس
الوظيفة مثل القائمة 9-6، لكن هذا التطبيق يستخدم
مشغل `?`.

<Listing number="9-7" file-name="src/main.rs" caption="دالة تُرجع الأخطاء إلى الكود المستدعي باستخدام مشغل `?`">

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}
```

</Listing>

علامة `?` الموضوعة بعد قيمة `Result` معرّفة للعمل بنفس
الطريقة تقريبًا كتعبيرات `match` التي عرّفناها للتعامل مع قيم `Result` في
القائمة 9-6. إذا كانت قيمة `Result` هي `Ok`، ستُرجع القيمة داخل
`Ok` من هذا التعبير، وسيستمر البرنامج. إذا كانت القيمة هي `Err`،
سيتم إرجاع `Err` من الدالة بأكملها كما لو استخدمنا الكلمة المفتاحية
`return` بحيث تنتشر قيمة الخطأ إلى الكود المستدعي.

هناك فرق بين ما يفعله تعبير `match` من القائمة 9-6 وما
يفعله مشغل `?`: قيم الخطأ التي يُستدعى عليها مشغل `?` تمر عبر
دالة `from`، المعرّفة في trait `From` في المكتبة القياسية،
والتي تُستخدم لتحويل قيم من نوع إلى آخر. عندما يستدعي مشغل `?` دالة
`from`، يُحوّل نوع الخطأ المُستقبل إلى نوع الخطأ المعرّف في نوع
الإرجاع للدالة الحالية. هذا مفيد عندما تُرجع دالة نوع خطأ واحد
لتمثيل جميع الطرق التي قد تفشل بها الدالة، حتى لو كانت الأجزاء قد تفشل
لعدة أسباب مختلفة.

على سبيل المثال، يمكننا تغيير دالة `read_username_from_file` في القائمة 9-7
لإرجاع نوع خطأ مخصص يُسمى `OurError` الذي نعرّفه. إذا عرّفنا أيضًا `impl
From<io::Error> for OurError` لبناء نسخة من `OurError` من
`io::Error`، فإن استدعاءات مشغل `?` في جسم `read_username_from_file`
ستستدعي `from` وتحوّل أنواع الأخطاء دون الحاجة إلى إضافة أي كود
إضافي إلى الدالة.

في سياق القائمة 9-7، علامة `?` في نهاية استدعاء `File::open` سترجع
القيمة داخل `Ok` إلى المتغير `username_file`. إذا حدث خطأ، ستُرجع
علامة `?` مبكرًا من الدالة بأكملها وتعطي أي قيمة `Err` للكود
المستدعي. نفس الشيء ينطبق على علامة `?` في نهاية استدعاء `read_to_string`.

مشغل `?` يزيل الكثير من التفاصيل ويجعل تطبيق هذه الدالة
أبسط. يمكننا حتى تقصير هذا الكود أكثر عن طريق ربط استدعاءات الدوال
مباشرة بعد علامة `?`، كما هو موضح في القائمة 9-8.

<Listing number="9-8" file-name="src/main.rs" caption="ربط استدعاءات الدوال بعد مشغل `?`">

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}
```

</Listing>

نقلنا إنشاء `String` الجديد في `username` إلى بداية
الدالة؛ هذا الجزء لم يتغير. بدلاً من إنشاء متغير `username_file`، ربطنا
استدعاء `read_to_string` مباشرة بنتيجة `File::open("hello.txt")?`. ما زلنا
لدينا علامة `?` في نهاية استدعاء `read_to_string`، وما زلنا نُرجع قيمة `Ok`
تحتوي على `username` عندما ينجح كل من `File::open` و `read_to_string`
بدلاً من إرجاع الأخطاء. الوظيفة مرة أخرى هي نفسها الموجودة في القائمة 9-6 والقائمة 9-7؛
هذه فقط طريقة مختلفة وأكثر سهولة لكتابتها.

القائمة 9-9 توضح طريقة لجعل هذا أقصر حتى باستخدام `fs::read_to_string`.

<Listing number="9-9" file-name="src/main.rs" caption="استخدام `fs::read_to_string` بدلاً من فتح ثم قراءة الملف">

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}
```

</Listing>

قراءة ملف إلى string هي عملية شائعة إلى حد ما، لذا توفر المكتبة
القياسية دالة `fs::read_to_string` الملائمة التي تفتح
الملف، وتنشئ `String` جديد، وتقرأ محتويات الملف، وتضع المحتويات
في تلك `String`، وترجعها. بالطبع، استخدام `fs::read_to_string`
لا يعطينا الفرصة لشرح جميع معالجات الأخطاء، لذا قمنا بذلك
بالطريقة الأطول أولاً.

<!-- Old headings. Do not remove or links may break. -->

<a id="where-the--operator-can-be-used"></a>

#### أين يمكن استخدام مشغل `?`

يمكن استخدام مشغل `?` فقط في الدوال التي نوع إرجاعها متوافق
مع القيمة التي يُستخدم عليها `?`. هذا لأن مشغل `?` معرّف
لإجراء إرجاع مبكر لقيمة من الدالة، بنفس الطريقة
التي استخدمنا بها تعبير `match` الذي عرّفناه في القائمة 9-6. في القائمة 9-6، كان
`match` يستخدم قيمة `Result`، وذراع الإرجاع المبكر أرجع قيمة
`Err(e)`. يجب أن يكون نوع الإرجاع للدالة `Result` حتى
يكون متوافقًا مع هذا `return`.

في القائمة 9-10، لننظر إلى الخطأ الذي سنحصل عليه إذا استخدمنا مشغل `?`
في دالة `main` بنوع إرجاع غير متوافق مع نوع
القيمة التي نستخدم `?` عليها.

<Listing number="9-10" file-name="src/main.rs" caption="محاولة استخدام `?` في دالة `main` التي تُرجع `()` لن تُترجم.">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}
```

</Listing>

هذا الكود يفتح ملفًا، وقد يفشل ذلك. يتبع مشغل `?` قيمة `Result`
المُرجعة من `File::open`، لكن دالة `main` هذه لها نوع إرجاع
`()`، وليس `Result`. عندما نترجم هذا الكود، نحصل على رسالة الخطأ
التالية:

```console
{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}
```

يشير هذا الخطأ إلى أننا مسموح لنا فقط باستخدام مشغل `?` في
دالة تُرجع `Result` أو `Option` أو نوع آخر ينفذ
`FromResidual`.

لإصلاح الخطأ، لديك خياران. الخيار الأول هو تغيير نوع الإرجاع
لدالتك ليكون متوافقًا مع القيمة التي تستخدم مشغل `?` عليها
طالما ليس لديك قيود تمنع ذلك. الخيار الآخر هو
استخدام `match` أو إحدى دوال `Result<T, E>` للتعامل مع `Result<T, E>`
بالطريقة المناسبة.

رسالة الخطأ ذكرت أيضًا أن `?` يمكن استخدامه مع قيم `Option<T>`
أيضًا. كما هو الحال مع استخدام `?` على `Result`، يمكنك فقط استخدام `?` على `Option` في
دالة تُرجع `Option`. سلوك مشغل `?` عند استدعائه على
`Option<T>` مشابه لسلوكه عند استدعائه على `Result<T, E>`:
إذا كانت القيمة `None`، سيتم إرجاع `None` مبكرًا من الدالة في
تلك النقطة. إذا كانت القيمة `Some`، فإن القيمة داخل `Some` هي
القيمة الناتجة من التعبير، وتستمر الدالة. القائمة 9-11 لها
مثال على دالة تجد آخر حرف من السطر الأول في
النص المعطى.

<Listing number="9-11" caption="استخدام مشغل `?` على قيمة `Option<T>`">

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}
```

</Listing>

هذه الدالة تُرجع `Option<char>` لأنه من المحتمل أن يكون هناك
حرف هناك، لكن من المحتمل أيضًا أن لا يكون. هذا الكود يأخذ
شريحة string `text` كمعامل ويستدعي دالة `lines` عليها، والتي تُرجع
iterator على الأسطر في ال string. لأن هذه الدالة تريد
فحص السطر الأول، تستدعي `next` على ال iterator للحصول على القيمة الأولى
من ال iterator. إذا كان `text` عبارة عن string فارغ، سيُرجع هذا الاستدعاء لـ `next`
`None`، وفي هذه الحالة نستخدم `?` للإيقاف وإرجاع `None` من
`last_char_of_first_line`. إذا لم يكن `text` string فارغًا، سيُرجع `next`
قيمة `Some` تحتوي على شريحة string للسطر الأول في `text`.

يستخرج `?` شريحة ال string، ويمكننا استدعاء `chars` على تلك الشريحة
للحصول على iterator لحروفها. نحن مهتمون بآخر حرف في
هذا السطر الأول، لذا نستدعي `last` لإرجاع العنصر الأخير في ال iterator.
هذا `Option` لأنه من المحتمل أن يكون السطر الأول عبارة عن string
فارغ؛ على سبيل المثال، إذا بدأ `text` بسطر فارغ ولكن به حروف على
أسطر أخرى، كما في `"\nhi"`. ومع ذلك، إذا كان هناك حرف أخير على السطر
الأول، سيتم إرجاعه في متغير `Some`. يعطينا مشغل `?` في الوسط
طريقة موجزة للتعبير عن هذا المنطق، مما يسمح لنا بتنفيذ
الدالة في سطر واحد. إذا لم نتمكن من استخدام مشغل `?` على `Option`، كان سيتعين
علينا تنفيذ هذا المنطق باستخدام المزيد من استدعاءات الدوال أو تعبير `match`.

لاحظ أنه يمكنك استخدام مشغل `?` على `Result` في دالة تُرجع
`Result`، ويمكنك استخدام مشغل `?` على `Option` في دالة
تُرجع `Option`، لكن لا يمكنك المزج والمطابقة. لن يحول مشغل `?`
تلقائيًا `Result` إلى `Option` أو العكس؛ في تلك الحالات،
يمكنك استخدام دوال مثل دالة `ok` على `Result` أو دالة `ok_or` على
`Option` للقيام بالتحويل بشكل صريح.

حتى الآن، جميع دوال `main` التي استخدمناها تُرجع `()`. دالة `main` خاصة
لأنها نقطة الدخول ونقطة الخروج من برنامج قابل للتنفيذ،
وهناك قيود على ما يمكن أن يكون نوع إرجاعها ليتصرف البرنامج
كما هو متوقع.

لحسن الحظ، يمكن لـ `main` أيضًا إرجاع `Result<(), E>`. القائمة 9-12 تحتوي على الكود
من القائمة 9-10، لكننا غيّرنا نوع الإرجاع لـ `main` ليكون
`Result<(), Box<dyn Error>>` وأضفنا قيمة إرجاع `Ok(())` إلى النهاية. هذا
الكود سيُترجم الآن.

<Listing number="9-12" file-name="src/main.rs" caption="تغيير `main` لإرجاع `Result<(), E>` يسمح باستخدام مشغل `?` على قيم `Result`.">

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}
```

</Listing>

نوع `Box<dyn Error>` هو trait object، الذي سنتحدث عنه في ["استخدام
كائنات Trait لتجريد السلوك المشترك"][trait-objects]<!-- ignore -->
في الفصل 18. في الوقت الحالي، يمكنك قراءة `Box<dyn Error>` على أنه يعني "أي نوع من
الأخطاء." استخدام `?` على قيمة `Result` في دالة `main` مع نوع خطأ
`Box<dyn Error>` مسموح به لأنه يسمح بإرجاع أي قيمة `Err`
مبكرًا. حتى لو كان جسم دالة `main` هذه سيُرجع فقط
أخطاء من نوع `std::io::Error`، بتحديد `Box<dyn Error>`، هذا التوقيع
سيستمر في كونه صحيحًا حتى إذا تمت إضافة المزيد من الكود الذي يُرجع أخطاء أخرى إلى
جسم `main`.

عندما تُرجع دالة `main` قيمة `Result<(), E>`، سيخرج البرنامج القابل للتنفيذ بقيمة
`0` إذا أرجع `main` قيمة `Ok(())` وسيخرج بقيمة غير صفرية إذا
أرجع `main` قيمة `Err`. البرامج القابلة للتنفيذ المكتوبة بلغة C تُرجع أعدادًا صحيحة عندما
تخرج: البرامج التي تخرج بنجاح تُرجع العدد الصحيح `0`، والبرامج
التي تفشل تُرجع عددًا صحيحًا آخر غير `0`. ترجع Rust أيضًا أعدادًا صحيحة من
البرامج القابلة للتنفيذ لتكون متوافقة مع هذا التقليد.

دالة `main` قد تُرجع أي أنواع تنفذ [trait
`std::process::Termination`][termination]<!-- ignore -->، والذي يحتوي
على دالة `report` تُرجع `ExitCode`. راجع وثائق المكتبة القياسية
لمزيد من المعلومات حول تنفيذ trait `Termination` لأنواعك
الخاصة.

الآن بعد أن ناقشنا تفاصيل استدعاء `panic!` أو إرجاع `Result`,
لنعد إلى موضوع كيفية تقرير أيهما مناسب للاستخدام في أي
الحالات.

[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result
[trait-objects]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior
[termination]: ../std/process/trait.Termination.html
