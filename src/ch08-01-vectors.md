## تخزين قوائم القيم باستخدام المتجهات (Vectors)

أول نوع من المجموعات سننظر إليه هو `Vec<T>`، المعروف أيضًا بالمتجه (vector).
تسمح لك المتجهات بتخزين أكثر من قيمة واحدة في هيكل بيانات واحد يضع
جميع القيم بجانب بعضها البعض في الذاكرة. يمكن للمتجهات تخزين قيم
من نفس النوع فقط. تكون مفيدة عندما يكون لديك قائمة من العناصر (elements)، مثل
أسطر النص في ملف أو أسعار العناصر في عربة التسوق.

### إنشاء متجه جديد

لإنشاء متجه جديد فارغ، نستدعي الدالة `Vec::new`، كما هو موضح في
القائمة 8-1.

<Listing number="8-1" caption="إنشاء متجه جديد فارغ لحمل قيم من النوع `i32`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-01/src/main.rs:here}}
```

</Listing>

لاحظ أننا أضفنا تعليقًا توضيحيًا للنوع هنا. لأننا لا نقوم بإدراج (insert) أي
قيم في هذا المتجه، لا يعرف Rust نوع العناصر التي ننوي
تخزينها. هذه نقطة مهمة. يتم تنفيذ المتجهات باستخدام الأنواع العمومية (generics)؛
سنغطي كيفية استخدام الأنواع العمومية مع أنواعك الخاصة في الفصل 10. في الوقت الحالي،
اعلم أن النوع `Vec<T>` المقدم من المكتبة القياسية يمكنه حمل أي نوع.
عندما ننشئ متجهًا لحمل نوع معين، يمكننا تحديد النوع داخل
الأقواس الزاوية. في القائمة 8-1، أخبرنا Rust أن `Vec<T>` في `v` سيحمل
عناصر من النوع `i32`.

في أغلب الأحيان، ستنشئ `Vec<T>` بقيم أولية، وسيستنتج Rust
نوع القيمة التي تريد تخزينها، لذلك نادرًا ما تحتاج إلى هذا التعليق التوضيحي
للنوع. يوفر Rust بشكل ملائم الماكرو `vec!`، الذي سينشئ
متجهًا جديدًا يحمل القيم التي تعطيها له. تنشئ القائمة 8-2 متجهًا جديدًا
`Vec<i32>` يحمل القيم `1` و `2` و `3`. نوع العدد الصحيح هو `i32`
لأن هذا هو نوع العدد الصحيح الافتراضي، كما ناقشنا في قسم [" أنواع
البيانات"][data-types]<!-- ignore --> من الفصل 3.

<Listing number="8-2" caption="إنشاء متجه جديد يحتوي على قيم">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-02/src/main.rs:here}}
```

</Listing>

لأننا أعطينا قيم `i32` أولية، يمكن لـ Rust استنتاج أن نوع `v`
هو `Vec<i32>`، والتعليق التوضيحي للنوع ليس ضروريًا. بعد ذلك، سننظر في كيفية
تعديل متجه.

### تحديث (update) متجه

لإنشاء متجه ثم إضافة عناصر إليه، يمكننا استخدام طريقة `push`،
كما هو موضح في القائمة 8-3.

<Listing number="8-3" caption="استخدام طريقة `push` لإضافة قيم إلى متجه">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-03/src/main.rs:here}}
```

</Listing>

كما هو الحال مع أي متغير، إذا أردنا أن نكون قادرين على تغيير قيمته، نحتاج إلى
جعله قابلاً للتغيير باستخدام الكلمة المفتاحية `mut`، كما تمت مناقشته في الفصل 3. الأرقام
التي نضعها بالداخل كلها من النوع `i32`، ويستنتج Rust هذا من البيانات، لذلك
لا نحتاج إلى التعليق التوضيحي `Vec<i32>`.

### قراءة عناصر المتجهات

هناك طريقتان للإشارة إلى قيمة مخزنة في متجه: عبر الفهرسة (indexing) أو عن طريق
استخدام طريقة `get`. في الأمثلة التالية، قمنا بتعليق أنواع
القيم التي يتم إرجاعها من هذه الدوال لمزيد من الوضوح.

توضح القائمة 8-4 كلا الطريقتين للوصول إلى قيمة في متجه، باستخدام صيغة الفهرسة
وطريقة `get`.

<Listing number="8-4" caption="استخدام صيغة الفهرسة واستخدام طريقة `get` للوصول إلى عنصر (element) في متجه">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-04/src/main.rs:here}}
```

</Listing>

لاحظ بعض التفاصيل هنا. نستخدم قيمة الفهرس (index) `2` للحصول على العنصر الثالث
لأن المتجهات تُفهرس بالأرقام، بدءًا من الصفر. استخدام `&` و `[]`
يعطينا مرجعًا إلى العنصر عند قيمة الفهرس. عندما نستخدم طريقة `get`
مع الفهرس الممرر كوسيطة، نحصل على `Option<&T>` يمكننا
استخدامه مع `match`.

يوفر Rust هاتين الطريقتين للإشارة إلى عنصر حتى تتمكن من اختيار كيف
يتصرف البرنامج عندما تحاول استخدام قيمة فهرس خارج نطاق
العناصر الموجودة. كمثال، دعونا نرى ما يحدث عندما يكون لدينا متجه
من خمسة عناصر ثم نحاول الوصول إلى عنصر عند الفهرس 100 بكل
تقنية، كما هو موضح في القائمة 8-5.

<Listing number="8-5" caption="محاولة الوصول إلى العنصر عند الفهرس 100 في متجه يحتوي على خمسة عناصر">

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-05/src/main.rs:here}}
```

</Listing>

عندما نشغل هذا الكود، ستتسبب طريقة `[]` الأولى في حدوث ذعر (panic) للبرنامج
لأنها تشير إلى عنصر غير موجود. هذه الطريقة هي الأفضل للاستخدام عندما
تريد أن يتعطل برنامجك إذا كانت هناك محاولة للوصول إلى عنصر بعد
نهاية المتجه.

عندما يتم تمرير فهرس خارج المتجه إلى طريقة `get`، فإنها ترجع
`None` دون حدوث ذعر. ستستخدم هذه الطريقة إذا كان الوصول إلى عنصر
خارج نطاق المتجه قد يحدث أحيانًا في ظل ظروف عادية. سيكون لكودك حينها منطق للتعامل مع وجود إما
`Some(&element)` أو `None`، كما تمت مناقشته في الفصل 6. على سبيل المثال، قد يكون الفهرس
قادمًا من شخص يدخل رقمًا. إذا أدخلوا عن طريق الخطأ
رقمًا كبيرًا جدًا وحصل البرنامج على قيمة `None`، يمكنك إخبار
المستخدم بعدد العناصر الموجودة في المتجه الحالي ومنحهم فرصة أخرى
لإدخال قيمة صالحة. سيكون ذلك أكثر ودية للمستخدم من تعطيل البرنامج
بسبب خطأ مطبعي!

عندما يكون للبرنامج مرجع صالح، يفرض مدقق الاستعارة (borrow checker)
قواعد الملكية والاستعارة (المغطاة في الفصل 4) لضمان أن هذا
المرجع وأي مراجع أخرى لمحتويات المتجه تظل صالحة.
تذكر القاعدة التي تنص على أنه لا يمكنك الحصول على مراجع قابلة للتغيير وغير قابلة للتغيير في
نفس النطاق. تنطبق تلك القاعدة في القائمة 8-6، حيث نحمل مرجعًا غير قابل للتغيير
إلى العنصر الأول في متجه ونحاول إضافة عنصر إلى
النهاية. لن يعمل هذا البرنامج إذا حاولنا أيضًا الإشارة إلى ذلك العنصر لاحقًا في
الدالة.

<Listing number="8-6" caption="محاولة إضافة عنصر إلى متجه مع الاحتفاظ بمرجع إلى عنصر">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-06/src/main.rs:here}}
```

</Listing>

سيؤدي ترجمة هذا الكود إلى هذا الخطأ:

```console
{{#include ../listings/ch08-common-collections/listing-08-06/output.txt}}
```

قد يبدو الكود في القائمة 8-6 وكأنه يجب أن يعمل: لماذا يجب على مرجع
للعنصر الأول أن يهتم بالتغييرات في نهاية المتجه؟ هذا الخطأ
يرجع إلى طريقة عمل المتجهات: لأن المتجهات تضع القيم بجانب بعضها
في الذاكرة، فإن إضافة عنصر جديد إلى نهاية المتجه قد تتطلب
تخصيص ذاكرة جديدة ونسخ العناصر القديمة إلى المساحة الجديدة، إذا لم تكن هناك
مساحة كافية لوضع جميع العناصر بجانب بعضها حيث يتم تخزين المتجه
حاليًا. في هذه الحالة، سيكون المرجع إلى العنصر الأول
يشير إلى ذاكرة تم إلغاء تخصيصها. تمنع قواعد الاستعارة البرامج من
الانتهاء في تلك الحالة.

> ملاحظة: لمزيد من التفاصيل حول تنفيذ نوع `Vec<T>`، راجع ["The
> Rustonomicon"][nomicon].

### التكرار عبر القيم في متجه

للوصول إلى كل عنصر في متجه بالتناوب، سنكرر عبر جميع
العناصر بدلاً من استخدام الفهارس للوصول إلى واحد في كل مرة. توضح القائمة 8-7 كيفية
استخدام حلقة `for` للحصول على مراجع غير قابلة للتغيير لكل عنصر في متجه من
قيم `i32` وطباعتها.

<Listing number="8-7" caption="طباعة كل عنصر في متجه من خلال التكرار عبر العناصر باستخدام حلقة `for`">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-07/src/main.rs:here}}
```

</Listing>

يمكننا أيضًا التكرار عبر مراجع قابلة للتغيير لكل عنصر في متجه قابل للتغيير
من أجل إجراء تغييرات على جميع العناصر. ستضيف حلقة `for` في القائمة 8-8
`50` إلى كل عنصر.

<Listing number="8-8" caption="التكرار عبر مراجع قابلة للتغيير لعناصر في متجه">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
```

</Listing>

لتغيير القيمة التي يشير إليها المرجع القابل للتغيير، يجب علينا استخدام
معامل إلغاء الإشارة `*` للوصول إلى القيمة في `i` قبل أن نتمكن من استخدام معامل `+=`
. سنتحدث أكثر عن معامل إلغاء الإشارة في قسم ["اتباع
المرجع إلى القيمة"][deref]<!-- ignore --> من الفصل 15.

التكرار عبر متجه، سواء كان غير قابل للتغيير أو قابلاً للتغيير، آمن بسبب
قواعد مدقق الاستعارة. إذا حاولنا إدراج أو إزالة عناصر في أجسام حلقة `for`
في القائمة 8-7 والقائمة 8-8، سنحصل على خطأ في المصرِّف
مشابه لذلك الذي حصلنا عليه مع الكود في القائمة 8-6. المرجع إلى
المتجه الذي تحمله حلقة `for` يمنع التعديل المتزامن
للمتجه بأكمله.

### استخدام Enum لتخزين أنواع متعددة

يمكن للمتجهات فقط تخزين قيم من نفس النوع. قد يكون هذا
غير مريح؛ هناك بالتأكيد حالات استخدام لحاجة تخزين قائمة من
عناصر من أنواع مختلفة. لحسن الحظ، يتم تعريف متغيرات enum
تحت نفس نوع enum، لذلك عندما نحتاج نوعًا واحدًا لتمثيل عناصر من
أنواع مختلفة، يمكننا تعريف واستخدام enum!

على سبيل المثال، لنفترض أننا نريد الحصول على قيم من صف في جدول بيانات حيث
تحتوي بعض الأعمدة في الصف على أعداد صحيحة، وبعضها على أرقام عشرية،
وبعضها على سلاسل نصية. يمكننا تعريف enum تحمل متغيراته أنواع
القيم المختلفة، وستُعتبر جميع متغيرات enum من نفس النوع: نوع
enum. بعد ذلك، يمكننا إنشاء متجه لحمل ذلك enum وبالتالي، في النهاية،
حمل أنواع مختلفة. لقد أوضحنا هذا في القائمة 8-9.

<Listing number="8-9" caption="تعريف enum لتخزين قيم من أنواع مختلفة في متجه واحد">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-09/src/main.rs:here}}
```

</Listing>

يحتاج Rust إلى معرفة أنواع ما سيكون في المتجه في وقت الترجمة حتى
يعرف بالضبط مقدار الذاكرة على الكومة (heap) التي ستكون مطلوبة لتخزين كل عنصر.
يجب أيضًا أن نكون صريحين بشأن الأنواع المسموح بها في هذا المتجه. إذا سمح Rust
لمتجه بحمل أي نوع، سيكون هناك احتمال أن واحدًا أو أكثر من
الأنواع سيتسبب في أخطاء مع العمليات المنفذة على عناصر
المتجه. استخدام enum بالإضافة إلى تعبير `match` يعني أن Rust سيضمن
في وقت الترجمة أنه يتم التعامل مع كل حالة ممكنة، كما تمت مناقشته في الفصل 6.

إذا كنت لا تعرف المجموعة الشاملة للأنواع التي سيحصل عليها البرنامج في وقت التشغيل
للتخزين في متجه، فإن تقنية enum لن تعمل. بدلاً من ذلك، يمكنك استخدام كائن سمة (trait object)،
والذي سنغطيه في الفصل 18.

الآن بعد أن ناقشنا بعض الطرق الأكثر شيوعًا لاستخدام المتجهات، تأكد
من مراجعة [وثائق API][vec-api]<!-- ignore --> لجميع الطرق
المفيدة العديدة المعرفة على `Vec<T>` بواسطة المكتبة القياسية. على سبيل المثال،
بالإضافة إلى `push`، تزيل طريقة `pop` وتُرجع العنصر الأخير.

### حذف متجه يحذف عناصره

مثل أي `struct` آخر، يتم تحرير المتجه عندما يخرج من النطاق، كما
هو موضح في القائمة 8-10.

<Listing number="8-10" caption="إظهار أين يتم حذف المتجه وعناصره">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-10/src/main.rs:here}}
```

</Listing>

عندما يتم حذف المتجه، يتم أيضًا حذف جميع محتوياته، مما يعني أن
الأعداد الصحيحة التي يحملها سيتم تنظيفها. يضمن مدقق الاستعارة أن أي
مراجع لمحتويات المتجه تُستخدم فقط بينما المتجه نفسه
صالح.

لننتقل إلى نوع المجموعة التالي: `String`!

[data-types]: ch03-02-data-types.html#data-types
[nomicon]: ../nomicon/vec/vec.html
[vec-api]: ../std/vec/struct.Vec.html
[deref]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator
