<!-- Old headings. Do not remove or links may break. -->

<a id="streams"></a>

## التدفقات: المستقبلات في تسلسل

تذكر كيف استخدمنا المستقبل للقناة async في وقت سابق في هذا الفصل في قسم ["تمرير الرسائل"][17-02-messages]<!-- ignore -->. طريقة `recv` غير المتزامنة تنتج تسلسلاً من العناصر بمرور الوقت. هذا مثيل لنمط أكثر عمومية يُعرف باسم _التدفق_ (stream). العديد من المفاهيم ممثلة بشكل طبيعي كتدفقات: العناصر التي تصبح متاحة في قائمة انتظار، وأجزاء البيانات التي يتم سحبها بشكل تدريجي من نظام الملفات عندما تكون مجموعة البيانات الكاملة كبيرة جدًا بالنسبة لذاكرة الكمبيوتر، أو البيانات القادمة عبر الشبكة بمرور الوقت. نظرًا لأن التدفقات هي مستقبلات، يمكننا استخدامها مع أي نوع آخر من المستقبلات والجمع بينها بطرق مثيرة للاهتمام. على سبيل المثال، يمكننا دفعة الأحداث لتجنب تفعيل عدد كبير جدًا من استدعاءات الشبكة، أو تعيين مهلات زمنية على تسلسلات العمليات طويلة الأمد، أو خنق أحداث واجهة المستخدم لتجنب القيام بالعمل غير الضروري.

رأينا تسلسلًا من العناصر في الفصل 13، عندما نظرنا إلى سِمَة Iterator في قسم ["سِمَة Iterator وطريقة `next`"][iterator-trait]<!-- ignore -->، لكن هناك فرقان بين المُكرِّرات ومستقبل القناة. الفرق الأول هو الوقت: المُكرِّرات متزامنة، بينما مستقبل القناة غير متزامن. الفرق الثاني هو واجهة برمجة التطبيقات. عند العمل مباشرة مع `Iterator`، نستدعي طريقة `next` المتزامنة الخاصة به. مع تدفق `trpl::Receiver` على وجه الخصوص، استدعينا طريقة `recv` غير المتزامنة بدلاً من ذلك. خلاف ذلك، تبدو واجهات برمجة التطبيقات هذه متشابهة جدًا، وهذا التشابه ليس صدفة. التدفق يشبه شكلاً غير متزامن من التكرار. في حين أن `trpl::Receiver` ينتظر على وجه التحديد استلام الرسائل، فإن واجهة برمجة التطبيقات العامة للتدفق أوسع بكثير: فهي توفر العنصر التالي بالطريقة التي يفعلها `Iterator`، ولكن بشكل غير متزامن.

التشابه بين المُكرِّرات والتدفقات في Rust يعني أنه يمكننا في الواقع إنشاء تدفق من أي مُكرِّر. كما هو الحال مع المكرر، يمكننا العمل مع تدفق من خلال استدعاء طريقة `next` الخاصة به ثم انتظار الناتج، كما في القائمة 17-21، والتي لن تترجم بعد.

<Listing number="17-21" caption="إنشاء تدفق من مُكرِّر وطباعة قيمه" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-21/src/main.rs:stream}}
```

</Listing>

نبدأ بمصفوفة من الأرقام، والتي نحولها إلى مُكرِّر ثم نستدعي `map` عليها لمضاعفة جميع القيم. ثم نحول المكرر إلى تدفق باستخدام دالة `trpl::stream_from_iter`. بعد ذلك، نتكرر على العناصر في التدفق عند وصولها باستخدام حلقة `while let`.

لسوء الحظ، عندما نحاول تشغيل الكود، فإنه لا يترجم ولكنه يبلغ بدلاً من ذلك عن عدم وجود طريقة `next` متاحة:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-21
cargo build
انسخ ناتج الخطأ فقط
-->

```text
error[E0599]: no method named `next` found for struct `tokio_stream::iter::Iter` in the current scope
  --> src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
```

كما يوضح هذا الناتج، سبب خطأ المصرِّف هو أننا بحاجة إلى السِمَة الصحيحة في النطاق لنتمكن من استخدام طريقة `next`. بالنظر إلى مناقشتنا حتى الآن، قد تتوقع بشكل معقول أن تكون هذه السِمَة `Stream`، لكنها في الواقع `StreamExt`. اختصار _extension_، `Ext` هو نمط شائع في مجتمع Rust لتوسيع سِمَة واحدة بأخرى.

تحدد سِمَة `Stream` واجهة منخفضة المستوى تجمع بشكل فعال بين سِمات `Iterator` و `Future`. توفر `StreamExt` مجموعة أعلى مستوى من واجهات برمجة التطبيقات فوق `Stream`، بما في ذلك طريقة `next` بالإضافة إلى طرق الأدوات الأخرى المشابهة لتلك التي توفرها سِمَة `Iterator`. `Stream` و `StreamExt` ليسا جزءًا من مكتبة Rust القياسية بعد، لكن معظم مكتبات النظام البيئي تستخدم تعريفات مماثلة.

الإصلاح لخطأ المصرِّف هو إضافة عبارة `use` لـ `trpl::StreamExt`، كما في القائمة 17-22.

<Listing number="17-22" caption="استخدام مُكرِّر بنجاح كأساس لتدفق" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-22/src/main.rs:all}}
```

</Listing>

مع جميع هذه القطع معًا، يعمل هذا الكود بالطريقة التي نريدها! ما هو أكثر من ذلك، الآن بعد أن أصبح لدينا `StreamExt` في النطاق، يمكننا استخدام جميع طرق الأدوات الخاصة به، تمامًا كما هو الحال مع المُكرِّرات.

[17-02-messages]: ch17-02-concurrency-with-async.html#message-passing
[iterator-trait]: ch13-02-iterators.html#the-iterator-trait-and-the-next-method
