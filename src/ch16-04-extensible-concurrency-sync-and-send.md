<!-- Old headings. Do not remove or links may break. -->

<a id="extensible-concurrency-with-the-sync-and-send-traits"></a>
<a id="extensible-concurrency-with-the-send-and-sync-traits"></a>

## التزامن القابل للتوسيع (extensible concurrency) مع `Send` و `Sync`

من المثير للاهتمام أن كل ميزة تزامن (concurrency) تحدثنا عنها تقريباً حتى الآن في هذا الفصل كانت جزءاً من المكتبة القياسية، وليس اللغة. خياراتك للتعامل مع التزامن (concurrency) ليست مقتصرة على اللغة أو المكتبة القياسية؛ يمكنك كتابة ميزات التزامن (concurrency) الخاصة بك أو استخدام تلك المكتوبة بواسطة الآخرين.

ومع ذلك، من بين مفاهيم التزامن الرئيسية المضمنة في اللغة بدلاً من المكتبة القياسية سِمات `std::marker`: `Send` و `Sync`.

<!-- Old headings. Do not remove or links may break. -->

<a id="allowing-transference-of-ownership-between-threads-with-send"></a>

### نقل الملكية بين الخيوط (threads)

تشير سِمة العلامة (marker trait) `Send` إلى أنه يمكن نقل ملكية قيم من النوع الذي ينفذ `Send` بين الخيوط (threads). تقريباً كل نوع Rust ينفذ `Send`، لكن هناك بعض الاستثناءات، بما في ذلك `Rc<T>`: لا يمكن لهذا تنفيذ `Send` لأنه إذا استنسخت قيمة `Rc<T>` وحاولت نقل ملكية الاستنساخ إلى خيط آخر، فقد يحدث كلا الخيطين تحديث عدد المراجع في نفس الوقت. لهذا السبب، يتم تنفيذ `Rc<T>` للاستخدام في المواقف أحادية الخيط حيث لا تريد دفع عقوبة الأداء الآمنة للخيوط.

لذلك، يضمن نظام الأنواع وحدود السِمات في Rust أنك لا يمكنك أبداً إرسال قيمة `Rc<T>` عبر الخيوط بشكل غير آمن عن طريق الخطأ. عندما حاولنا القيام بذلك في القائمة 16-14، حصلنا على الخطأ `` the trait `Send` is not implemented for `Rc<Mutex<i32>>` ``. عندما انتقلنا إلى `Arc<T>`، الذي ينفذ `Send`، تم ترجمة الكود.

يتم تلقائياً وضع علامة على أي نوع يتكون بالكامل من أنواع `Send` على أنه `Send` أيضاً. تقريباً جميع الأنواع الأولية هي `Send`، باستثناء المؤشرات الخام (Raw pointers)، التي سنناقشها في الفصل 20.

<!-- Old headings. Do not remove or links may break. -->

<a id="allowing-access-from-multiple-threads-with-sync"></a>

### الوصول من خيوط (threads) متعددة

تشير سِمة العلامة (marker trait) `Sync` إلى أنه من الآمن للنوع الذي ينفذ `Sync` أن تتم الإشارة إليه من خيوط (threads) متعددة. بعبارة أخرى، أي نوع `T` ينفذ `Sync` إذا كان `&T` (مرجع غير قابل للتغيير إلى `T`) ينفذ `Send`، مما يعني أنه يمكن إرسال المرجع بأمان إلى خيط آخر. على غرار `Send`، تنفذ الأنواع الأولية جميعها `Sync`، والأنواع المكونة بالكامل من أنواع تنفذ `Sync` تنفذ `Sync` أيضاً.

المؤشر الذكي `Rc<T>` أيضاً لا ينفذ `Sync` لنفس الأسباب التي لا ينفذ بها `Send`. النوع `RefCell<T>` (الذي تحدثنا عنه في الفصل 15) وعائلة أنواع `Cell<T>` ذات الصلة لا تنفذ `Sync`. تنفيذ فحص الاستعارة الذي يقوم به `RefCell<T>` في وقت التشغيل ليس آمناً للخيوط. المؤشر الذكي `Mutex<T>` ينفذ `Sync` ويمكن استخدامه لمشاركة الوصول مع خيوط متعددة، كما رأيت في ["الوصول المشترك إلى `Mutex<T>`"][shared-access]<!-- ignore -->.

### تنفيذ `Send` و `Sync` يدوياً غير آمن

نظراً لأن الأنواع المكونة بالكامل من أنواع أخرى تنفذ سِمات `Send` و `Sync` تنفذ `Send` و `Sync` تلقائياً أيضاً، فليس علينا تنفيذ تلك السِمات يدوياً. كسِمات علامة، ليس لديها حتى أي دوال لتنفيذها. إنها مفيدة فقط لفرض ثوابت متعلقة بالتزامن.

يتضمن التنفيذ اليدوي لهذه السِمات تنفيذ كود Rust غير آمن. سنتحدث عن استخدام كود Rust غير آمن في الفصل 20؛ في الوقت الحالي، المعلومات المهمة هي أن بناء أنواع تزامن جديدة ليست مصنوعة من أجزاء `Send` و `Sync` يتطلب تفكيراً دقيقاً للحفاظ على ضمانات الأمان. ["The Rustonomicon"][nomicon] يحتوي على مزيد من المعلومات حول هذه الضمانات وكيفية الحفاظ عليها.

## الخلاصة

هذه ليست المرة الأخيرة التي ستراها للتزامن في هذا الكتاب: يركز الفصل التالي على البرمجة غير المتزامنة (Async programming)، وسيستخدم المشروع في الفصل 21 المفاهيم في هذا الفصل في موقف أكثر واقعية من الأمثلة الأصغر التي تمت مناقشتها هنا.

كما ذُكر سابقاً، نظراً لأن القليل جداً من كيفية تعامل Rust مع التزامن هو جزء من اللغة، يتم تنفيذ العديد من حلول التزامن كصناديق. تتطور هذه بسرعة أكبر من المكتبة القياسية، لذا تأكد من البحث عبر الإنترنت عن الصناديق الحالية والمتقدمة للاستخدام في المواقف متعددة الخيوط.

توفر المكتبة القياسية لـ Rust قنوات لتمرير الرسائل وأنواع مؤشرات ذكية، مثل `Mutex<T>` و `Arc<T>`، آمنة للاستخدام في السياقات المتزامنة. يضمن نظام الأنواع ومدقق الاستعارة أن الكود الذي يستخدم هذه الحلول لن ينتهي بسباقات البيانات (Data races) أو مراجع غير صالحة. بمجرد أن يتم ترجمة كودك، يمكنك أن تطمئن إلى أنه سيعمل بسعادة على خيوط متعددة دون أنواع الأخطاء التي يصعب تتبعها والشائعة في اللغات الأخرى. لم تعد البرمجة المتزامنة مفهوماً يجب الخوف منه: انطلق واجعل برامجك متزامنة، بلا خوف!

[shared-access]: ch16-03-shared-state.html#shared-access-to-mutext
[nomicon]: ../nomicon/index.html
