## أنواع البيانات

كل قيمة في Rust لها _نوع بيانات_ معين، والذي يخبر Rust بنوع البيانات المحددة حتى تعرف كيفية التعامل مع تلك البيانات. سننظر في مجموعتين فرعيتين من أنواع البيانات: القياسية والمركبة.

ضع في اعتبارك أن Rust لغة _مكتوبة بشكل ثابت_، مما يعني أنه يجب أن تعرف أنواع جميع المتغيرات في وقت الترجمة. عادةً ما يستطيع المصرِّف استنتاج النوع الذي نريد استخدامه بناءً على القيمة وكيفية استخدامنا لها. في الحالات التي تكون فيها العديد من الأنواع ممكنة، مثل عندما حولنا `String` إلى نوع رقمي باستخدام `parse` في قسم [«مقارنة التخمين بالرقم السري»][comparing-the-guess-to-the-secret-number]<!-- ignore --> في الفصل الثاني، يجب علينا إضافة تعليق توضيحي للنوع، مثل هذا:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

إذا لم نضف تعليق النوع التوضيحي `: u32` الموضح في الكود السابق، فسيعرض Rust الخطأ التالي، مما يعني أن المصرِّف يحتاج إلى مزيد من المعلومات منا لمعرفة النوع الذي نريد استخدامه:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

سترى تعليقات توضيحية مختلفة للأنواع لأنواع البيانات الأخرى.

### الأنواع القياسية

يمثل النوع _القياسي_ قيمة واحدة. لدى Rust أربعة أنواع قياسية أساسية: الأعداد الصحيحة، وأعداد الفاصلة العائمة، والقيم المنطقية، والأحرف. قد تتعرف على هذه من لغات البرمجة الأخرى. دعنا ننتقل إلى كيفية عملها في Rust.

#### أنواع الأعداد الصحيحة

_العدد الصحيح_ هو رقم بدون مكون كسري. استخدمنا نوع عدد صحيح واحد في الفصل الثاني، وهو نوع `u32`. يشير إعلان النوع هذا إلى أن القيمة المرتبطة به يجب أن تكون عددًا صحيحًا غير موقّع (تبدأ أنواع الأعداد الصحيحة الموقّعة بـ `i` بدلاً من `u`) يشغل 32 بتًا من المساحة. يوضح الجدول 3-1 أنواع الأعداد الصحيحة المدمجة في Rust. يمكننا استخدام أي من هذه المتغيرات للإعلان عن نوع قيمة عدد صحيح.

<span class="caption">الجدول 3-1: أنواع الأعداد الصحيحة في Rust</span>

| الطول            | موقّع    | غير موقّع |
| ---------------- | ------- | -------- |
| 8-بت             | `i8`    | `u8`     |
| 16-بت            | `i16`   | `u16`    |
| 32-بت            | `i32`   | `u32`    |
| 64-بت            | `i64`   | `u64`    |
| 128-بت           | `i128`  | `u128`   |
| يعتمد على البنية | `isize` | `usize`  |

يمكن أن يكون كل متغير إما موقعًا أو غير موقع وله حجم صريح. يشير _الموقّع_ و _غير الموقّع_ إلى ما إذا كان من الممكن أن يكون الرقم سالبًا - بمعنى آخر، ما إذا كان الرقم يحتاج إلى أن يكون معه إشارة (موقع) أو ما إذا كان سيكون إيجابيًا فقط ويمكن بالتالي تمثيله بدون إشارة (غير موقع). إنه مثل كتابة الأرقام على الورق: عندما تكون الإشارة مهمة، يتم عرض الرقم بعلامة زائد أو علامة ناقص؛ ومع ذلك، عندما يكون من الآمن افتراض أن الرقم إيجابي، يتم عرضه بدون إشارة. يتم تخزين الأرقام الموقعة باستخدام تمثيل [المتمم الثنائي][twos-complement]<!-- ignore -->.

يمكن لكل متغير موقع تخزين أرقام من -(2<sup>n - 1</sup>) إلى 2<sup>n - 1</sup> - 1 ضمناً، حيث _n_ هو عدد البتات التي يستخدمها ذلك المتغير. لذلك، يمكن لـ `i8` تخزين أرقام من -(2<sup>7</sup>) إلى 2<sup>7</sup> - 1، والذي يساوي -128 إلى 127. يمكن للمتغيرات غير الموقعة تخزين أرقام من 0 إلى 2<sup>n</sup> - 1، لذلك يمكن لـ `u8` تخزين أرقام من 0 إلى 2<sup>8</sup> - 1، والذي يساوي 0 إلى 255.

بالإضافة إلى ذلك، يعتمد نوعا `isize` و `usize` على بنية الكمبيوتر الذي يعمل عليه برنامجك: 64 بتًا إذا كنت على بنية 64 بتًا و 32 بتًا إذا كنت على بنية 32 بتًا.

يمكنك كتابة الحرفيات الصحيحة بأي من الأشكال الموضحة في الجدول 3-2. لاحظ أن الحرفيات الرقمية التي يمكن أن تكون أنواعًا رقمية متعددة تسمح بلاحقة النوع، مثل `57u8`، لتحديد النوع. يمكن للحرفيات الرقمية أيضًا استخدام `_` كفاصل بصري لجعل الرقم أسهل في القراءة، مثل `1_000`، والذي سيكون له نفس القيمة كما لو كنت قد حددت `1000`.

<span class="caption">الجدول 3-2: الحرفيات الصحيحة في Rust</span>

| الحرفيات الرقمية | مثال          |
| ---------------- | ------------- |
| عشري             | `98_222`      |
| ست عشري          | `0xff`        |
| ثماني            | `0o77`        |
| ثنائي            | `0b1111_0000` |
| بايت (`u8` فقط)  | `b'A'`        |

إذن كيف تعرف أي نوع من الأعداد الصحيحة تستخدم؟ إذا لم تكن متأكدًا، فإن الإعدادات الافتراضية في Rust هي عمومًا أماكن جيدة للبدء: تكون أنواع الأعداد الصحيحة افتراضيًا `i32`. الموقف الأساسي الذي قد تستخدم فيه `isize` أو `usize` هو عند فهرسة نوع من المجموعات.

> ##### تجاوز العدد الصحيح
>
> لنفترض أن لديك متغيرًا من النوع `u8` يمكنه الاحتفاظ بقيم بين 0 و 255. إذا حاولت تغيير المتغير إلى قيمة خارج هذا النطاق، مثل 256، فسيحدث _تجاوز العدد الصحيح_، والذي يمكن أن يؤدي إلى أحد سلوكين. عند الترجمة في وضع التصحيح، يتضمن Rust فحوصات لتجاوز الأعداد الصحيحة التي تتسبب في _الذعر_ لبرنامجك في وقت التشغيل إذا حدث هذا السلوك. يستخدم Rust مصطلح _الذعر_ عندما يخرج البرنامج مع خطأ؛ سنناقش حالات الذعر بشكل أكثر تفصيلاً في قسم [«الأخطاء غير القابلة للاسترداد مع `panic!`»][unrecoverable-errors-with-panic]<!-- ignore --> في الفصل التاسع.
>
> عند الترجمة في وضع الإصدار باستخدام علامة `--release`، لا يتضمن Rust فحوصات لتجاوز الأعداد الصحيحة التي تسبب الذعر. بدلاً من ذلك، إذا حدث تجاوز، يقوم Rust بإجراء _التفاف المتمم الثنائي_. باختصار، القيم الأكبر من القيمة القصوى التي يمكن للنوع الاحتفاظ بها «تلتف» إلى الحد الأدنى من القيم التي يمكن للنوع الاحتفاظ بها. في حالة `u8`، تصبح القيمة 256 هي 0، والقيمة 257 تصبح 1، وهكذا. لن يصاب البرنامج بالذعر، لكن المتغير سيكون له قيمة ربما لم تكن تتوقعها. يعتبر الاعتماد على سلوك التفاف تجاوز العدد الصحيح خطأً.
>
> للتعامل صراحةً مع احتمال التجاوز، يمكنك استخدام عائلات الطرق هذه التي توفرها المكتبة القياسية لأنواع الأرقام الأولية:
>
> - الالتفاف في جميع الأوضاع باستخدام طرق `wrapping_*`، مثل `wrapping_add`.
> - إرجاع قيمة `None` إذا كان هناك تجاوز باستخدام طرق `checked_*`.
> - إرجاع القيمة وقيمة منطقية تشير إلى ما إذا كان هناك تجاوز باستخدام طرق `overflowing_*`.
> - التشبع عند القيم الدنيا أو القصوى للقيمة باستخدام طرق `saturating_*`.

#### أنواع الفاصلة العائمة

يحتوي Rust أيضًا على نوعين أوليين لـ _أرقام الفاصلة العائمة_، وهي أرقام ذات نقاط عشرية. أنواع الفاصلة العائمة في Rust هي `f32` و `f64`، والتي تبلغ أحجامها 32 بتًا و 64 بتًا، على التوالي. النوع الافتراضي هو `f64` لأنه على وحدات المعالجة المركزية الحديثة، فإن سرعته تقريبًا نفس سرعة `f32` ولكنه قادر على مزيد من الدقة. جميع أنواع الفاصلة العائمة موقّعة.

إليك مثال يوضح أرقام الفاصلة العائمة أثناء العمل:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

يتم تمثيل أرقام الفاصلة العائمة وفقًا لمعيار IEEE-754.

#### العمليات الرقمية

يدعم Rust العمليات الرياضية الأساسية التي تتوقعها لجميع أنواع الأرقام: الجمع والطرح والضرب والقسمة والباقي. تقطع القسمة الصحيحة نحو الصفر إلى أقرب عدد صحيح. يوضح الكود التالي كيفية استخدام كل عملية رقمية في عبارة `let`:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

يستخدم كل تعبير في هذه العبارات عامل رياضي ويقيّم إلى قيمة واحدة، والتي يتم بعد ذلك ربطها بمتغير. يحتوي [الملحق B][appendix_b]<!-- ignore --> على قائمة بجميع العوامل التي توفرها Rust.

#### النوع المنطقي

كما في معظم لغات البرمجة الأخرى، فإن النوع المنطقي في Rust له قيمتان ممكنتان: `true` و `false`. القيم المنطقية بحجم بايت واحد. يتم تحديد النوع المنطقي في Rust باستخدام `bool`. على سبيل المثال:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

الطريقة الأساسية لاستخدام القيم المنطقية هي من خلال الشروط، مثل تعبير `if`. سنغطي كيفية عمل تعبيرات `if` في Rust في قسم [«تدفق التحكم»][control-flow]<!-- ignore -->.

#### نوع الحرف

نوع `char` في Rust هو النوع الأبجدي الأكثر بدائية في اللغة. فيما يلي بعض الأمثلة على إعلان قيم `char`:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

لاحظ أننا نحدد حرفيات `char` بعلامات الاقتباس المفردة، على عكس حرفيات السلسلة، التي تستخدم علامات الاقتباس المزدوجة. نوع `char` في Rust بحجم أربعة بايتات ويمثل قيمة Unicode Scalar، مما يعني أنه يمكن أن يمثل أكثر بكثير من مجرد ASCII. الحروف المشكّلة، والرموز التعبيرية الصينية واليابانية والكورية، والرموز التعبيرية، ومسافات العرض الصفرية كلها قيم `char` صالحة في Rust. تتراوح قيم Unicode Scalar من `U+0000` إلى `U+D7FF` ومن `U+E000` إلى `U+10FFFF` ضمناً. ومع ذلك، فإن «الحرف» ليس في الواقع مفهومًا في Unicode، لذا فإن حدسك البشري حول ماهية «الحرف» قد لا يتطابق مع ما هو `char` في Rust. سنناقش هذا الموضوع بالتفصيل في [«تخزين النص المشفر UTF-8 بالسلاسل»][strings]<!-- ignore --> في الفصل الثامن.

### الأنواع المركبة

يمكن للـ _أنواع المركبة_ ترجمة قيم متعددة في نوع واحد. يحتوي Rust على نوعين مركبين أوليين: المجموعات والمصفوفات.

#### نوع المجموعة

_المجموعة_ هي طريقة عامة لتجميع عدد من القيم بأنواع متنوعة في نوع مركب واحد. للمجموعات طول ثابت: بمجرد إعلانها، لا يمكنها النمو أو الانكماش في الحجم.

نقوم بإنشاء مجموعة عن طريق كتابة قائمة مفصولة بفواصل من القيم داخل أقواس. كل موضع في المجموعة له نوع، ولا يجب أن تكون أنواع القيم المختلفة في المجموعة هي نفسها. لقد أضفنا تعليقات توضيحية اختيارية للنوع في هذا المثال:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

يربط المتغير `tup` بالمجموعة بأكملها لأن المجموعة تعتبر عنصرًا مركبًا واحدًا. للحصول على القيم الفردية من المجموعة، يمكننا استخدام مطابقة النمط لتفكيك قيمة المجموعة، مثل هذا:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

ينشئ هذا البرنامج أولاً مجموعة ويربطها بالمتغير `tup`. ثم يستخدم نمطًا مع `let` لأخذ `tup` وتحويله إلى ثلاثة متغيرات منفصلة، `x` و `y` و `z`. يسمى هذا _التفكيك_ لأنه يكسر المجموعة الواحدة إلى ثلاثة أجزاء. أخيرًا، يطبع البرنامج قيمة `y`، وهي `6.4`.

يمكننا أيضًا الوصول إلى عنصر المجموعة مباشرة باستخدام نقطة (`.`) متبوعة بفهرس القيمة التي نريد الوصول إليها. على سبيل المثال:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

ينشئ هذا البرنامج المجموعة `x` ثم يصل إلى كل عنصر من عناصر المجموعة باستخدام فهارسها الخاصة. كما هو الحال مع معظم لغات البرمجة، يكون الفهرس الأول في المجموعة هو 0.

للمجموعة بدون أي قيم اسم خاص، _الوحدة_. يتم كتابة هذه القيمة ونوعها المقابل على حد سواء `()` وتمثل قيمة فارغة أو نوع إرجاع فارغ. تقوم التعبيرات ضمنيًا بإرجاع قيمة الوحدة إذا لم ترجع أي قيمة أخرى.

#### نوع المصفوفة

طريقة أخرى لوجود مجموعة من قيم متعددة هي باستخدام _مصفوفة_. على عكس المجموعة، يجب أن يكون لكل عنصر من عناصر المصفوفة نفس النوع. على عكس المصفوفات في بعض اللغات الأخرى، فإن المصفوفات في Rust لها طول ثابت.

نكتب القيم في المصفوفة كقائمة مفصولة بفواصل داخل أقواس مربعة:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

تكون المصفوفات مفيدة عندما تريد تخصيص بياناتك على المكدس، كما هو الحال مع الأنواع الأخرى التي رأيناها حتى الآن، بدلاً من الكومة (سنناقش المكدس والكومة بمزيد من التفاصيل في [الفصل الرابع][stack-and-heap]<!-- ignore -->) أو عندما تريد التأكد من أن لديك دائمًا عددًا ثابتًا من العناصر. المصفوفة ليست مرنة مثل نوع المتجه. المتجه هو نوع مجموعة مماثل يوفره المكتبة القياسية _يُسمح_ له بالنمو أو الانكماش في الحجم لأن محتوياته تعيش على الكومة. إذا لم تكن متأكدًا من استخدام مصفوفة أو متجه، فمن المحتمل أن تستخدم متجهًا. يناقش [الفصل الثامن][vectors]<!-- ignore --> المتجهات بمزيد من التفاصيل.

ومع ذلك، تكون المصفوفات أكثر فائدة عندما تعرف أن عدد العناصر لن يحتاج إلى التغيير. على سبيل المثال، إذا كنت تستخدم أسماء الأشهر في برنامج، فمن المحتمل أن تستخدم مصفوفة بدلاً من متجه لأنك تعلم أنها ستحتوي دائمًا على 12 عنصرًا:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

تكتب نوع المصفوفة باستخدام أقواس مربعة مع نوع كل عنصر، وفاصلة منقوطة، ثم عدد العناصر في المصفوفة، مثل هذا:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

هنا، `i32` هو نوع كل عنصر. بعد الفاصلة المنقوطة، يشير الرقم `5` إلى أن المصفوفة تحتوي على خمسة عناصر.

يمكنك أيضًا تهيئة مصفوفة لتحتوي على نفس القيمة لكل عنصر عن طريق تحديد القيمة الأولية، متبوعة بفاصلة منقوطة، ثم طول المصفوفة بين أقواس مربعة، كما هو موضح هنا:

```rust
let a = [3; 5];
```

ستحتوي المصفوفة المسماة `a` على `5` عناصر سيتم تعيينها جميعًا على القيمة `3` في البداية. هذا هو نفس كتابة `let a = [3, 3, 3, 3, 3];` ولكن بطريقة أكثر إيجازًا.

<!-- Old headings. Do not remove or links may break. -->

<a id="accessing-array-elements"></a>

#### الوصول إلى عناصر المصفوفة

المصفوفة هي جزء واحد من الذاكرة بحجم معروف وثابت يمكن تخصيصه على المكدس. يمكنك الوصول إلى عناصر المصفوفة باستخدام الفهرسة، مثل هذا:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

في هذا المثال، سيحصل المتغير المسمى `first` على القيمة `1` لأن هذه هي القيمة عند الفهرس `[0]` في المصفوفة. سيحصل المتغير المسمى `second` على القيمة `2` من الفهرس `[1]` في المصفوفة.

#### الوصول غير الصالح إلى عنصر المصفوفة

دعنا نرى ما يحدث إذا حاولت الوصول إلى عنصر من مصفوفة يتجاوز نهاية المصفوفة. لنفترض أنك تقوم بتشغيل هذا الكود، على غرار لعبة التخمين في الفصل الثاني، للحصول على فهرس مصفوفة من المستخدم:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

يتم ترجمة هذا الكود بنجاح. إذا قمت بتشغيل هذا الكود باستخدام `cargo run` وأدخلت `0` أو `1` أو `2` أو `3` أو `4`، فسيطبع البرنامج القيمة المقابلة عند ذلك الفهرس في المصفوفة. إذا أدخلت بدلاً من ذلك رقمًا يتجاوز نهاية المصفوفة، مثل `10`، فسترى إخراجًا مثل هذا:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

أدى البرنامج إلى خطأ في وقت التشغيل عند نقطة استخدام قيمة غير صالحة في عملية الفهرسة. خرج البرنامج برسالة خطأ ولم ينفذ عبارة `println!` النهائية. عندما تحاول الوصول إلى عنصر باستخدام الفهرسة، سيتحقق Rust من أن الفهرس الذي حددته أقل من طول المصفوفة. إذا كان الفهرس أكبر من أو يساوي الطول، فسيصاب Rust بالذعر. يجب أن يحدث هذا الفحص في وقت التشغيل، خاصة في هذه الحالة، لأن المصرِّف لا يمكنه معرفة القيمة التي سيدخلها المستخدم عندما يقوم بتشغيل الكود لاحقًا.

هذا مثال على مبادئ أمان الذاكرة في Rust أثناء العمل. في العديد من اللغات منخفضة المستوى، لا يتم إجراء هذا النوع من الفحص، وعندما تقدم فهرسًا غير صحيح، يمكن الوصول إلى ذاكرة غير صالحة. يحميك Rust من هذا النوع من الأخطاء عن طريق الخروج فورًا بدلاً من السماح بالوصول إلى الذاكرة والاستمرار. يناقش الفصل التاسع المزيد من معالجة الأخطاء في Rust وكيف يمكنك كتابة كود آمن وقابل للقراءة لا يصاب بالذعر ولا يسمح بالوصول إلى ذاكرة غير صالحة.

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[appendix_b]: appendix-02-operators.md
