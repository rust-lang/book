## ชนิดข้อมูล (Data Types)

ทุกค่าใน Rust มี _ชนิดข้อมูล_ (data type) ที่แน่นอน ซึ่งบอก Rust ว่ากำลังระบุข้อมูลชนิดใด เพื่อให้รู้ว่าจะทำงานกับข้อมูลนั้นอย่างไร เราจะดูชนิดข้อมูลสองกลุ่มย่อย: สเกลาร์ (scalar) และประสม (compound)

โปรดทราบว่า Rust เป็นภาษาที่มีการกำหนดชนิดข้อมูลแบบ _สแตติก_ (statically typed) ซึ่งหมายความว่าจะต้องทราบชนิดของตัวแปรทั้งหมดในขณะคอมไพล์ คอมไพเลอร์มักจะสามารถอนุมาน (infer) ได้ว่าเราต้องการใช้ชนิดข้อมูลใดโดยพิจารณาจากค่าและวิธีที่เราใช้งาน ในกรณีที่สามารถเป็นไปได้หลายชนิด เช่น เมื่อเราแปลง `String` เป็นชนิดตัวเลขโดยใช้ `parse` ในส่วน [“การเปรียบเทียบค่าที่ทายกับเลขลับ”][comparing-the-guess-to-the-secret-number]<!-- ignore --> ในบทที่ 2 เราจะต้องเพิ่มคำอธิบายประกอบชนิดข้อมูล (type annotation) ดังนี้:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

หากเราไม่เพิ่มคำอธิบายประกอบชนิดข้อมูล `: u32` ดังที่แสดงในโค้ดก่อนหน้า Rust จะแสดงข้อผิดพลาดต่อไปนี้ ซึ่งหมายความว่าคอมไพเลอร์ต้องการข้อมูลเพิ่มเติมจากเราเพื่อทราบว่าเราต้องการใช้ชนิดข้อมูลใด:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

คุณจะเห็นคำอธิบายประกอบชนิดข้อมูลที่แตกต่างกันสำหรับชนิดข้อมูลอื่นๆ

### ชนิดข้อมูลสเกลาร์ (Scalar Types)

ชนิดข้อมูล _สเกลาร์_ (scalar) แทนค่าเดียว Rust มีชนิดข้อมูลสเกลาร์หลักสี่ชนิด: จำนวนเต็ม (integers), เลขทศนิยม (floating-point numbers), บูลีน (Booleans) และอักขระ (characters) คุณอาจรู้จักชนิดข้อมูลเหล่านี้จากภาษาโปรแกรมอื่น มาดูกันว่ามันทำงานอย่างไรใน Rust

#### ชนิดข้อมูลจำนวนเต็ม (Integer Types)

_จำนวนเต็ม_ (integer) คือตัวเลขที่ไม่มีส่วนที่เป็นเศษส่วน เราใช้ชนิดข้อมูลจำนวนเต็มหนึ่งชนิดในบทที่ 2 คือชนิด `u32` การประกาศชนิดข้อมูลนี้บ่งชี้ว่าค่าที่เกี่ยวข้องควรเป็นจำนวนเต็มแบบไม่มีเครื่องหมาย (unsigned integer) (ชนิดข้อมูลจำนวนเต็มแบบมีเครื่องหมาย (signed integer) จะขึ้นต้นด้วย `i` แทน `u`) ซึ่งใช้พื้นที่ 32 บิต ตาราง 3-1 แสดงชนิดข้อมูลจำนวนเต็มในตัวของ Rust เราสามารถใช้ variant ใดๆ เหล่านี้เพื่อประกาศชนิดของค่าจำนวนเต็มได้

<span class="caption">ตาราง 3-1: ชนิดข้อมูลจำนวนเต็มใน Rust</span>

| ขนาด (Length)  | มีเครื่องหมาย (Signed)  | ไม่มีเครื่องหมาย (Unsigned) |
| ------- | ------- | -------- |
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| ขึ้นอยู่กับสถาปัตยกรรม (architecture dependent) | `isize` | `usize`  |

แต่ละ variant สามารถเป็นได้ทั้งแบบมีเครื่องหมายหรือไม่มีเครื่องหมาย และมีขนาดที่ชัดเจน _มีเครื่องหมาย_ (Signed) และ _ไม่มีเครื่องหมาย_ (unsigned) หมายถึงความเป็นไปได้ที่ตัวเลขจะเป็นค่าลบหรือไม่ กล่าวอีกนัยหนึ่งคือ ตัวเลขจำเป็นต้องมีเครื่องหมายบวกหรือลบกำกับหรือไม่ (มีเครื่องหมาย) หรือว่าตัวเลขนั้นจะเป็นบวกเสมอและสามารถแสดงได้โดยไม่มีเครื่องหมาย (ไม่มีเครื่องหมาย) มันเหมือนกับการเขียนตัวเลขบนกระดาษ: เมื่อเครื่องหมายมีความสำคัญ ตัวเลขจะแสดงด้วยเครื่องหมายบวกหรือลบ อย่างไรก็ตาม เมื่อมั่นใจได้ว่าตัวเลขเป็นบวก ก็จะแสดงโดยไม่มีเครื่องหมาย ตัวเลขแบบมีเครื่องหมายจะถูกเก็บโดยใช้การแทนค่าแบบ [ส่วนเติมเต็มสอง][twos-complement]<!-- ignore --> (two’s complement representation)

แต่ละ variant แบบมีเครื่องหมายสามารถเก็บตัวเลขได้ตั้งแต่ −(2<sup>n − 1</sup>) ถึง 2<sup>n − 1</sup> − 1 โดยที่ _n_ คือจำนวนบิตที่ variant นั้นใช้ ดังนั้น `i8` สามารถเก็บตัวเลขได้ตั้งแต่ −(2<sup>7</sup>) ถึง 2<sup>7</sup> − 1 ซึ่งเท่ากับ −128 ถึง 127 variant แบบไม่มีเครื่องหมายสามารถเก็บตัวเลขได้ตั้งแต่ 0 ถึง 2<sup>n</sup> − 1 ดังนั้น `u8` สามารถเก็บตัวเลขได้ตั้งแต่ 0 ถึง 2<sup>8</sup> − 1 ซึ่งเท่ากับ 0 ถึง 255

นอกจากนี้ ชนิด `isize` และ `usize` จะขึ้นอยู่กับสถาปัตยกรรมของคอมพิวเตอร์ที่โปรแกรมของคุณกำลังทำงานอยู่: 64 บิตหากคุณใช้สถาปัตยกรรม 64 บิต และ 32 บิตหากคุณใช้สถาปัตยกรรม 32 บิต

คุณสามารถเขียนค่าจำนวนเต็ม (integer literals) ในรูปแบบใดก็ได้ที่แสดงในตาราง 3-2 โปรดทราบว่าค่าตัวเลขที่สามารถเป็นได้หลายชนิดตัวเลขอนุญาตให้มีส่วนต่อท้ายชนิดข้อมูล (type suffix) เช่น `57u8` เพื่อกำหนดชนิดข้อมูล ค่าตัวเลขยังสามารถใช้ `_` เป็นตัวคั่นเพื่อให้อ่านตัวเลขได้ง่ายขึ้น เช่น `1_000` ซึ่งจะมีค่าเท่ากับ `1000`

<span class="caption">ตาราง 3-2: ค่าจำนวนเต็มใน Rust</span>

| ค่าตัวเลข (Number literals)  | ตัวอย่าง       |
| ---------------- | ------------- |
| เลขฐานสิบ (Decimal)          | `98_222`      |
| เลขฐานสิบหก (Hex)              | `0xff`        |
| เลขฐานแปด (Octal)            | `0o77`        |
| เลขฐานสอง (Binary)           | `0b1111_0000` |
| ไบต์ (Byte) (`u8` เท่านั้น) | `b'A'`        |

แล้วจะรู้ได้อย่างไรว่าควรใช้ชนิดข้อมูลจำนวนเต็มแบบใด? หากคุณไม่แน่ใจ ค่าเริ่มต้นของ Rust โดยทั่วไปเป็นจุดเริ่มต้นที่ดี: ชนิดข้อมูลจำนวนเต็มจะมีค่าเริ่มต้นเป็น `i32` สถานการณ์หลักที่คุณจะใช้ `isize` หรือ `usize` คือเมื่อทำการเข้าถึงดัชนี (indexing) ของ collection บางประเภท

> ##### Integer Overflow (จำนวนเต็มล้น)
>
> สมมติว่าคุณมีตัวแปรชนิด `u8` ที่สามารถเก็บค่าได้ระหว่าง 0 ถึง 255 หากคุณพยายามเปลี่ยนตัวแปรเป็นค่านอกช่วงนั้น เช่น 256 _integer overflow_ (จำนวนเต็มล้น) จะเกิดขึ้น ซึ่งอาจส่งผลให้เกิดพฤติกรรมหนึ่งในสองอย่าง เมื่อคุณคอมไพล์ในโหมดดีบัก Rust จะมีการตรวจสอบ integer overflow ที่ทำให้โปรแกรมของคุณ _panic_ (ตื่นตระหนก) ในขณะรันไทม์หากพฤติกรรมนี้เกิดขึ้น Rust ใช้คำว่า _panicking_ เมื่อโปรแกรมจบการทำงานพร้อมข้อผิดพลาด เราจะพูดถึง panic ในรายละเอียดเพิ่มเติมในส่วน [“ข้อผิดพลาดที่ไม่สามารถกู้คืนได้ด้วย `panic!`”][unrecoverable-errors-with-panic]<!-- ignore --> ในบทที่ 9
>
> เมื่อคุณคอมไพล์ในโหมด release ด้วยแฟล็ก `--release` Rust จะ _ไม่_ มีการตรวจสอบ integer overflow ที่ทำให้เกิด panic แทนที่จะเป็นเช่นนั้น หากเกิด overflow ขึ้น Rust จะทำการ _two’s complement wrapping_ (การวนครบรอบแบบส่วนเติมเต็มสอง) โดยสรุปคือ ค่าที่มากกว่าค่าสูงสุดที่ชนิดข้อมูลสามารถเก็บได้จะ “วนกลับ” ไปยังค่าต่ำสุดที่ชนิดข้อมูลสามารถเก็บได้ ในกรณีของ `u8` ค่า 256 จะกลายเป็น 0 ค่า 257 จะกลายเป็น 1 และต่อไปเรื่อยๆ โปรแกรมจะไม่ panic แต่ตัวแปรจะมีค่าที่อาจไม่ใช่สิ่งที่คุณคาดหวัง การพึ่งพาพฤติกรรมการวนครบรอบของ integer overflow ถือเป็นข้อผิดพลาด
>
> ในการจัดการกับความเป็นไปได้ของการ overflow อย่างชัดเจน คุณสามารถใช้กลุ่มของเมธอดเหล่านี้ที่ไลบรารีมาตรฐานมีให้สำหรับชนิดข้อมูลตัวเลขพื้นฐาน:
>
> - วนครบรอบในทุกโหมดด้วยเมธอด `wrapping_*` เช่น `wrapping_add`
> - คืนค่า `None` หากมีการ overflow ด้วยเมธอด `checked_*`
> - คืนค่าและค่าบูลีนที่ระบุว่ามีการ overflow หรือไม่ด้วยเมธอด `overflowing_*`
> - ทำให้ค่าอิ่มตัวที่ค่าต่ำสุดหรือสูงสุดของชนิดข้อมูลด้วยเมธอด `saturating_*`

#### ชนิดข้อมูลเลขทศนิยม (Floating-Point Types)

Rust ยังมีชนิดข้อมูลพื้นฐานสองชนิดสำหรับ _เลขทศนิยม_ (floating-point numbers) ซึ่งเป็นตัวเลขที่มีจุดทศนิยม ชนิดข้อมูลเลขทศนิยมของ Rust คือ `f32` และ `f64` ซึ่งมีขนาด 32 บิตและ 64 บิตตามลำดับ ชนิดข้อมูลเริ่มต้นคือ `f64` เนื่องจากบน CPU สมัยใหม่ มันมีความเร็วใกล้เคียงกับ `f32` แต่มีความแม่นยำมากกว่า ชนิดข้อมูลเลขทศนิยมทั้งหมดเป็นแบบมีเครื่องหมาย

นี่คือตัวอย่างที่แสดงการทำงานของเลขทศนิยม:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

เลขทศนิยมถูกแทนค่าตามมาตรฐาน IEEE-754

#### การดำเนินการทางตัวเลข (Numeric Operations)

Rust สนับสนุนการดำเนินการทางคณิตศาสตร์พื้นฐานที่คุณคาดหวังสำหรับชนิดข้อมูลตัวเลขทั้งหมด: การบวก, การลบ, การคูณ, การหาร และการหาเศษเหลือ การหารจำนวนเต็มจะปัดเศษเข้าหาศูนย์ไปยังจำนวนเต็มที่ใกล้ที่สุด โค้ดต่อไปนี้แสดงวิธีที่คุณจะใช้การดำเนินการทางตัวเลขแต่ละอย่างในคำสั่ง `let`:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

แต่ละนิพจน์ในคำสั่งเหล่านี้ใช้ตัวดำเนินการทางคณิตศาสตร์และประเมินผลเป็นค่าเดียว ซึ่งจากนั้นจะถูกผูกเข้ากับตัวแปร [ภาคผนวก B][appendix_b]<!-- ignore --> มีรายการตัวดำเนินการทั้งหมดที่ Rust มีให้

#### ชนิดข้อมูลบูลีน (The Boolean Type)

เช่นเดียวกับในภาษาโปรแกรมอื่นส่วนใหญ่ ชนิดข้อมูลบูลีนใน Rust มีสองค่าที่เป็นไปได้: `true` และ `false` บูลีนมีขนาดหนึ่งไบต์ ชนิดข้อมูลบูลีนใน Rust ระบุโดยใช้ `bool` ตัวอย่างเช่น:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

วิธีหลักในการใช้ค่าบูลีนคือผ่านเงื่อนไข เช่น นิพจน์ `if` เราจะครอบคลุมวิธีการทำงานของนิพจน์ `if` ใน Rust ในส่วน [“การควบคุมการทำงานของโปรแกรม”][control-flow]<!-- ignore -->

#### ชนิดข้อมูลอักขระ (The Character Type)

ชนิด `char` ของ Rust เป็นชนิดข้อมูลตัวอักษรพื้นฐานที่สุดของภาษา นี่คือตัวอย่างบางส่วนของการประกาศค่า `char`:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

โปรดทราบว่าเราระบุค่า `char` ด้วยเครื่องหมายอัญประกาศเดี่ยว (single quotes) ซึ่งแตกต่างจากค่าสตริง (string literals) ที่ใช้เครื่องหมายอัญประกาศคู่ (double quotes) ชนิด `char` ของ Rust มีขนาดสี่ไบต์และแทนค่าสเกลาร์ Unicode ซึ่งหมายความว่ามันสามารถแทนค่าได้มากกว่าแค่ ASCII ตัวอักษรที่มีเครื่องหมายกำกับเสียง (accented letters) อักขระจีน ญี่ปุ่น และเกาหลี อีโมจิ และช่องว่างที่ไม่มีความกว้าง (zero-width spaces) ล้วนเป็นค่า `char` ที่ถูกต้องใน Rust ค่าสเกลาร์ Unicode อยู่ในช่วงตั้งแต่ `U+0000` ถึง `U+D7FF` และ `U+E000` ถึง `U+10FFFF` โดยรวม อย่างไรก็ตาม “อักขระ” ไม่ใช่แนวคิดใน Unicode จริงๆ ดังนั้นสัญชาตญาณของมนุษย์เกี่ยวกับว่า “อักขระ” คืออะไรอาจไม่ตรงกับสิ่งที่ `char` เป็นใน Rust เราจะพูดถึงหัวข้อนี้โดยละเอียดใน [“การเก็บข้อความที่เข้ารหัสแบบ UTF-8 ด้วยสตริง”][strings]<!-- ignore --> ในบทที่ 8

### ชนิดข้อมูลประสม (Compound Types)

_ชนิดข้อมูลประสม_ (Compound types) สามารถจัดกลุ่มหลายค่าให้อยู่ในชนิดข้อมูลเดียวได้ Rust มีชนิดข้อมูลประสมพื้นฐานสองชนิด: ทูเพิล (tuples) และอาร์เรย์ (arrays)

#### ชนิดข้อมูลทูเพิล (The Tuple Type)

_ทูเพิล_ (tuple) เป็นวิธีการทั่วไปในการจัดกลุ่มค่าจำนวนหนึ่งที่มีชนิดข้อมูลหลากหลายให้อยู่ในชนิดข้อมูลประสมเดียว ทูเพิลมีความยาวคงที่: เมื่อประกาศแล้ว จะไม่สามารถเพิ่มหรือลดขนาดได้

เราสร้างทูเพิลโดยการเขียนรายการค่าที่คั่นด้วยจุลภาคภายในวงเล็บ แต่ละตำแหน่งในทูเพิลมีชนิดข้อมูล และชนิดข้อมูลของค่าต่างๆ ในทูเพิลไม่จำเป็นต้องเหมือนกัน เราได้เพิ่มคำอธิบายประกอบชนิดข้อมูลที่เป็นทางเลือกในตัวอย่างนี้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

ตัวแปร `tup` ผูกกับทูเพิลทั้งหมด เนื่องจากทูเพิลถือเป็นองค์ประกอบประสมเดียว ในการรับค่าแต่ละค่าออกจากทูเพิล เราสามารถใช้การจับคู่รูปแบบ (pattern matching) เพื่อแยกโครงสร้าง (destructure) ค่าทูเพิลได้ ดังนี้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

โปรแกรมนี้สร้างทูเพิลขึ้นก่อนแล้วผูกเข้ากับตัวแปร `tup` จากนั้นใช้รูปแบบกับ `let` เพื่อนำ `tup` มาเปลี่ยนเป็นตัวแปรแยกกันสามตัวคือ `x`, `y` และ `z` สิ่งนี้เรียกว่า _การแยกโครงสร้าง_ (destructuring) เพราะมันแบ่งทูเพิลเดียวออกเป็นสามส่วน สุดท้าย โปรแกรมจะพิมพ์ค่าของ `y` ซึ่งก็คือ `6.4`

เรายังสามารถเข้าถึงสมาชิกทูเพิลได้โดยตรงโดยใช้เครื่องหมายจุด (`.`) ตามด้วยดัชนีของค่าที่เราต้องการเข้าถึง ตัวอย่างเช่น:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

โปรแกรมนี้สร้างทูเพิล `x` แล้วเข้าถึงแต่ละสมาชิกของทูเพิลโดยใช้ดัชนีตามลำดับ เช่นเดียวกับภาษาโปรแกรมส่วนใหญ่ ดัชนีแรกในทูเพิลคือ 0

ทูเพิลที่ไม่มีค่าใดๆ มีชื่อพิเศษคือ _unit_ ค่านี้และชนิดข้อมูลที่สอดคล้องกันเขียนแทนด้วย `()` และแทนค่าว่างหรือชนิดข้อมูลส่งคืนที่ว่างเปล่า นิพจน์จะคืนค่า unit โดยปริยายหากไม่ได้คืนค่าอื่นใด

#### ชนิดข้อมูลอาร์เรย์ (The Array Type)

อีกวิธีหนึ่งในการมี collection ของหลายค่าคือการใช้ _อาร์เรย์_ (array) ซึ่งแตกต่างจากทูเพิลตรงที่ทุกสมาชิกของอาร์เรย์จะต้องมีชนิดข้อมูลเดียวกัน ซึ่งแตกต่างจากอาร์เรย์ในภาษาอื่นบางภาษา อาร์เรย์ใน Rust มีความยาวคงที่

เราเขียนค่าในอาร์เรย์เป็นรายการที่คั่นด้วยจุลภาคภายในวงเล็บเหลี่ยม:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

อาร์เรย์มีประโยชน์เมื่อคุณต้องการให้ข้อมูลของคุณถูกจัดสรรบน stack เช่นเดียวกับชนิดข้อมูลอื่นๆ ที่เราเคยเห็นมา แทนที่จะเป็น heap (เราจะพูดถึง stack และ heap เพิ่มเติมใน [บทที่ 4][stack-and-heap]<!-- ignore -->) หรือเมื่อคุณต้องการให้แน่ใจว่าคุณมีจำนวนสมาชิกคงที่เสมอ อาร์เรย์ไม่ได้ยืดหยุ่นเท่ากับชนิดข้อมูล vector อย่างไรก็ตาม _vector_ เป็นชนิดข้อมูล collection ที่คล้ายกันซึ่งไลบรารีมาตรฐานมีให้ และ _สามารถ_ เพิ่มหรือลดขนาดได้เนื่องจากเนื้อหาของมันอยู่บน heap หากคุณไม่แน่ใจว่าจะใช้อาร์เรย์หรือ vector โอกาสที่คุณควรใช้ vector จะสูงกว่า [บทที่ 8][vectors]<!-- ignore --> จะพูดถึง vector ในรายละเอียดเพิ่มเติม

อย่างไรก็ตาม อาร์เรย์มีประโยชน์มากกว่าเมื่อคุณทราบว่าจำนวนสมาชิกจะไม่จำเป็นต้องเปลี่ยนแปลง ตัวอย่างเช่น หากคุณใช้ชื่อเดือนในโปรแกรม คุณอาจจะใช้อาร์เรย์แทน vector เพราะคุณรู้ว่ามันจะมี 12 สมาชิกเสมอ:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

คุณเขียนชนิดข้อมูลของอาร์เรย์โดยใช้วงเล็บเหลี่ยมพร้อมด้วยชนิดข้อมูลของแต่ละสมาชิก เครื่องหมายอัฒภาค จากนั้นตามด้วยจำนวนสมาชิกในอาร์เรย์ ดังนี้:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

ในที่นี้ `i32` คือชนิดข้อมูลของแต่ละสมาชิก หลังเครื่องหมายอัฒภาค ตัวเลข `5` บ่งชี้ว่าอาร์เรย์มีห้าสมาชิก

คุณยังสามารถเริ่มต้นอาร์เรย์ให้มีค่าเดียวกันสำหรับแต่ละสมาชิกได้โดยการระบุค่าเริ่มต้น ตามด้วยเครื่องหมายอัฒภาค จากนั้นตามด้วยความยาวของอาร์เรย์ในวงเล็บเหลี่ยม ดังที่แสดงไว้ที่นี่:

```rust
let a = [3; 5];
```

อาร์เรย์ชื่อ `a` จะมี `5` สมาชิกซึ่งทั้งหมดจะถูกตั้งค่าเป็น `3` ในตอนเริ่มต้น นี่เหมือนกับการเขียน `let a = [3, 3, 3, 3, 3];` แต่วิธีนี้กระชับกว่า

##### การเข้าถึงสมาชิกอาร์เรย์ (Accessing Array Elements)

อาร์เรย์คือส่วนของหน่วยความจำก้อนเดียวที่มีขนาดที่ทราบและคงที่ซึ่งสามารถจัดสรรบน stack ได้ คุณสามารถเข้าถึงสมาชิกของอาร์เรย์โดยใช้การทำดัชนี (indexing) ดังนี้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

ในตัวอย่างนี้ ตัวแปรชื่อ `first` จะได้ค่า `1` เพราะนั่นคือค่าที่ดัชนี `[0]` ในอาร์เรย์ ตัวแปรชื่อ `second` จะได้ค่า `2` จากดัชนี `[1]` ในอาร์เรย์

##### การเข้าถึงสมาชิกอาร์เรย์ที่ไม่ถูกต้อง (Invalid Array Element Access)

เรามาดูกันว่าจะเกิดอะไรขึ้นหากคุณพยายามเข้าถึงสมาชิกของอาร์เรย์ที่อยู่เลยจุดสิ้นสุดของอาร์เรย์ สมมติว่าคุณรันโค้ดนี้ ซึ่งคล้ายกับเกมทายตัวเลขในบทที่ 2 เพื่อรับดัชนีอาร์เรย์จากผู้ใช้:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

โค้ดนี้คอมไพล์สำเร็จ หากคุณรันโค้ดนี้โดยใช้ `cargo run` และป้อน `0`, `1`, `2`, `3` หรือ `4` โปรแกรมจะพิมพ์ค่าที่สอดคล้องกันที่ดัชนีนั้นในอาร์เรย์ออกมา หากคุณป้อนตัวเลขที่อยู่เลยจุดสิ้นสุดของอาร์เรย์ เช่น `10` คุณจะเห็นผลลัพธ์ดังนี้:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

โปรแกรมเกิดข้อผิดพลาดขณะ _รันไทม์_ (runtime error) ณ จุดที่ใช้ค่าที่ไม่ถูกต้องในการดำเนินการทำดัชนี โปรแกรมจบการทำงานพร้อมข้อความแสดงข้อผิดพลาดและไม่ได้ εκτελέσιμο (execute) คำสั่ง `println!` สุดท้าย เมื่อคุณพยายามเข้าถึงสมาชิกโดยใช้การทำดัชนี Rust จะตรวจสอบว่าดัชนีที่คุณระบุนั้นน้อยกว่าความยาวของอาร์เรย์หรือไม่ หากดัชนีมากกว่าหรือเท่ากับความยาว Rust จะ panic การตรวจสอบนี้จะต้องเกิดขึ้นในขณะรันไทม์ โดยเฉพาะอย่างยิ่งในกรณีนี้ เนื่องจากคอมไพเลอร์ไม่สามารถทราบได้เลยว่าผู้ใช้จะป้อนค่าใดเมื่อพวกเขารันโค้ดในภายหลัง

นี่เป็นตัวอย่างของหลักการความปลอดภัยของหน่วยความจำ (memory safety principles) ของ Rust ในการทำงาน ในภาษาโปรแกรมระดับต่ำหลายภาษา การตรวจสอบประเภทนี้ไม่ได้ทำ และเมื่อคุณระบุที่ไม่ถูกต้อง อาจมีการเข้าถึงหน่วยความจำที่ไม่ถูกต้องได้ Rust ปกป้องคุณจากข้อผิดพลาดประเภทนี้โดยการจบการทำงานทันทีแทนที่จะอนุญาตให้เข้าถึงหน่วยความจำและดำเนินการต่อ บทที่ 9 จะพูดถึงการจัดการข้อผิดพลาดของ Rust เพิ่มเติม และวิธีที่คุณสามารถเขียนโค้ดที่อ่านง่ายและปลอดภัยซึ่งไม่ panic และไม่อนุญาตให้เข้าถึงหน่วยความจำที่ไม่ถูกต้อง

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[appendix_b]: appendix-02-operators.md
