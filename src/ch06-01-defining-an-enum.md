## تعريف تعداد (Enum)

بينما تمنحك الهياكل طريقة لتجميع الحقول والبيانات ذات الصلة معًا، مثل
`Rectangle` مع `width` و `height`، تمنحك التعدادات (enums) طريقة للقول إن
القيمة هي واحدة من مجموعة محتملة من القيم. على سبيل المثال، قد نرغب في القول إن
`Rectangle` هو واحد من مجموعة من الأشكال المحتملة التي تتضمن أيضًا `Circle` و
`Triangle`. للقيام بذلك، تسمح لنا Rust بتشفير هذه الاحتماليات كتعداد (enum).

لننظر إلى حالة قد نرغب في التعبير عنها في الكود ونرى لماذا التعدادات (enums)
مفيدة وأكثر ملاءمة من الهياكل في هذه الحالة. لنفترض أننا بحاجة إلى العمل
مع عناوين IP. حاليًا، يُستخدم معياران رئيسيان لعناوين IP:
الإصدار الرابع والإصدار السادس. نظرًا لأن هذه هي الاحتماليات الوحيدة لعنوان
IP الذي سيواجهه برنامجنا، يمكننا _تعداد_ جميع المتغيرات (variants) الممكنة، وهذا هو المكان الذي يحصل التعداد (enum) على اسمه منه.

يمكن أن يكون أي عنوان IP إما عنوان إصدار رابع أو إصدار سادس، ولكن ليس
كلاهما في نفس الوقت. تجعل هذه الخاصية من عناوين IP بنية البيانات التعدادية (enum)
مناسبة لأن قيمة التعداد (enum) يمكن أن تكون فقط واحدة من متغيراتها (variants).
كل من عناوين الإصدار الرابع والسادس لا تزال في الأساس عناوين IP، لذا يجب معاملتها كنفس النوع عندما يتعامل الكود مع
حالات تنطبق على أي نوع من عناوين IP.

يمكننا التعبير عن هذا المفهوم في الكود من خلال تعريف تعداد (enum) `IpAddrKind` و
إدراج الأنواع المحتملة التي يمكن أن يكون عليها عنوان IP، `V4` و `V6`. هذه هي
متغيرات (variants) التعداد (enum):

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:def}}
```

`IpAddrKind` هو الآن نوع بيانات مخصص يمكننا استخدامه في أي مكان آخر في كودنا.

### قيم التعداد (Enum Values)

يمكننا إنشاء نُسخ من كل متغير (variant) من المتغيرين (variants) لـ `IpAddrKind` بهذه الطريقة:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:instance}}
```

لاحظ أن متغيرات (variants) التعداد (enum) موضوعة في نطاق معرفها، ونحن
نستخدم نقطتين مزدوجتين لفصل الاثنين. هذا مفيد لأن الآن كلتا القيمتين
`IpAddrKind::V4` و `IpAddrKind::V6` من نفس النوع: `IpAddrKind`. يمكننا
بعد ذلك، على سبيل المثال، تعريف دالة تأخذ أي `IpAddrKind`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn}}
```

ويمكننا استدعاء هذه الدالة بأي من المتغيرين (variants):

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn_call}}
```

استخدام التعدادات (enums) له مزايا أكثر. عند التفكير أكثر في نوع عنوان IP الخاص بنا،
في الوقت الحالي ليس لدينا طريقة لتخزين _بيانات_ عنوان IP الفعلية؛ نحن
فقط نعرف _نوعه_. نظرًا لأنك تعلمت للتو عن الهياكل في
الفصل 5، قد تميل إلى معالجة هذه المشكلة بالهياكل كما هو موضح في
القائمة 6-1.

<Listing number="6-1" caption="تخزين البيانات ومتغير (variant) `IpAddrKind` لعنوان IP باستخدام `struct`">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-01/src/main.rs:here}}
```

</Listing>

هنا، قمنا بتعريف هيكل `IpAddr` الذي يحتوي على حقلين: حقل `kind` الذي
من نوع `IpAddrKind` (التعداد (enum) الذي عرفناه سابقًا) وحقل `address`
من نوع `String`. لدينا نسختان من هذا الهيكل. الأولى هي `home`،
ولديها القيمة `IpAddrKind::V4` كـ `kind` مع بيانات العنوان المرتبطة
`127.0.0.1`. النسخة الثانية هي `loopback`. لديها المتغير (variant) الآخر
من `IpAddrKind` كقيمة `kind`، `V6`، ولديها العنوان `::1`
مرتبط بها. لقد استخدمنا هيكلًا لتجميع قيم `kind` و `address`
معًا، لذا الآن المتغير (variant) مرتبط بالقيمة.

ومع ذلك، فإن تمثيل نفس المفهوم باستخدام تعداد (enum) فقط أكثر إيجازًا:
بدلاً من تعداد (enum) داخل هيكل، يمكننا وضع البيانات مباشرة في كل متغير (variant)
من التعداد (enum). هذا التعريف الجديد لتعداد (enum) `IpAddr` يقول إن كل من متغيري (variants) `V4` و `V6`
سيكون لهما قيم `String` مرتبطة:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-02-enum-with-data/src/main.rs:here}}
```

نحن نربط البيانات بكل متغير (variant) من التعداد (enum) مباشرة، لذا لا حاجة
لهيكل إضافي. هنا، من الأسهل أيضًا رؤية تفصيل آخر حول كيفية عمل التعدادات (enums):
يصبح اسم كل متغير (variant) من التعداد (enum) الذي نعرفه أيضًا دالة تبني نسخة من التعداد (enum). أي، `IpAddr::V4()` هي استدعاء دالة
يأخذ وسيط `String` ويُرجع نسخة من نوع `IpAddr`. نحن
نحصل تلقائيًا على دالة البناء هذه المُعرّفة كنتيجة لتعريف
التعداد (enum).

هناك ميزة أخرى لاستخدام تعداد (enum) بدلاً من هيكل: يمكن أن يكون لكل متغير (variant)
أنواع وكميات مختلفة من البيانات المرتبطة. عناوين IP الإصدار الرابع
سيكون لديها دائمًا أربعة مكونات رقمية ستكون لها قيم
بين 0 و 255. إذا أردنا تخزين عناوين `V4` كأربع قيم `u8` ولكن
لا نزال نعبر عن عناوين `V6` كقيمة `String` واحدة، فلن نتمكن من ذلك مع
هيكل. تتعامل التعدادات (enums) مع هذه الحالة بسهولة:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-03-variants-with-different-data/src/main.rs:here}}
```

لقد أظهرنا عدة طرق مختلفة لتعريف هياكل البيانات لتخزين الإصدار
الرابع والسادس من عناوين IP. ومع ذلك، اتضح أن الرغبة في تخزين
عناوين IP وتشفير نوعها شائعة جدًا لدرجة أن [المكتبة القياسية
لديها تعريف يمكننا استخدامه!][IpAddr]<!-- ignore --> لننظر إلى كيفية
تعريف المكتبة القياسية لـ `IpAddr`. لديها التعداد (enum) والمتغيرات (variants) بالضبط التي
عرفناها واستخدمناها، لكنها تضمّن بيانات العنوان داخل المتغيرات (variants) في
شكل هيكلين مختلفين، معرفان بشكل مختلف لكل
متغير (variant):

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

يوضح هذا الكود أنه يمكنك وضع أي نوع من البيانات داخل متغير (variant) التعداد (enum):
سلاسل نصية، أنواع رقمية، أو هياكل، على سبيل المثال. يمكنك حتى تضمين تعداد (enum) آخر! أيضًا، أنواع المكتبة القياسية غالبًا ليست أكثر تعقيدًا بكثير مما
قد تتوصل إليه.

لاحظ أنه على الرغم من أن المكتبة القياسية تحتوي على تعريف لـ `IpAddr`،
لا يزال بإمكاننا إنشاء واستخدام تعريفنا الخاص دون تعارض لأننا
لم نجلب تعريف المكتبة القياسية إلى نطاقنا. سنتحدث
أكثر عن جلب الأنواع إلى النطاق في الفصل 7.

لننظر إلى مثال آخر لتعداد (enum) في القائمة 6-2: هذا يحتوي على تنوع واسع
من الأنواع المضمنة في متغيراته (variants).

<Listing number="6-2" caption="تعداد (enum) `Message` الذي تخزن متغيراته (variants) كميات وأنواعًا مختلفة من القيم">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

</Listing>

هذا التعداد (enum) يحتوي على أربعة متغيرات (variants) بأنواع مختلفة:

- `Quit`: ليس لديه بيانات مرتبطة به على الإطلاق
- `Move`: لديه حقول مسماة، مثل الهيكل
- `Write`: يتضمن `String` واحد
- `ChangeColor`: يتضمن ثلاث قيم `i32`

تعريف تعداد (enum) بمتغيرات (variants) مثل تلك الموجودة في القائمة 6-2 مشابه
لتعريف أنواع مختلفة من تعريفات الهياكل، باستثناء أن التعداد (enum) لا يستخدم
كلمة `struct` وجميع المتغيرات (variants) مجمعة معًا تحت نوع `Message`. يمكن للهياكل التالية أن تحمل نفس البيانات التي تحملها متغيرات (variants) التعداد (enum) السابقة:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-04-structs-similar-to-message-enum/src/main.rs:here}}
```

ولكن إذا استخدمنا هياكل مختلفة، كل منها له نوعه الخاص، فلا
يمكننا بسهولة تعريف دالة تأخذ أيًا من هذه الأنواع من الرسائل كما
يمكننا مع تعداد (enum) `Message` المُعرّف في القائمة 6-2، والذي هو نوع واحد.

هناك تشابه آخر بين التعدادات (enums) والهياكل: تمامًا كما نستطيع
تعريف دوال على الهياكل باستخدام `impl`، نستطيع أيضًا تعريف دوال على
التعدادات (enums). هنا دالة تسمى `call` يمكننا تعريفها على تعداد (enum) `Message` الخاص بنا:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-05-methods-on-enums/src/main.rs:here}}
```

سيستخدم جسم الدالة `self` للحصول على القيمة التي استدعينا عليها
الدالة. في هذا المثال، أنشأنا متغير `m` الذي يحتوي على القيمة
`Message::Write(String::from("hello"))`، وهذا ما سيكون `self` في
جسم دالة `call` عندما يتم تشغيل `m.call()`.

لننظر إلى تعداد (enum) آخر في المكتبة القياسية شائع جدًا
ومفيد: `Option`.

<!-- Old headings. Do not remove or links may break. -->

<a id="the-option-enum-and-its-advantages-over-null-values"></a>

### تعداد (Enum) `Option`

يستكشف هذا القسم دراسة حالة لـ `Option`، وهو تعداد (enum) آخر معرف
من قبل المكتبة القياسية. يشفّر نوع `Option` السيناريو الشائع جدًا الذي
فيه يمكن أن تكون القيمة شيئًا ما، أو يمكن أن تكون لا شيء.

على سبيل المثال، إذا طلبت العنصر الأول في قائمة غير فارغة، ستحصل على
قيمة. إذا طلبت العنصر الأول في قائمة فارغة، ستحصل على لا شيء.
التعبير عن هذا المفهوم من حيث نظام الأنواع يعني أن المصرِّف يمكنه
التحقق مما إذا كنت قد تعاملت مع جميع الحالات التي يجب عليك التعامل معها؛ هذه
الوظيفة يمكن أن تمنع أخطاء شائعة للغاية في لغات البرمجة الأخرى.

غالبًا ما يُفكر في تصميم لغة البرمجة من حيث الميزات التي تتضمنها، لكن الميزات التي تستبعدها مهمة أيضًا. لا تحتوي Rust على
ميزة null الموجودة في العديد من اللغات الأخرى. _Null_ هي قيمة تعني عدم وجود
قيمة هناك. في اللغات التي تحتوي على null، يمكن أن تكون المتغيرات دائمًا في واحدة من
حالتين: null أو not-null.

في عرضه التقديمي عام 2009 "مراجع Null: خطأ المليار دولار"، قال توني
هوار، مخترع null، هذا:

> أسميه خطأي بمليار دولار. في ذلك الوقت، كنت أصمم أول
> نظام أنواع شامل للمراجع في لغة موجهة للكائنات. كان
> هدفي هو التأكد من أن جميع استخدامات المراجع يجب أن تكون آمنة تمامًا، مع
> فحص يتم تلقائيًا بواسطة المصرِّف. لكنني لم أستطع مقاومة
> إغراء وضع مرجع null، لأنه كان من السهل جدًا
> تنفيذه. أدى هذا إلى أخطاء لا حصر لها، وثغرات أمنية، وانهيارات نظام، والتي ربما تسببت في مليار دولار من الألم والضرر في
> الأربعين عامًا الماضية.

المشكلة مع قيم null هي أنه إذا حاولت استخدام قيمة null كقيمة
not-null، ستحصل على خطأ من نوع ما. نظرًا لأن خاصية null أو not-null هذه
منتشرة، فمن السهل للغاية ارتكاب هذا النوع من الأخطاء.

ومع ذلك، فإن المفهوم الذي يحاول null التعبير عنه لا يزال مفيدًا: null هي قيمة غير صالحة حاليًا أو غائبة لسبب ما.

المشكلة ليست حقًا مع المفهوم ولكن مع التنفيذ المحدد. على هذا النحو، لا تحتوي Rust على nulls، لكنها تحتوي على تعداد (enum)
يمكنه تشفير مفهوم وجود أو غياب قيمة. هذا التعداد (enum) هو
`Option<T>`، وهو [معرف من قبل المكتبة القياسية][option]<!-- ignore -->
على النحو التالي:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

تعداد (enum) `Option<T>` مفيد جدًا لدرجة أنه مُضمّن حتى في المقدمة؛ أنت
لست بحاجة لجلبه إلى النطاق صراحةً. متغيراته (variants) مضمنة أيضًا في
المقدمة: يمكنك استخدام `Some` و `None` مباشرة دون بادئة `Option::`. تعداد (enum) `Option<T>` لا يزال مجرد تعداد (enum) عادي، و `Some(T)` و
`None` لا تزال متغيرات (variants) من نوع `Option<T>`.

الصياغة `<T>` هي ميزة من Rust لم نتحدث عنها بعد. إنها
معامل نوع عمومي، وسنغطي الأنواع العمومية بمزيد من التفصيل في الفصل 10.
في الوقت الحالي، كل ما تحتاج معرفته هو أن `<T>` يعني أن متغير (variant) `Some` من
تعداد (enum) `Option` يمكن أن يحمل قطعة واحدة من البيانات من أي نوع، وأن كل
نوع محدد يُستخدم بدلاً من `T` يجعل نوع `Option<T>` الكلي
نوعًا مختلفًا. إليك بعض الأمثلة على استخدام قيم `Option` لحمل
أنواع الأرقام وأنواع char:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here}}
```

نوع `some_number` هو `Option<i32>`. نوع `some_char` هو
`Option<char>`، وهو نوع مختلف. يمكن لـ Rust استنتاج هذه الأنواع لأننا
حددنا قيمة داخل متغير (variant) `Some`. بالنسبة لـ `absent_number`، تطلب Rust
منا أن نضيف تعليقًا توضيحيًا على نوع `Option` الكلي: لا يمكن للمصرِّف استنتاج
النوع الذي سيحمله متغير (variant) `Some` المقابل بالنظر فقط إلى قيمة
`None`. هنا، نخبر Rust أننا نعني أن `absent_number` من نوع
`Option<i32>`.

عندما يكون لدينا قيمة `Some`، نعلم أن هناك قيمة موجودة، وأن القيمة
محفوظة داخل `Some`. عندما يكون لدينا قيمة `None`، بمعنى ما تعني
نفس الشيء مثل null: ليس لدينا قيمة صالحة. إذن، لماذا وجود `Option<T>`
أفضل من وجود null؟

باختصار، لأن `Option<T>` و `T` (حيث يمكن أن يكون `T` أي نوع) نوعان مختلفان، لن يسمح لنا المصرِّف باستخدام قيمة `Option<T>` كما لو كانت
بالتأكيد قيمة صالحة. على سبيل المثال، لن يتم ترجمة هذا الكود، لأنه
يحاول إضافة `i8` إلى `Option<i8>`:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here}}
```

إذا قمنا بتشغيل هذا الكود، سنحصل على رسالة خطأ مثل هذه:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}
```

قوي! في الواقع، تعني رسالة الخطأ هذه أن Rust لا تفهم كيفية
إضافة `i8` و `Option<i8>`، لأنهما نوعان مختلفان. عندما يكون لدينا
قيمة من نوع مثل `i8` في Rust، سيضمن المصرِّف أن لدينا
دائمًا قيمة صالحة. يمكننا المضي قدمًا بثقة دون الحاجة إلى التحقق
من null قبل استخدام تلك القيمة. فقط عندما يكون لدينا `Option<i8>` (أو
أي نوع من القيم التي نعمل بها) يتعين علينا القلق بشأن عدم
وجود قيمة محتملاً، وسيتأكد المصرِّف من أننا نتعامل مع تلك الحالة قبل
استخدام القيمة.

بعبارة أخرى، يجب عليك تحويل `Option<T>` إلى `T` قبل أن تتمكن من
إجراء عمليات `T` معه. بشكل عام، هذا يساعد في اكتشاف واحدة من أكثر
المشكلات شيوعًا مع null: افتراض أن شيئًا ما ليس null عندما يكون في الواقع كذلك.

القضاء على خطر الافتراض الخاطئ بأن القيمة not-null يساعدك على أن تكون أكثر
ثقة في كودك. لكي يكون لديك قيمة يمكن أن تكون null، يجب
عليك الاشتراك صراحةً من خلال جعل نوع تلك القيمة `Option<T>`. بعد ذلك، عندما
تستخدم تلك القيمة، يُطلب منك التعامل صراحة مع الحالة التي تكون فيها
القيمة null. في كل مكان تكون فيه القيمة من نوع ليس `Option<T>`،
_يمكنك_ افتراض بأمان أن القيمة ليست null. كان هذا قرار تصميم
متعمدًا لـ Rust للحد من انتشار null وزيادة أمان كود Rust.

إذن كيف تحصل على قيمة `T` من متغير (variant) `Some` عندما يكون لديك قيمة
من نوع `Option<T>` حتى تتمكن من استخدام تلك القيمة؟ تعداد (enum) `Option<T>` لديه
عدد كبير من الدوال المفيدة في مجموعة متنوعة من الحالات؛ يمكنك
التحقق منها في [وثائقها][docs]<!-- ignore -->. التعرف على
الدوال الموجودة على `Option<T>` سيكون مفيدًا للغاية في رحلتك مع
Rust.

بشكل عام، لكي تستخدم قيمة `Option<T>`، تريد أن يكون لديك كود
سيتعامل مع كل متغير (variant). تريد بعض الكود الذي سيعمل فقط عندما يكون لديك
قيمة `Some(T)`، وهذا الكود مسموح له باستخدام `T` الداخلي. تريد بعض
الكود الآخر ليعمل فقط إذا كان لديك قيمة `None`، وهذا الكود لا يحتوي على
قيمة `T` متاحة. تعبير `match` هو بناء تحكم في التدفق
يقوم بذلك بالضبط عند استخدامه مع التعدادات (enums): سيقوم بتشغيل كود مختلف اعتمادًا على
متغير (variant) التعداد (enum) الموجود لديه، ويمكن لهذا الكود استخدام البيانات الموجودة داخل القيمة
المطابقة.

[IpAddr]: ../std/net/enum.IpAddr.html
[option]: ../std/option/enum.Option.html
[docs]: ../std/option/enum.Option.html
