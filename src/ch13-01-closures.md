<!-- Old headings. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>
<a id="closures-anonymous-functions-that-capture-their-environment"></a>

## الإغلاقات

الإغلاقات (Closures) في Rust هي دوال مجهولة الهوية يمكنك حفظها في متغيّر أو تمريرها كوسائط إلى دوال أخرى. يمكنك إنشاء الإغلاق في مكان واحد ثم استدعاء الإغلاق في مكان آخر لتقييمه في سياق مختلف. على عكس الدوال، يمكن للإغلاقات التقاط القيم من النطاق الذي تم تعريفها فيه. سنوضح كيف تسمح ميزات الإغلاق هذه بإعادة استخدام الكود وتخصيص السلوك.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>
<a id="capturing-the-environment-with-closures"></a>

### التقاط البيئة

سنفحص أولاً كيف يمكننا استخدام الإغلاقات لالتقاط القيم من البيئة التي تم تعريفها فيها للاستخدام لاحقًا. إليك السيناريو: من حين لآخر، تقدم شركة القمصان الخاصة بنا قميصًا حصريًا ومحدود الإصدار لشخص ما في قائمتنا البريدية كعرض ترويجي. يمكن للأشخاص في القائمة البريدية إضافة لونهم المفضل اختياريًا إلى ملفهم الشخصي. إذا كان الشخص المختار للقميص المجاني قد حدد لونه المفضل، فسيحصل على قميص بهذا اللون. إذا لم يحدد الشخص لونًا مفضلاً، فسيحصل على اللون الذي لدى الشركة أكثر منه حاليًا.

هناك طرق عديدة لتنفيذ ذلك. في هذا المثال، سنستخدم تعدادًا يسمى `ShirtColor` يحتوي على المتغيرات `Red` و `Blue` (لتقليل عدد الألوان المتاحة من أجل البساطة). نمثل مخزون الشركة ببنية `Inventory` التي تحتوي على حقل يسمى `shirts` يحتوي على `Vec<ShirtColor>` يمثل ألوان القمصان المتوفرة حاليًا في المخزون. الدالة `giveaway` المعرفة على `Inventory` تحصل على تفضيل لون القميص الاختياري لفائز القميص المجاني، وتعيد لون القميص الذي سيحصل عليه الشخص. هذا الإعداد موضح في القائمة 13-1.

<Listing number="13-1" file-name="src/main.rs" caption="موقف شركة القمصان للهدايا المجانية">

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

</Listing>

المتجر `store` المعرف في `main` لديه قميصان أزرقان وقميص أحمر واحد متبقي للتوزيع في هذا العرض الترويجي المحدود الإصدار. نستدعي دالة `giveaway` لمستخدم لديه تفضيل لقميص أحمر ومستخدم ليس لديه أي تفضيل.

مرة أخرى، يمكن تنفيذ هذا الكود بطرق عديدة، وهنا، للتركيز على الإغلاقات، التزمنا بالمفاهيم التي تعلمتها بالفعل، باستثناء جسم دالة `giveaway` التي تستخدم إغلاقًا. في دالة `giveaway`، نحصل على تفضيل المستخدم كمعامل من النوع `Option<ShirtColor>` ونستدعي دالة `unwrap_or_else` على `user_preference`. [دالة `unwrap_or_else` على `Option<T>`][unwrap-or-else]<!-- ignore --> معرفة بواسطة المكتبة القياسية. تأخذ وسيطًا واحدًا: إغلاقًا بدون أي وسائط يعيد قيمة `T` (نفس النوع المخزن في متغير `Some` من `Option<T>`، في هذه الحالة `ShirtColor`). إذا كان `Option<T>` هو متغير `Some`، فإن `unwrap_or_else` تعيد القيمة من داخل `Some`. إذا كان `Option<T>` هو متغير `None`، فإن `unwrap_or_else` تستدعي الإغلاق وتعيد القيمة المعادة بواسطة الإغلاق.

نحدد تعبير الإغلاق `|| self.most_stocked()` كوسيط لـ `unwrap_or_else`. هذا إغلاق لا يأخذ معاملات بنفسه (إذا كان للإغلاق معاملات، فستظهر بين الأنبوبين العموديين). جسم الإغلاق يستدعي `self.most_stocked()`. نقوم بتعريف الإغلاق هنا، وتنفيذ `unwrap_or_else` سيقوم بتقييم الإغلاق لاحقًا إذا لزمت النتيجة.

تشغيل هذا الكود يطبع ما يلي:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

أحد الجوانب المثيرة للاهتمام هنا هو أننا قمنا بتمرير إغلاق يستدعي `self.most_stocked()` على نسخة `Inventory` الحالية. لم تكن المكتبة القياسية بحاجة إلى معرفة أي شيء عن أنواع `Inventory` أو `ShirtColor` التي عرفناها، أو المنطق الذي نريد استخدامه في هذا السيناريو. يلتقط الإغلاق مَرجِعًا غير قابل للتغيير إلى نسخة `Inventory` المشار إليها بـ `self` ويمررها مع الكود الذي نحدده إلى دالة `unwrap_or_else`. من ناحية أخرى، الدوال غير قادرة على التقاط بيئتها بهذه الطريقة.

<!-- Old headings. Do not remove or links may break. -->

<a id="closure-type-inference-and-annotation"></a>

### استنتاج أنواع الإغلاق والتعليق عليها

هناك المزيد من الاختلافات بين الدوال والإغلاقات. عادةً لا تتطلب الإغلاقات منك التعليق على أنواع المعاملات أو قيمة الإرجاع مثل دوال `fn`. التعليقات على الأنواع مطلوبة في الدوال لأن الأنواع جزء من واجهة صريحة معروضة لمستخدميك. تعريف هذه الواجهة بشكل صارم مهم لضمان موافقة الجميع على أنواع القيم التي تستخدمها الدالة وتعيدها. من ناحية أخرى، لا يتم استخدام الإغلاقات في واجهة معروضة مثل هذه: يتم تخزينها في متغيرات، ويتم استخدامها دون تسميتها وعرضها لمستخدمي مكتبتنا.

عادةً ما تكون الإغلاقات قصيرة وذات صلة فقط ضمن سياق ضيق بدلاً من أي سيناريو عشوائي. ضمن هذه السياقات المحدودة، يمكن للمصرِّف استنتاج أنواع المعاملات ونوع الإرجاع، بطريقة مشابهة لكيفية قدرته على استنتاج أنواع معظم المتغيرات (هناك حالات نادرة يحتاج فيها المصرِّف إلى تعليقات نوع الإغلاق أيضًا).

كما هو الحال مع المتغيرات، يمكننا إضافة تعليقات الأنواع إذا أردنا زيادة الوضوح والوضوح بتكلفة أن نكون أكثر إسهابًا مما هو ضروري بشكل صارم. التعليق على الأنواع للإغلاق سيبدو مثل التعريف الموضح في القائمة 13-2. في هذا المثال، نقوم بتعريف إغلاق وتخزينه في متغيّر بدلاً من تعريف الإغلاق في المكان الذي نمرره فيه كوسيط، كما فعلنا في القائمة 13-1.

<Listing number="13-2" file-name="src/main.rs" caption="إضافة تعليقات نوع اختيارية لأنواع المعامل وقيمة الإرجاع في الإغلاق">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

</Listing>

مع إضافة تعليقات الأنواع، يبدو صيغة الإغلاقات أكثر شبهاً بصيغة الدوال. هنا، نعرف دالة تضيف 1 إلى معاملها وإغلاقًا له نفس السلوك، للمقارنة. أضفنا بعض المسافات لمحاذاة الأجزاء ذات الصلة. يوضح هذا كيف أن صيغة الإغلاق تشبه صيغة الدالة باستثناء استخدام الأنابيب وكمية الصيغة الاختيارية:

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

السطر الأول يُظهر تعريف دالة والسطر الثاني يُظهر تعريف إغلاق مع تعليق كامل. في السطر الثالث، نزيل تعليقات الأنواع من تعريف الإغلاق. في السطر الرابع، نزيل الأقواس المعقوفة، وهي اختيارية لأن جسم الإغلاق يحتوي على تعبير واحد فقط. هذه كلها تعريفات صالحة ستنتج نفس السلوك عند استدعائها. تتطلب أسطر `add_one_v3` و `add_one_v4` تقييم الإغلاقات لتكون قادرة على الترجمة لأن الأنواع سيتم استنتاجها من استخدامها. هذا مشابه لـ `let v = Vec::new();` التي تحتاج إما إلى تعليقات الأنواع أو قيم من نوع ما لإدراجها في `Vec` لكي يتمكن Rust من استنتاج النوع.

بالنسبة لتعريفات الإغلاق، سيستنتج المصرِّف نوعًا محددًا واحدًا لكل من معاملاتها وقيمة الإرجاع. على سبيل المثال، تُظهر القائمة 13-3 تعريف إغلاق قصير يعيد فقط القيمة التي يتلقاها كمعامل. هذا الإغلاق ليس مفيدًا جدًا إلا لأغراض هذا المثال. لاحظ أننا لم نضف أي تعليقات نوع إلى التعريف. نظرًا لعدم وجود تعليقات نوع، يمكننا استدعاء الإغلاق بأي نوع، وهو ما فعلناه هنا مع `String` في المرة الأولى. إذا حاولنا بعد ذلك استدعاء `example_closure` بعدد صحيح، فسنحصل على خطأ.

<Listing number="13-3" file-name="src/main.rs" caption="محاولة استدعاء إغلاق يتم استنتاج أنواعه بنوعين مختلفين">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

</Listing>

يعطينا المصرِّف هذا الخطأ:

```console
{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
```

في المرة الأولى التي نستدعي فيها `example_closure` بقيمة `String`، يستنتج المصرِّف نوع `x` ونوع الإرجاع للإغلاق ليكون `String`. ثم يتم قفل هذه الأنواع في الإغلاق في `example_closure`، ونحصل على خطأ في النوع عندما نحاول بعد ذلك استخدام نوع مختلف مع نفس الإغلاق.

### التقاط المَراجِع أو نقل الملكية

يمكن للإغلاقات التقاط القيم من بيئتها بثلاث طرق، والتي ترتبط مباشرة بالطرق الثلاث التي يمكن للدالة أن تأخذ بها معاملاً: الاستعارة بشكل غير قابل للتغيير، والاستعارة بشكل قابل للتغيير، وأخذ الملكية. سيقرر الإغلاق أيًا من هذه الطرق سيستخدم بناءً على ما يفعله جسم الدالة بالقيم الملتقطة.

في القائمة 13-4، نعرف إغلاقًا يلتقط مَرجِعًا غير قابل للتغيير إلى المتجه المسمى `list` لأنه يحتاج فقط إلى مَرجِع غير قابل للتغيير لطباعة القيمة.

<Listing number="13-4" file-name="src/main.rs" caption="تعريف واستدعاء إغلاق يلتقط مَرجِعًا غير قابل للتغيير">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
```

</Listing>

يوضح هذا المثال أيضًا أن متغيّرًا يمكن أن يرتبط بتعريف إغلاق، ويمكننا لاحقًا استدعاء الإغلاق باستخدام اسم المتغيّر والأقواس كما لو كان اسم المتغيّر اسم دالة.

نظرًا لأنه يمكننا الحصول على مَراجِع متعددة غير قابلة للتغيير إلى `list` في نفس الوقت، لا يزال `list` قابلاً للوصول من الكود قبل تعريف الإغلاق، وبعد تعريف الإغلاق ولكن قبل استدعاء الإغلاق، وبعد استدعاء الإغلاق. يترجم هذا الكود، ويعمل، ويطبع:

```console
{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
```

بعد ذلك، في القائمة 13-5، نغير جسم الإغلاق بحيث يضيف عنصرًا إلى متجه `list`. الإغلاق الآن يلتقط مَرجِعًا قابلاً للتغيير.

<Listing number="13-5" file-name="src/main.rs" caption="تعريف واستدعاء إغلاق يلتقط مَرجِعًا قابلاً للتغيير">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
```

</Listing>

يترجم هذا الكود، ويعمل، ويطبع:

```console
{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
```

لاحظ أنه لا يوجد `println!` بعد الآن بين التعريف والاستدعاء للإغلاق `borrows_mutably`: عندما يتم تعريف `borrows_mutably`، يلتقط مَرجِعًا قابلاً للتغيير إلى `list`. نحن لا نستخدم الإغلاق مرة أخرى بعد استدعاء الإغلاق، لذلك تنتهي الاستعارة القابلة للتغيير. بين تعريف الإغلاق واستدعاء الإغلاق، لا يُسمح باستعارة غير قابلة للتغيير للطباعة، لأنه لا يُسمح باستعارات أخرى عندما تكون هناك استعارة قابلة للتغيير. حاول إضافة `println!` هناك لترى رسالة الخطأ التي تحصل عليها!

إذا كنت تريد إجبار الإغلاق على أخذ ملكية القيم التي يستخدمها في البيئة حتى لو لم يكن جسم الإغلاق يحتاج الملكية بشكل صارم، يمكنك استخدام الكلمة المفتاحية `move` قبل قائمة المعاملات.

هذه التقنية مفيدة في الغالب عند تمرير إغلاق إلى خيط جديد لنقل البيانات بحيث يمتلكها الخيط الجديد. سنناقش الخيوط (threads) وسبب رغبتك في استخدامها بالتفصيل في الفصل 16 عندما نتحدث عن التزامن (concurrency)، ولكن الآن، دعنا نستكشف بإيجاز إنشاء خيط جديد باستخدام إغلاق يحتاج إلى الكلمة المفتاحية `move`. توضح القائمة 13-6 القائمة 13-4 معدلة لطباعة المتجه في خيط جديد بدلاً من الخيط الرئيسي.

<Listing number="13-6" file-name="src/main.rs" caption="استخدام `move` لإجبار الإغلاق للخيط على أخذ ملكية `list`">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
```

</Listing>

ننشئ خيطًا جديدًا، ونعطي الخيط إغلاقًا للتشغيل كوسيط. جسم الإغلاق يطبع القائمة. في القائمة 13-4، التقط الإغلاق `list` فقط باستخدام مَرجِع غير قابل للتغيير لأن ذلك هو أقل قدر من الوصول إلى `list` اللازم لطباعته. في هذا المثال، على الرغم من أن جسم الإغلاق لا يزال يحتاج فقط إلى مَرجِع غير قابل للتغيير، نحتاج إلى تحديد أنه يجب نقل `list` إلى الإغلاق عن طريق وضع الكلمة المفتاحية `move` في بداية تعريف الإغلاق. إذا قام الخيط الرئيسي بإجراء المزيد من العمليات قبل استدعاء `join` على الخيط الجديد، فقد ينتهي الخيط الجديد قبل انتهاء بقية الخيط الرئيسي، أو قد ينتهي الخيط الرئيسي أولاً. إذا حافظ الخيط الرئيسي على ملكية `list` ولكن انتهى قبل الخيط الجديد وأسقط `list`، فسيكون المَرجِع غير القابل للتغيير في الخيط غير صالح. لذلك، يتطلب المصرِّف نقل `list` إلى الإغلاق المعطى للخيط الجديد بحيث يكون المَرجِع صالحًا. حاول إزالة الكلمة المفتاحية `move` أو استخدام `list` في الخيط الرئيسي بعد تعريف الإغلاق لترى أخطاء المصرِّف التي تحصل عليها!

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>
<a id="moving-captured-values-out-of-closures-and-the-fn-traits"></a>

### نقل القيم الملتقطة خارج الإغلاقات

بمجرد أن يلتقط الإغلاق مَرجِعًا أو يلتقط ملكية قيمة من البيئة حيث تم تعريف الإغلاق (وبالتالي يؤثر على ما، إن وُجد، يتم نقله _داخل_ الإغلاق)، يحدد الكود في جسم الإغلاق ما يحدث للمَراجِع أو القيم عند تقييم الإغلاق لاحقًا (وبالتالي يؤثر على ما، إن وُجد، يتم نقله _خارج_ الإغلاق).

يمكن لجسم الإغلاق القيام بأي مما يلي: نقل قيمة ملتقطة خارج الإغلاق، أو تغيير القيمة الملتقطة، أو عدم نقل ولا تغيير القيمة، أو عدم التقاط أي شيء من البيئة في البداية.

تؤثر الطريقة التي يلتقط بها الإغلاق ويتعامل بها مع القيم من البيئة على السِمات التي ينفذها الإغلاق، والسِمات هي كيفية تحديد الدوال والبُنى لأنواع الإغلاقات التي يمكنها استخدامها. ستنفذ الإغلاقات تلقائيًا واحدة أو اثنتين أو جميع السِمات الثلاث `Fn` هذه، بطريقة إضافية، اعتمادًا على كيفية تعامل جسم الإغلاق مع القيم:

* `FnOnce` تنطبق على الإغلاقات التي يمكن استدعاؤها مرة واحدة. تنفذ جميع الإغلاقات على الأقل هذه السِمَة لأن جميع الإغلاقات يمكن استدعاؤها. الإغلاق الذي ينقل القيم الملتقطة خارج جسمه سينفذ فقط `FnOnce` ولا شيء من سِمات `Fn` الأخرى لأنه يمكن استدعاؤه مرة واحدة فقط.
* `FnMut` تنطبق على الإغلاقات التي لا تنقل القيم الملتقطة خارج جسمها ولكن قد تغير القيم الملتقطة. يمكن استدعاء هذه الإغلاقات أكثر من مرة.
* `Fn` تنطبق على الإغلاقات التي لا تنقل القيم الملتقطة خارج جسمها ولا تغير القيم الملتقطة، وكذلك الإغلاقات التي لا تلتقط أي شيء من بيئتها. يمكن استدعاء هذه الإغلاقات أكثر من مرة دون تغيير بيئتها، وهو أمر مهم في حالات مثل استدعاء إغلاق عدة مرات بشكل متزامن.

دعنا ننظر إلى تعريف دالة `unwrap_or_else` على `Option<T>` التي استخدمناها في القائمة 13-1:

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

تذكر أن `T` هو النوع العام الذي يمثل نوع القيمة في متغير `Some` من `Option`. هذا النوع `T` هو أيضًا نوع الإرجاع لدالة `unwrap_or_else`: الكود الذي يستدعي `unwrap_or_else` على `Option<String>`، على سبيل المثال، سيحصل على `String`.

بعد ذلك، لاحظ أن دالة `unwrap_or_else` لديها معامل نوع عام إضافي `F`. نوع `F` هو نوع المعامل المسمى `f`, وهو الإغلاق الذي نقدمه عند استدعاء `unwrap_or_else`.

قيد السِمَة المحدد على النوع العام `F` هو `FnOnce() -> T`، مما يعني أن `F` يجب أن يكون قادرًا على الاستدعاء مرة واحدة، ولا يأخذ وسائط، ويعيد `T`. استخدام `FnOnce` في قيد السِمَة يعبر عن القيد بأن `unwrap_or_else` لن تستدعي `f` أكثر من مرة واحدة. في جسم `unwrap_or_else`، يمكننا أن نرى أنه إذا كان `Option` هو `Some`، فلن يتم استدعاء `f`. إذا كان `Option` هو `None`، فسيتم استدعاء `f` مرة واحدة. نظرًا لأن جميع الإغلاقات تنفذ `FnOnce`، فإن `unwrap_or_else` تقبل جميع الأنواع الثلاثة من الإغلاقات وتكون مرنة قدر الإمكان.

> ملاحظة: إذا كان ما نريد القيام به لا يتطلب التقاط قيمة من البيئة، يمكننا استخدام اسم دالة بدلاً من إغلاق حيث نحتاج إلى شيء ينفذ إحدى سِمات `Fn`. على سبيل المثال، على قيمة `Option<Vec<T>>`، يمكننا استدعاء `unwrap_or_else(Vec::new)` للحصول على متجه جديد فارغ إذا كانت القيمة `None`. ينفذ المصرِّف تلقائيًا أيًا من سِمات `Fn` المناسبة لتعريف دالة.

الآن دعنا ننظر إلى دالة المكتبة القياسية `sort_by_key`، المعرفة على الشرائح، لنرى كيف تختلف عن `unwrap_or_else` ولماذا تستخدم `sort_by_key` `FnMut` بدلاً من `FnOnce` لقيد السِمَة. يحصل الإغلاق على وسيط واحد في شكل مَرجِع إلى العنصر الحالي في الشريحة قيد النظر، ويعيد قيمة من النوع `K` يمكن ترتيبها. هذه الدالة مفيدة عندما تريد فرز شريحة بواسطة سمة معينة لكل عنصر. في القائمة 13-7، لدينا قائمة من نُسخ `Rectangle`، ونستخدم `sort_by_key` لترتيبها حسب سمة `width` من الأدنى إلى الأعلى.

<Listing number="13-7" file-name="src/main.rs" caption="استخدام `sort_by_key` لترتيب المستطيلات حسب العرض">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

</Listing>

يطبع هذا الكود:

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

السبب في أن `sort_by_key` معرفة لأخذ إغلاق `FnMut` هو أنها تستدعي الإغلاق عدة مرات: مرة واحدة لكل عنصر في الشريحة. الإغلاق `|r| r.width` لا يلتقط، أو يغير، أو ينقل أي شيء من بيئته، لذا فهو يلبي متطلبات قيد السِمَة.

في المقابل، توضح القائمة 13-8 مثالاً على إغلاق ينفذ فقط السِمَة `FnOnce`، لأنه ينقل قيمة خارج البيئة. لن يسمح لنا المصرِّف باستخدام هذا الإغلاق مع `sort_by_key`.

<Listing number="13-8" file-name="src/main.rs" caption="محاولة استخدام إغلاق `FnOnce` مع `sort_by_key`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

</Listing>

هذه طريقة مصطنعة ومعقدة (لا تعمل) لمحاولة حساب عدد المرات التي تستدعي فيها `sort_by_key` الإغلاق عند فرز `list`. يحاول هذا الكود القيام بهذا العد عن طريق دفع `value`—وهو `String` من بيئة الإغلاق—إلى متجه `sort_operations`. يلتقط الإغلاق `value` ثم ينقل `value` خارج الإغلاق عن طريق نقل ملكية `value` إلى متجه `sort_operations`. يمكن استدعاء هذا الإغلاق مرة واحدة؛ محاولة استدعائه مرة ثانية لن تعمل، لأن `value` لن يكون موجودًا في البيئة ليتم دفعه إلى `sort_operations` مرة أخرى! لذلك، ينفذ هذا الإغلاق فقط `FnOnce`. عندما نحاول ترجمة هذا الكود، نحصل على هذا الخطأ بأنه لا يمكن نقل `value` خارج الإغلاق لأن الإغلاق يجب أن ينفذ `FnMut`:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

يشير الخطأ إلى السطر في جسم الإغلاق الذي ينقل `value` خارج البيئة. لإصلاح ذلك، نحتاج إلى تغيير جسم الإغلاق بحيث لا ينقل القيم خارج البيئة. الاحتفاظ بعداد في البيئة وزيادة قيمته في جسم الإغلاق هو طريقة أكثر وضوحًا لحساب عدد المرات التي يتم فيها استدعاء الإغلاق. الإغلاق في القائمة 13-9 يعمل مع `sort_by_key` لأنه يلتقط فقط مَرجِعًا قابلاً للتغيير إلى عداد `num_sort_operations` وبالتالي يمكن استدعاؤه أكثر من مرة.

<Listing number="13-9" file-name="src/main.rs" caption="استخدام إغلاق `FnMut` مع `sort_by_key` مسموح به.">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

</Listing>

سِمات `Fn` مهمة عند تعريف أو استخدام دوال أو أنواع تستخدم الإغلاقات. في القسم التالي، سنناقش المُكرِّرات. تأخذ العديد من دوال المُكرِّرات وسائط الإغلاق، لذا احتفظ بتفاصيل الإغلاق هذه في الاعتبار بينما نستمر!

[unwrap-or-else]: ../std/option/enum.Option.html#method.unwrap_or_else
