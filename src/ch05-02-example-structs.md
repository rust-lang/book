## یک برنامه نمونه با استفاده از Structها

برای درک بهتر زمانی که ممکن است بخواهیم از ساختارها استفاده کنیم، بیایید یک برنامه بنویسیم که مساحت یک مستطیل را محاسبه کند. ما ابتدا با استفاده از متغیرهای جداگانه شروع می‌کنیم و سپس برنامه را بازنویسی می‌کنیم تا از ساختارها استفاده کند.

بیایید یک پروژه باینری جدید با Cargo به نام _rectangles_ ایجاد کنیم که عرض و ارتفاع یک مستطیل را بر حسب پیکسل مشخص کرده و مساحت آن را محاسبه کند. لیست ۵-۸ یک برنامه کوتاه نشان می‌دهد که دقیقاً همین کار را در فایل _src/main.rs_ پروژه ما انجام می‌دهد.

<Listing number="5-8" file-name="src/main.rs" caption="محاسبه مساحت یک مستطیل که با متغیرهای عرض و ارتفاع جداگانه مشخص شده است">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:all}}
```

</Listing>

اکنون، این برنامه را با استفاده از دستور `cargo run` اجرا کنید:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/output.txt}}
```

این کد با فراخوانی تابع `area` با هر یک از ابعاد موفق به محاسبه مساحت مستطیل می‌شود، اما می‌توانیم این کد را خواناتر و قابل درک‌تر کنیم.

مشکل این کد در امضای تابع `area` مشخص است:

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:here}}
```

تابع `area` قرار است مساحت یک مستطیل را محاسبه کند، اما تابعی که نوشتیم دو پارامتر دارد و هیچ‌کجا در برنامه مشخص نیست که این پارامترها به هم مرتبط هستند. بهتر است عرض و ارتفاع را به صورت گروهی تعریف کنیم تا خوانایی و مدیریت کد بهتر شود. یکی از روش‌هایی که قبلاً در بخش [«نوع Tuple»][the-tuple-type]<!-- ignore --> فصل ۳ بحث کردیم این است که از تاپل‌ها استفاده کنیم.

### بازنویسی با استفاده از Tupleها

لیست ۵-۹ نسخه دیگری از برنامه ما را نشان می‌دهد که از تاپل‌ها استفاده می‌کند.

<Listing number="5-9" file-name="src/main.rs" caption="مشخص کردن عرض و ارتفاع مستطیل با یک Tuple">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-09/src/main.rs}}
```

</Listing>

از یک منظر، این برنامه بهتر است. تاپل‌ها کمی ساختار اضافه می‌کنند و اکنون ما فقط یک آرگومان ارسال می‌کنیم. اما از منظر دیگر، این نسخه کمتر واضح است: تاپل‌ها اجزای خود را نام‌گذاری نمی‌کنند، بنابراین باید به بخش‌های تاپل با استفاده از ایندکس‌ها دسترسی پیدا کنیم که محاسبات ما را کمتر شفاف می‌کند.

اگر بخواهیم مستطیل را روی صفحه نمایش بکشیم، جابه‌جایی عرض و ارتفاع اهمیتی ندارد، اما برای رسم آن اهمیت پیدا می‌کند! ما باید به خاطر داشته باشیم که `width` ایندکس `0` تاپل و `height` ایندکس `1` تاپل است. این کار حتی برای کسی که از کد ما استفاده می‌کند سخت‌تر خواهد بود و به اشتباهات بیشتری منجر می‌شود. چون معنای داده‌های ما در کد مشخص نشده است، احتمال خطا بیشتر می‌شود.

### بازنویسی با استفاده از Structها: افزودن معنای بیشتر

ما از ساختارها استفاده می‌کنیم تا با نام‌گذاری داده‌ها، معنای بیشتری به آن‌ها بدهیم. می‌توانیم تاپلی که استفاده می‌کنیم را به یک ساختار تبدیل کنیم که برای کل داده‌ها یک نام و همچنین برای بخش‌های مختلف آن نام‌هایی مشخص کنیم، همان‌طور که در لیست ۵-۱۰ نشان داده شده است.

<Listing number="5-10" file-name="src/main.rs" caption="تعریف یک ساختار `Rectangle`">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-10/src/main.rs}}
```

</Listing>

در این‌جا یک `struct` تعریف کرده‌ایم و نام آن را `Rectangle` گذاشته‌ایم.  
درون آکولادها، فیلدهایی با نام‌های `width` و `height` تعریف کرده‌ایم  
که هر دو دارای نوع `u32` هستند. سپس، در تابع `main`، یک نمونه خاص از `Rectangle` ایجاد کرده‌ایم  
که `width` آن برابر با `30` و `height` آن برابر با `50` است.

تابع `area` ما اکنون با یک پارامتر تعریف شده است که آن را `rectangle` نامیده‌ایم و نوع آن یک ارجاع غیرقابل تغییر به یک نمونه از ساختار `Rectangle` است. همان‌طور که در فصل ۴ اشاره شد، ما می‌خواهیم ساختار را قرض بگیریم نه اینکه مالکیت آن را بگیریم. به این ترتیب، `main` مالکیت خود را حفظ می‌کند و می‌تواند همچنان از `rect1` استفاده کند. به همین دلیل است که از `&` در امضای تابع و در جایی که تابع را فراخوانی می‌کنیم استفاده می‌کنیم.

تابع `area` به فیلدهای `width` و `height` در نمونه `Rectangle` دسترسی پیدا می‌کند (توجه داشته باشید که دسترسی به فیلدهای یک نمونه قرض‌گرفته‌شده باعث انتقال مقادیر فیلدها نمی‌شود، به همین دلیل است که اغلب قرض‌گیری ساختارها را مشاهده می‌کنید). امضای تابع `area` ما اکنون دقیقاً همان چیزی را می‌گوید که منظور ماست: مساحت `Rectangle` را با استفاده از فیلدهای `width` و `height` آن محاسبه کن. این کار نشان می‌دهد که عرض و ارتفاع به یکدیگر مرتبط هستند و نام‌های توصیفی به مقادیر می‌دهد، به جای استفاده از مقادیر ایندکس تاپل‌ها مانند `0` و `1`. این یک پیروزی برای شفافیت است.

### افزودن قابلیت‌های مفید با Traits مشتق‌شده

زمانی که در حال اشکال‌زدایی برنامه خود هستیم، مفید است که بتوانیم نمونه‌ای از `Rectangle` را چاپ کرده و مقادیر تمام فیلدهای آن را ببینیم. لیست ۵-۱۱ تلاش می‌کند با استفاده از ماکروی [`println!`][println]<!-- ignore --> که در فصل‌های قبلی استفاده کرده‌ایم، این کار را انجام دهد. با این حال، این کار موفق نخواهد بود.

<Listing number="5-11" file-name="src/main.rs" caption="تلاش برای چاپ یک نمونه از `Rectangle`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/src/main.rs}}
```

</Listing>

وقتی این کد را کامپایل می‌کنیم، با خطایی مواجه می‌شویم که پیام اصلی آن به این صورت است:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:3}}
```

ماکروی `println!` می‌تواند بسیاری از انواع فرمت‌بندی را انجام دهد، و به صورت پیش‌فرض، آکولادها به `println!` می‌گویند که از فرمت‌بندی‌ای که به نام `Display` شناخته می‌شود استفاده کند: خروجی‌ای که برای مصرف مستقیم کاربر نهایی در نظر گرفته شده است. انواع ابتدایی که تاکنون دیده‌ایم به صورت پیش‌فرض ویژگی `Display` را پیاده‌سازی می‌کنند زیرا تنها یک روش برای نمایش یک مقدار مانند `1` یا هر نوع ابتدایی دیگری به کاربر وجود دارد. اما با ساختارها، روش فرمت‌بندی خروجی کمتر واضح است زیرا امکانات بیشتری برای نمایش وجود دارد: آیا می‌خواهید از ویرگول استفاده شود یا خیر؟ آیا می‌خواهید آکولادها چاپ شوند؟ آیا تمام فیلدها باید نشان داده شوند؟ به دلیل این ابهام، Rust سعی نمی‌کند حدس بزند که ما چه می‌خواهیم، و ساختارها پیاده‌سازی‌ای برای `Display` ندارند که بتوان با `println!` و جایگزین `{}` استفاده کرد.

اگر به خواندن خطاها ادامه دهیم، به این یادداشت مفید خواهیم رسید:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:9:10}}
```

بیایید آن را امتحان کنیم! اکنون فراخوانی ماکروی `println!` به صورت `println!("rect1 is {rect1:?}");` خواهد بود. قرار دادن مشخص‌کننده `:?` داخل آکولادها به `println!` می‌گوید که می‌خواهیم از یک فرمت خروجی به نام `Debug` استفاده کنیم. ویژگی `Debug` به ما اجازه می‌دهد تا ساختار خود را به روشی که برای توسعه‌دهندگان مفید است چاپ کنیم تا مقدار آن را هنگام اشکال‌زدایی کد خود ببینیم.

کد را با این تغییر کامپایل کنید. خب، باز هم یک خطا دریافت می‌کنیم:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:3}}
```

اما باز هم کامپایلر یادداشتی مفید به ما می‌دهد:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:9:10}}
```

Rust _در واقع_ قابلیت چاپ اطلاعات اشکال‌زدایی را دارد، اما باید به صورت صریح این قابلیت را برای ساختار خود فعال کنیم. برای انجام این کار، ویژگی بیرونی `#[derive(Debug)]` را دقیقاً قبل از تعریف ساختار اضافه می‌کنیم، همان‌طور که در لیست ۵-۱۲ نشان داده شده است.

<Listing number="5-12" file-name="src/main.rs" caption="افزودن ویژگی برای مشتق کردن `Debug` و چاپ نمونه `Rectangle` با استفاده از فرمت اشکال‌زدایی">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/src/main.rs}}
```

</Listing>

اکنون وقتی برنامه را اجرا می‌کنیم، هیچ خطایی دریافت نخواهیم کرد و خروجی زیر را خواهیم دید:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/output.txt}}
```

عالی! این خروجی ممکن است زیباترین نباشد، اما مقادیر تمام فیلدها را برای این نمونه نشان می‌دهد که قطعاً در هنگام اشکال‌زدایی کمک می‌کند. زمانی که ساختارهای بزرگ‌تری داریم، مفید است که خروجی کمی آسان‌تر خوانده شود؛ در چنین مواردی می‌توانیم به جای `{:?}` از `{:#?}` در رشته `println!` استفاده کنیم. در این مثال، استفاده از سبک `{:#?}` خروجی زیر را ایجاد خواهد کرد:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-02-pretty-debug/output.txt}}
```

روش دیگر برای چاپ مقدار با استفاده از فرمت `Debug`، استفاده از ماکروی [`dbg!`][dbg]<!-- ignore --> است که مالکیت یک عبارت را می‌گیرد (برخلاف `println!`، که ارجاع می‌گیرد)، فایل و شماره خطی که فراخوانی `dbg!` در آن اتفاق می‌افتد همراه با مقدار حاصل از آن عبارت را چاپ می‌کند و مالکیت مقدار را بازمی‌گرداند.


Here is the continuation of the translation for **"ch05-02-example-structs.md"** into Persian:

در اینجا مثالی آورده شده است که در آن ما به مقدار اختصاص داده شده به فیلد `width` و همچنین مقدار کل ساختار در `rect1` علاقه‌مند هستیم:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/src/main.rs}}
```

ما می‌توانیم `dbg!` را در اطراف عبارت `30 * scale` قرار دهیم و چون `dbg!` مالکیت مقدار عبارت را بازمی‌گرداند، فیلد `width` همان مقداری را خواهد داشت که اگر فراخوانی `dbg!` در آنجا وجود نداشت. ما نمی‌خواهیم `dbg!` مالکیت `rect1` را بگیرد، بنابراین از یک ارجاع به `rect1` در فراخوانی بعدی استفاده می‌کنیم. در اینجا خروجی این مثال آورده شده است:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/output.txt}}
```

می‌توانیم ببینیم که اولین بخش خروجی از خط ۱۰ در _src/main.rs_ آمده است، جایی که ما در حال اشکال‌زدایی عبارت `30 * scale` هستیم، و مقدار حاصل آن `60` است (فرمت‌بندی `Debug` که برای اعداد صحیح پیاده‌سازی شده است فقط مقدار آن‌ها را چاپ می‌کند). فراخوانی `dbg!` در خط ۱۴ از _src/main.rs_ مقدار `&rect1` را چاپ می‌کند که ساختار `Rectangle` است. این خروجی از فرمت‌بندی زیبا و مفید `Debug` برای نوع `Rectangle` استفاده می‌کند. ماکروی `dbg!` می‌تواند در هنگام تلاش برای درک رفتار کدتان بسیار مفید باشد!

علاوه بر ویژگی `Debug`، Rust تعدادی ویژگی برای ما فراهم کرده است که می‌توانیم با استفاده از ویژگی `derive` آن‌ها را به نوع‌های سفارشی خود اضافه کنیم و رفتار مفیدی ارائه دهند. این ویژگی‌ها و رفتار آن‌ها در [ضمیمه ج][app-c]<!-- ignore --> فهرست شده‌اند. ما در فصل ۱۰ به نحوه پیاده‌سازی این ویژگی‌ها با رفتار سفارشی و همچنین نحوه ایجاد ویژگی‌های خود می‌پردازیم. همچنین بسیاری از ویژگی‌های دیگر به غیر از `derive` وجود دارند؛ برای اطلاعات بیشتر، به [بخش «ویژگی‌ها» در مرجع Rust][attributes] مراجعه کنید.

تابع `area` ما بسیار خاص است: فقط مساحت مستطیل‌ها را محاسبه می‌کند. مفید خواهد بود اگر این رفتار را به صورت نزدیک‌تر با ساختار `Rectangle` مرتبط کنیم، زیرا این تابع با هیچ نوع دیگری کار نخواهد کرد. بیایید ببینیم که چگونه می‌توانیم با تبدیل تابع `area` به یک _متد_ که برای نوع `Rectangle` تعریف شده است، این کد را بازنویسی کنیم.

[the-tuple-type]: ch03-02-data-types.html#the-tuple-type
[app-c]: appendix-03-derivable-traits.md
[println]: https://doc.rust-lang.org/std/macro.println.html
[dbg]: https://doc.rust-lang.org/std/macro.dbg.html
[attributes]: ../reference/attributes.html