## المراجع والاستعارة

المشكلة في كود الصف المزدوج في القائمة 4-5 هي أننا يجب أن نعيد قيمة
`String` إلى الدالة المُستدعية حتى نتمكن من استخدام `String` بعد
استدعاء `calculate_length`، لأن `String` تم نقلها إلى
`calculate_length`. بدلاً من ذلك، يمكننا توفير مرجع لقيمة `String`.
المرجع يشبه المؤشر من حيث أنه عنوان يمكننا اتباعه للوصول إلى
البيانات المخزنة في هذا العنوان؛ تلك البيانات مملوكة بواسطة متغير آخر.
بخلاف المؤشر، يُضمن أن المرجع يشير إلى قيمة صالحة من
نوع معين طوال فترة حياة ذلك المرجع.

هكذا يمكنك تعريف واستخدام دالة `calculate_length` التي لديها
مرجع لكائن كمعامل بدلاً من أخذ ملكية القيمة:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
```

</Listing>

أولاً، لاحظ أن جميع أكواد الصف المزدوج في تصريح المتغير وقيمة
إرجاع الدالة قد اختفت. ثانياً، لاحظ أننا نمرر `&s1` إلى
`calculate_length` وفي تعريفها، نأخذ `&String` بدلاً من
`String`. هذه العلامات & تمثل المراجع، وتسمح لك بالإشارة إلى
قيمة ما دون أخذ ملكيتها. الشكل 4-6 يوضح هذا المفهوم.

<img alt="ثلاث جداول: جدول s يحتوي فقط على مؤشر إلى جدول
s1. جدول s1 يحتوي على بيانات المكدس لـ s1 ويشير إلى بيانات
السلسلة النصية في الكومة." src="img/trpl04-06.svg" class="center" />

<span class="caption">الشكل 4-6: مخطط لـ `&String` `s` يشير إلى
`String` `s1`</span>

> ملاحظة: عكس الإشارة باستخدام `&` هو _إلغاء الإشارة_، والذي يتم
> تنفيذه باستخدام عامل إلغاء الإشارة، `*`. سنرى بعض استخدامات
> عامل إلغاء الإشارة في الفصل 8 ونناقش تفاصيل إلغاء الإشارة في
> الفصل 15.

لنلقِ نظرة فاحصة على استدعاء الدالة هنا:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
```

صياغة `&s1` تتيح لنا إنشاء مرجع _يشير_ إلى قيمة `s1`
ولكن لا يملكها. لأن المرجع لا يملكها، القيمة التي يشير إليها
لن يتم حذفها عندما يتوقف استخدام المرجع.

بالمثل، توقيع الدالة يستخدم `&` للإشارة إلى أن نوع
المعامل `s` هو مرجع. لنضف بعض التعليقات التوضيحية:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
```

النطاق الذي يكون فيه المتغير `s` صالحاً هو نفسه نطاق أي معامل
دالة، لكن القيمة التي يشير إليها المرجع لا يتم حذفها
عندما يتوقف استخدام `s`، لأن `s` لا يملك الملكية. عندما تحتوي الدوال
على مراجع كمعاملات بدلاً من القيم الفعلية، لن نحتاج إلى
إعادة القيم لإعادة الملكية، لأننا لم نحصل على
الملكية أبداً.

نسمي عملية إنشاء مرجع _الاستعارة_. كما في الحياة الواقعية، إذا كان
شخص يمتلك شيئاً، يمكنك استعارته منه. عندما تنتهي، يجب عليك
إعادته. أنت لا تملكه.

إذن، ماذا يحدث إذا حاولنا تعديل شيء نستعيره؟ جرب الكود في
القائمة 4-6. تنبيه: لن يعمل!

<Listing number="4-6" file-name="src/main.rs" caption="محاولة تعديل قيمة مستعارة">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}
```

</Listing>

هذا هو الخطأ:

```console
{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
```

كما أن المتغيرات غير قابلة للتغيير افتراضياً، كذلك المراجع. نحن غير
مسموح لنا بتعديل شيء لدينا مرجع له.

### المراجع القابلة للتغيير

يمكننا إصلاح الكود من القائمة 4-6 للسماح لنا بتعديل قيمة مستعارة
بتعديلات صغيرة تستخدم، بدلاً من ذلك، _مرجعاً قابلاً للتغيير_:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
```

</Listing>

أولاً، نغير `s` ليكون `mut`. ثم نُنشئ مرجعاً قابلاً للتغيير باستخدام
`&mut s` حيث نستدعي دالة `change` ونحدّث توقيع الدالة
لقبول مرجع قابل للتغيير بـ `some_string: &mut String`. هذا يجعل من
الواضح جداً أن دالة `change` ستغيّر القيمة التي تستعيرها.

المراجع القابلة للتغيير لها قيد كبير واحد: إذا كان لديك مرجع قابل للتغيير لـ
قيمة، لا يمكنك الحصول على مراجع أخرى لتلك القيمة. هذا الكود الذي
يحاول إنشاء مرجعين قابلين للتغيير لـ `s` سيفشل:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}
```

</Listing>

هذا هو الخطأ:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
```

هذا الخطأ يقول أن هذا الكود غير صالح لأننا لا يمكننا استعارة `s` كـ
قابل للتغيير أكثر من مرة واحدة في نفس الوقت. الاستعارة القابلة للتغيير الأولى في `r1` ويجب أن
تستمر حتى يتم استخدامها في `println!`، ولكن بين إنشاء ذلك
المرجع القابل للتغيير واستخدامه، حاولنا إنشاء مرجع قابل للتغيير آخر
في `r2` يستعير نفس البيانات مثل `r1`.

القيد الذي يمنع وجود مراجع قابلة للتغيير متعددة لنفس البيانات في
نفس الوقت يسمح بالتغيير ولكن بطريقة محكومة جداً. إنه شيء
يعاني معه مبرمجو Rust الجدد لأن معظم اللغات تتيح لك التغيير
متى أردت. فائدة وجود هذا القيد هو أن Rust يمكنه
منع تسابق البيانات في وقت الترجمة. _تسابق البيانات_ مشابه لحالة
التسابق ويحدث عندما تحدث هذه السلوكيات الثلاثة:

- مؤشران أو أكثر يصلان إلى نفس البيانات في نفس الوقت.
- على الأقل أحد المؤشرات يُستخدم للكتابة إلى البيانات.
- لا توجد آلية مستخدمة لتزامن الوصول إلى البيانات.

تسابق البيانات يسبب سلوكاً غير محدد ويمكن أن يكون صعب التشخيص والإصلاح
عندما تحاول تتبعه في وقت التشغيل؛ Rust يمنع هذه المشكلة من خلال
رفض ترجمة كود به تسابق بيانات!

كما هو الحال دائماً، يمكننا استخدام الأقواس المعقوفة لإنشاء نطاق جديد، مما يسمح بـ
مراجع قابلة للتغيير متعددة، ولكن ليس مراجع _متزامنة_:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
```

تفرض Rust قاعدة مماثلة للجمع بين المراجع القابلة والغير قابلة للتغيير.
هذا الكود ينتج عنه خطأ:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}
```

هذا هو الخطأ:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
```

أوه! نحن _أيضاً_ لا يمكننا الحصول على مرجع قابل للتغيير بينما لدينا مرجع غير قابل للتغيير
لنفس القيمة.

مستخدمو المرجع الغير قابل للتغيير لا يتوقعون أن تتغير القيمة فجأة
من تحتهم! ومع ذلك، المراجع الغير قابلة للتغيير المتعددة مسموح بها لأن لا
أحد يقرأ البيانات فقط لديه القدرة على التأثير على قراءة أي شخص آخر
للبيانات.

لاحظ أن نطاق المرجع يبدأ من حيث يتم تقديمه ويستمر
حتى آخر مرة يُستخدم فيها ذلك المرجع. على سبيل المثال، هذا الكود سوف
يُترجم لأن آخر استخدام للمراجع الغير قابلة للتغيير في `println!`،
قبل تقديم المرجع القابل للتغيير:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
```

نطاقات المراجع الغير قابلة للتغيير `r1` و `r2` تنتهي بعد `println!`
حيث يتم استخدامها للمرة الأخيرة، وهو قبل إنشاء المرجع القابل للتغيير `r3`.
هذه النطاقات لا تتداخل، لذلك هذا الكود مسموح به: المترجم يمكنه
معرفة أن المرجع لم يعد قيد الاستخدام في نقطة قبل نهاية
النطاق.

على الرغم من أن أخطاء الاستعارة قد تكون محبطة في بعض الأحيان، تذكر أن
مترجم Rust يشير إلى خطأ محتمل مبكراً (في وقت الترجمة بدلاً
من وقت التشغيل) ويوضح لك بالضبط أين المشكلة. عندئذٍ، لن تضطر
إلى تتبع سبب عدم كون بياناتك كما كنت تعتقد أنها كانت.

### المراجع المعلقة

في اللغات ذات المؤشرات، من السهل إنشاء _مؤشر معلق_
خطأً—مؤشر يشير إلى موقع في الذاكرة ربما تم
إعطاؤه لشخص آخر—عن طريق تحرير بعض الذاكرة مع الحفاظ على مؤشر لتلك
الذاكرة. في Rust، على النقيض، يضمن المترجم أن المراجع لن
تكون أبداً مراجع معلقة: إذا كان لديك مرجع لبعض البيانات، سوف
يضمن المترجم أن البيانات لن تخرج من النطاق قبل
المرجع للبيانات.

لنحاول إنشاء مرجع معلق لنرى كيف تمنعها Rust بـ
خطأ وقت الترجمة:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}
```

</Listing>

هذا هو الخطأ:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
```

رسالة الخطأ هذه تشير إلى ميزة لم نتناولها بعد: فترات الحياة. سوف
نناقش فترات الحياة بالتفصيل في الفصل 10. ولكن، إذا تجاهلت الأجزاء
المتعلقة بفترات الحياة، الرسالة تحتوي على المفتاح لماذا هذا الكود مشكلة:

```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
```

لنلقِ نظرة فاحصة على ما يحدث بالضبط في كل مرحلة من كود
`dangle`:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}
```

</Listing>

لأن `s` يتم إنشاؤه داخل `dangle`، عندما ينتهي كود `dangle`،
سيتم تحرير `s`. لكننا حاولنا إعادة مرجع له. هذا يعني
هذا المرجع سيكون يشير إلى `String` غير صالح. هذا ليس جيداً! Rust
لن يسمح لنا بفعل هذا.

الحل هنا هو إعادة `String` مباشرة:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
```

هذا يعمل بدون أي مشاكل. يتم نقل الملكية، ولا شيء يتم
تحريره.

### قواعد المراجع

لنلخص ما ناقشناه عن المراجع:

- في أي وقت، يمكنك الحصول على _إما_ مرجع قابل للتغيير واحد _أو_ أي
  عدد من المراجع الغير قابلة للتغيير.
- يجب أن تكون المراجع صالحة دائماً.

بعد ذلك، سننظر إلى نوع مختلف من المراجع: الشرائح.
