## خصائص اللغات الكائنية التوجه

لا يوجد إجماع في مجتمع البرمجة حول الميزات التي يجب أن تمتلكها اللغة لتُعتبر كائنية التوجه. تتأثر Rust بالعديد من نماذج البرمجة، بما في ذلك OOP؛ على سبيل المثال، استكشفنا الميزات التي جاءت من البرمجة الوظيفية في الفصل 13. يُمكن القول أن لغات OOP تشترك في خصائص شائعة معينة—وهي: الكائنات (objects)، والتغليف (encapsulation)، والوراثة (inheritance). لننظر إلى ما تعنيه كل من هذه الخصائص وما إذا كانت Rust تدعمها.

### الكائنات تحتوي على بيانات وسلوك

الكتاب _Design Patterns: Elements of Reusable Object-Oriented Software_ لإريك جاما، وريتشارد هيلم، ورالف جونسون، وجون فليسيدس (Addison-Wesley، 1994)، والمشار إليه بشكل عامي باسم كتاب _The Gang of Four_، هو كتالوج لأنماط التصميم الكائنية التوجه. يُعرّف OOP بهذه الطريقة:

> البرامج الكائنية التوجه مكونة من كائنات. **الكائن** (object) يُحزّم كلاً من البيانات والإجراءات التي تعمل على تلك البيانات. عادة ما تُسمى الإجراءات **الدوال** (methods) أو **العمليات** (operations).

باستخدام هذا التعريف، Rust كائنية التوجه: تحتوي البُنى (Structs) والتعدادات (enums) على بيانات، وتوفر كتل `impl` دوالاً على البُنى والتعدادات. حتى لو لم تُسمى البُنى والتعدادات التي تحتوي على دوال _كائنات_، فإنها توفر نفس الوظيفة، وفقًا لتعريف Gang of Four للكائنات.

### التغليف الذي يخفي تفاصيل التنفيذ

جانب آخر يُرتبط عادة مع OOP هو فكرة _التغليف_ (encapsulation)، والتي تعني أن تفاصيل التنفيذ الخاصة بالكائن ليست متاحة للكود الذي يستخدم ذلك الكائن. وبالتالي، الطريقة الوحيدة للتفاعل مع الكائن هي من خلال واجهة برمجة التطبيقات العامة (public API) الخاصة به؛ لا يجب أن يتمكن الكود الذي يستخدم الكائن من الوصول إلى تفاصيل الكائن الداخلية وتغيير البيانات أو السلوك مباشرة. هذا يُمكّن المبرمج من تغيير وإعادة هيكلة تفاصيل الكائن الداخلية دون الحاجة إلى تغيير الكود الذي يستخدم الكائن.

ناقشنا كيفية التحكم في التغليف في الفصل 7: يمكننا استخدام الكلمة المفتاحية `pub` لتحديد أي من الوحدات والأنواع والدوال والدوال في كودنا يجب أن تكون عامة، وبشكل افتراضي كل شيء آخر خاص. على سبيل المثال، يمكننا تعريف بنية `AveragedCollection` التي تحتوي على حقل يحتوي على متجه من قيم `i32`. يمكن أن تحتوي البنية أيضًا على حقل يحتوي على متوسط القيم في المتجه، مما يعني أن المتوسط لا يجب حسابه عند الطلب كلما احتاجه أحد. بمعنى آخر، ستُخزن `AveragedCollection` المتوسط المحسوب لنا في ذاكرة التخزين المؤقتة. القائمة 18-1 تحتوي على تعريف بنية `AveragedCollection`.

<Listing number="18-1" file-name="src/lib.rs" caption="بنية `AveragedCollection` التي تحتفظ بقائمة من الأعداد الصحيحة ومتوسط العناصر في المجموعة">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-01/src/lib.rs}}
```

</Listing>

البنية محددة بـ `pub` حتى يتمكن الكود الآخر من استخدامها، لكن الحقول داخل البنية تظل خاصة. هذا مهم في هذه الحالة لأننا نريد التأكد من أنه كلما تمت إضافة قيمة أو إزالتها من القائمة، يتم تحديث المتوسط أيضًا. نقوم بذلك من خلال تنفيذ الدوال `add` و`remove` و`average` على البنية، كما هو موضح في القائمة 18-2.

<Listing number="18-2" file-name="src/lib.rs" caption="تنفيذات الدوال العامة `add` و`remove` و`average` على `AveragedCollection`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-02/src/lib.rs:here}}
```

</Listing>

الدوال العامة `add` و`remove` و`average` هي الطرق الوحيدة للوصول إلى أو تعديل البيانات في نسخة من `AveragedCollection`. عندما يتم إضافة عنصر إلى `list` باستخدام دالة `add` أو إزالته باستخدام دالة `remove`، تقوم تنفيذات كل منهما باستدعاء دالة `update_average` الخاصة التي تتعامل مع تحديث حقل `average` أيضًا.

نترك حقلي `list` و`average` خاصين حتى لا توجد طريقة للكود الخارجي لإضافة أو إزالة عناصر من أو إلى حقل `list` مباشرة؛ وإلا قد يصبح حقل `average` غير متزامن عندما يتغير `list`. تُرجع دالة `average` القيمة في حقل `average`، مما يسمح للكود الخارجي بقراءة `average` ولكن ليس تعديله.

نظرًا لأننا غلّفنا تفاصيل التنفيذ الخاصة ببنية `AveragedCollection`، يمكننا بسهولة تغيير جوانب، مثل هيكل البيانات، في المستقبل. على سبيل المثال، يمكننا استخدام `HashSet<i32>` بدلاً من `Vec<i32>` لحقل `list`. طالما بقيت توقيعات الدوال العامة `add` و`remove` و`average` كما هي، فإن الكود الذي يستخدم `AveragedCollection` لن يحتاج إلى التغيير. إذا جعلنا `list` عامة بدلاً من ذلك، فلن يكون هذا هو الحال بالضرورة: `HashSet<i32>` و`Vec<i32>` لديهما دوال مختلفة لإضافة وإزالة العناصر، لذلك من المحتمل أن يضطر الكود الخارجي إلى التغيير إذا كان يُعدل `list` مباشرة.

إذا كان التغليف جانبًا مطلوبًا لاعتبار لغة ما كائنية التوجه، فإن Rust تفي بهذا المتطلب. يُمكّن خيار استخدام `pub` أو عدم استخدامه لأجزاء مختلفة من الكود من تغليف تفاصيل التنفيذ.

### الوراثة كنظام نوع ومشاركة للكود

_الوراثة_ (Inheritance) هي آلية يمكن من خلالها لكائن أن يرث عناصر من تعريف كائن آخر، وبالتالي يكتسب بيانات وسلوك الكائن الأب دون الحاجة إلى تعريفها مرة أخرى.

إذا كان يجب أن يكون للغة وراثة لتكون كائنية التوجه، فإن Rust ليست مثل هذه اللغة. لا توجد طريقة لتعريف بنية ترث حقول وتنفيذات دوال البنية الأب دون استخدام ماكرو.

ومع ذلك، إذا كنت معتادًا على وجود الوراثة في صندوق أدوات البرمجة الخاص بك، يمكنك استخدام حلول أخرى في Rust، اعتمادًا على سبب لجوئك إلى الوراثة في المقام الأول.

ستختار الوراثة لسببين رئيسيين. أحدهما هو إعادة استخدام الكود: يمكنك تنفيذ سلوك معين لنوع واحد، وتُمكّنك الوراثة من إعادة استخدام هذا التنفيذ لنوع مختلف. يمكنك القيام بذلك بطريقة محدودة في كود Rust باستخدام التنفيذات الافتراضية لدوال السِمة (trait)، والتي رأيتها في القائمة 10-14 عندما أضفنا تنفيذًا افتراضيًا لدالة `summarize` على السِمة (trait) `Summary`. أي نوع يُنفذ السِمة `Summary` سيكون لديه دالة `summarize` متاحة عليه دون أي كود إضافي. هذا مشابه لفئة أب (parent class) تحتوي على تنفيذ لدالة وفئة فرع (child class) ترث وتحتوي أيضًا على تنفيذ الدالة. يمكننا أيضًا تجاوز التنفيذ الافتراضي لدالة `summarize` عندما نُنفذ السِمة `Summary`، وهو ما يشبه فئة فرع تتجاوز تنفيذ دالة موروثة من فئة أب.

السبب الآخر لاستخدام الوراثة يتعلق بنظام النوع: لتمكين استخدام نوع فرع في نفس الأماكن التي يُستخدم فيها النوع الأب. هذا يُسمى أيضًا _تعدد الأشكال_ (polymorphism)، والذي يعني أنه يمكنك استبدال كائنات (objects) متعددة ببعضها البعض في وقت التشغيل إذا كانت تشترك في خصائص معينة.

> ### تعدد الأشكال
>
> بالنسبة للكثيرين، تعدد الأشكال مرادف للوراثة. لكنه في الواقع مفهوم أكثر عمومية يشير إلى الكود الذي يمكن أن يعمل مع بيانات من أنواع متعددة. بالنسبة للوراثة، تلك الأنواع عادة ما تكون فئات فرعية (subclasses).
>
> بدلاً من ذلك، تستخدم Rust الأنواع العمومية (generics) للتجريد على أنواع محتملة مختلفة وقيود السِمات (trait bounds) لفرض قيود على ما يجب أن توفره تلك الأنواع. هذا يُسمى أحيانًا _تعدد الأشكال البارامتري المحدود_ (bounded parametric polymorphism).

اختارت Rust مجموعة مختلفة من المفاضلات بعدم تقديم الوراثة. غالبًا ما تكون الوراثة معرضة لخطر مشاركة كود أكثر من اللازم. لا يجب أن تشترك الفئات الفرعية دائمًا في جميع خصائص فئتها الأب ولكنها ستفعل ذلك مع الوراثة. هذا يمكن أن يجعل تصميم البرنامج أقل مرونة. كما أنه يُقدم إمكانية استدعاء دوال على الفئات الفرعية التي لا معنى لها أو تتسبب في أخطاء لأن الدوال لا تنطبق على الفئة الفرعية. بالإضافة إلى ذلك، ستسمح بعض اللغات فقط بـ _الوراثة الفردية_ (single inheritance) (بمعنى أن الفئة الفرعية يمكن أن ترث من فئة واحدة فقط)، مما يقيد مرونة تصميم البرنامج أكثر.

لهذه الأسباب، تتخذ Rust نهجًا مختلفًا باستخدام كائنات السِمة (trait objects) بدلاً من الوراثة لتحقيق تعدد الأشكال في وقت التشغيل. دعونا ننظر إلى كيفية عمل كائنات السِمة.
