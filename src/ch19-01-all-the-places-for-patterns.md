## جميع الأماكن التي يمكن استخدام الأنماط فيها

تظهر الأنماط في عدد من الأماكن في Rust، وقد استخدمتها كثيرًا دون أن تدرك ذلك! يناقش هذا القسم جميع الأماكن التي تكون فيها الأنماط صالحة.

### أذرع `match`

كما نوقش في الفصل 6، نستخدم الأنماط في أذرع تعبيرات `match`. رسميًا، يتم تعريف تعبيرات `match` على أنها الكلمة المفتاحية `match`، وقيمة للمطابقة عليها، وذراع واحد أو أكثر من أذرع المطابقة (match arms) التي تتكون من نمط وتعبير لتشغيله إذا طابقت القيمة نمط ذلك الذراع، مثل هذا:

<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre><code>match <em>VALUE</em> {
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
}</code></pre>

على سبيل المثال، إليك تعبير `match` من القائمة 6-5 الذي يطابق على قيمة `Option<i32>` في المتغير `x`:

```rust,ignore
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

الأنماط في تعبير `match` هذا هي `None` و `Some(i)` إلى يسار كل سهم.

أحد متطلبات تعبيرات `match` هو أنها يجب أن تكون شاملة بمعنى أنه يجب حساب جميع الاحتمالات للقيمة في تعبير `match`. طريقة واحدة للتأكد من أنك قمت بتغطية كل احتمال هي أن يكون لديك نمط شامل للذراع الأخير: على سبيل المثال، اسم متغير يطابق أي قيمة لا يمكن أن يفشل أبدًا وبالتالي يغطي كل حالة متبقية.

النمط الخاص `_` سيطابق أي شيء، لكنه لا يرتبط أبدًا بمتغير، لذلك غالبًا ما يستخدم في ذراع المطابقة الأخير. يمكن أن يكون نمط `_` مفيدًا عندما تريد تجاهل أي قيمة غير محددة، على سبيل المثال. سنغطي نمط `_` بمزيد من التفصيل في ["تجاهل القيم في النمط"][ignoring-values-in-a-pattern]<!-- ignore --> لاحقًا في هذا الفصل.

### تعليمات `let`

قبل هذا الفصل، ناقشنا صراحة استخدام الأنماط مع `match` و `if let` فقط، ولكن في الواقع، استخدمنا الأنماط في أماكن أخرى أيضًا، بما في ذلك في تعليمات `let`. على سبيل المثال، ضع في اعتبارك هذا التعيين المباشر للمتغير باستخدام `let`:

```rust
let x = 5;
```

في كل مرة استخدمت فيها تعليمة `let` مثل هذه، كنت تستخدم الأنماط، على الرغم من أنك قد لا تكون قد أدركت ذلك! بشكل أكثر رسمية، تبدو تعليمة `let` كما يلي:

<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>

في تعليمات مثل `let x = 5;` مع اسم متغير في خانة PATTERN، اسم المتغير هو مجرد شكل بسيط بشكل خاص من النمط. يقارن Rust التعبير مع النمط ويعين أي أسماء يجدها. لذا، في مثال `let x = 5;`، `x` هو نمط يعني "اربط ما يطابق هنا بالمتغير `x`". ولأن الاسم `x` هو النمط بالكامل، فإن هذا النمط يعني فعليًا "اربط كل شيء بالمتغير `x`، مهما كانت القيمة".

لرؤية جانب مطابقة الأنماط في `let` بشكل أوضح، ضع في اعتبارك القائمة 19-1، التي تستخدم نمطًا مع `let` لتفكيك صف.


<Listing number="19-1" caption="استخدام نمط لتفكيك صف وإنشاء ثلاثة متغيرات دفعة واحدة">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-01/src/main.rs:here}}
```

</Listing>

هنا، نطابق صفًا مع نمط. يقارن Rust القيمة `(1, 2, 3)` مع النمط `(x, y, z)` ويرى أن القيمة تطابق النمط - أي أنه يرى أن عدد العناصر هو نفسه في كليهما - لذلك يربط Rust `1` بـ `x`، و`2` بـ `y`، و`3` بـ `z`. يمكنك التفكير في نمط الصف هذا على أنه يتضمن ثلاثة أنماط متغيرات فردية بداخله.

إذا لم يطابق عدد العناصر في النمط عدد العناصر في الصف، فلن يطابق النوع الإجمالي وسنحصل على خطأ في المترجم. على سبيل المثال، تُظهر القائمة 19-2 محاولة لتفكيك صف بثلاثة عناصر إلى متغيرين، وهو ما لن ينجح.

<Listing number="19-2" caption="بناء نمط بشكل غير صحيح حيث لا تطابق المتغيرات عدد العناصر في الصف">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-02/src/main.rs:here}}
```

</Listing>

محاولة تجميع هذا الكود تؤدي إلى خطأ النوع هذا:

```console
{{#include ../listings/ch19-patterns-and-matching/listing-19-02/output.txt}}
```

لإصلاح الخطأ، يمكننا تجاهل واحدة أو أكثر من القيم في الصف باستخدام `_` أو `..`، كما سترى في قسم ["تجاهل القيم في النمط"][ignoring-values-in-a-pattern]<!-- ignore -->. إذا كانت المشكلة هي أن لدينا عددًا كبيرًا جدًا من المتغيرات في النمط، فالحل هو جعل الأنواع متطابقة عن طريق إزالة المتغيرات بحيث يساوي عدد المتغيرات عدد العناصر في الصف.

### تعبيرات `if let` الشرطية

في الفصل 6، ناقشنا كيفية استخدام تعبيرات `if let` بشكل أساسي كطريقة أقصر لكتابة ما يعادل `match` الذي يطابق حالة واحدة فقط. اختياريًا، يمكن أن يحتوي `if let` على `else` مقابل يحتوي على كود لتشغيله إذا لم يطابق النمط في `if let`.

تُظهر القائمة 19-3 أنه من الممكن أيضًا مزج ومطابقة تعبيرات `if let` و `else if` و `else if let`. يمنحنا القيام بذلك مرونة أكبر من تعبير `match` الذي يمكننا فيه التعبير عن قيمة واحدة فقط للمقارنة مع الأنماط. أيضًا، لا يتطلب Rust أن تكون الشروط في سلسلة من أذرع `if let` و `else if` و `else if let` مرتبطة ببعضها البعض.

يحدد الكود في القائمة 19-3 اللون الذي ستجعل خلفيتك عليه بناءً على سلسلة من الفحوصات لعدة شروط. لهذا المثال، أنشأنا متغيرات بقيم مشفرة قد يتلقاها برنامج حقيقي من مدخلات المستخدم.

<Listing number="19-3" file-name="src/main.rs" caption="مزج `if let` و `else if` و `else if let` و `else`">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-03/src/main.rs}}
```

</Listing>

إذا حدد المستخدم لونًا مفضلاً، فسيتم استخدام هذا اللون كخلفية. إذا لم يتم تحديد لون مفضل وكان اليوم هو الثلاثاء، فإن لون الخلفية أخضر. خلاف ذلك، إذا حدد المستخدم عمره كسلسلة نصية ويمكننا تحليلها كرقم بنجاح، فإن اللون إما أرجواني أو برتقالي اعتمادًا على قيمة الرقم. إذا لم تنطبق أي من هذه الشروط، فإن لون الخلفية أزرق.

يتيح لنا هذا الهيكل الشرطي دعم متطلبات معقدة. مع القيم المشفرة التي لدينا هنا، سيطبع هذا المثال `Using purple as the background color`.

يمكنك أن ترى أن `if let` يمكنه أيضًا تقديم متغيرات جديدة تحجب المتغيرات الموجودة بنفس الطريقة التي يمكن أن تفعلها أذرع `match`: السطر `if let Ok(age) = age` يقدم متغير `age` جديدًا يحتوي على القيمة داخل متغير `Ok`، محجوبًا متغير `age` الموجود. هذا يعني أننا بحاجة إلى وضع شرط `if age > 30` داخل ذلك الكتلة: لا يمكننا دمج هذين الشرطين في `if let Ok(age) = age && age > 30`. المتغير `age` الجديد الذي نريد مقارنته بـ 30 غير صالح حتى يبدأ النطاق الجديد بالقوس المجعد.

الجانب السلبي لاستخدام تعبيرات `if let` هو أن المترجم لا يتحقق من الشمولية، بينما مع تعبيرات `match` يفعل ذلك. إذا حذفنا كتلة `else` الأخيرة وبالتالي فاتنا معالجة بعض الحالات، فلن ينبهنا المترجم إلى خطأ المنطق المحتمل.

### حلقات `while let` الشرطية

مماثلة في البناء لـ `if let`، تسمح حلقة `while let` الشرطية لحلقة `while` بالتشغيل طالما استمر النمط في المطابقة. في القائمة 19-4، نعرض حلقة `while let` التي تنتظر الرسائل المرسلة بين الخيوط، ولكن في هذه الحالة التحقق من `Result` بدلاً من `Option`.

<Listing number="19-4" caption="استخدام حلقة `while let` لطباعة القيم طالما أن `rx.recv()` يُرجع `Ok`">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-04/src/main.rs:here}}
```

</Listing>

يطبع هذا المثال `1` و `2` ثم `3`. تأخذ طريقة `recv` الرسالة الأولى من جانب المستقبل للقناة وتُرجع `Ok(value)`. عندما رأينا `recv` لأول مرة في الفصل 16، قمنا بفك الخطأ مباشرة، أو تفاعلنا معه كمكرر باستخدام حلقة `for`. كما توضح القائمة 19-4، يمكننا أيضًا استخدام `while let`، لأن طريقة `recv` تُرجع `Ok` في كل مرة تصل فيها رسالة، طالما أن المرسل موجود، ثم تنتج `Err` بمجرد انقطاع جانب المرسل.

### حلقات `for`

في حلقة `for`، القيمة التي تلي الكلمة المفتاحية `for` مباشرة هي نمط. على سبيل المثال، في `for x in y`، `x` هو النمط. توضح القائمة 19-5 كيفية استخدام نمط في حلقة `for` للتفكيك، أو التفكك، لصف كجزء من حلقة `for`.


<Listing number="19-5" caption="استخدام نمط في حلقة `for` لتفكيك صف">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-05/src/main.rs:here}}
```

</Listing>

سيطبع الكود في القائمة 19-5 ما يلي:


```console
{{#include ../listings/ch19-patterns-and-matching/listing-19-05/output.txt}}
```

نقوم بتكييف مكرر باستخدام طريقة `enumerate` بحيث ينتج قيمة والفهرس لتلك القيمة، موضوعة في صف. القيمة الأولى المنتجة هي الصف `(0, 'a')`. عندما يتم مطابقة هذه القيمة مع النمط `(index, value)`، سيكون `index` هو `0` و `value` سيكون `'a'`، طباعة السطر الأول من الناتج.


### معاملات الدوال

يمكن أن تكون معاملات الدوال أيضًا أنماطًا. الكود في القائمة 19-6، الذي يعلن عن دالة تسمى `foo` تأخذ معاملاً واحدًا يسمى `x` من النوع `i32`، يجب أن يبدو مألوفًا الآن.

<Listing number="19-6" caption="توقيع دالة يستخدم الأنماط في المعاملات">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-06/src/main.rs:here}}
```

</Listing>

الجزء `x` هو نمط! كما فعلنا مع `let`، يمكننا مطابقة صف في حجج الدالة مع النمط. تقسم القائمة 19-7 القيم في صف كما نمررها إلى دالة.

<Listing number="19-7" file-name="src/main.rs" caption="دالة بمعاملات تفكك صفًا">

```rust
{{#rustdoc_include ../listings/ch19-patterns-and-matching/listing-19-07/src/main.rs}}
```

</Listing>

يطبع هذا الكود `Current location: (3, 5)`. القيم `&(3, 5)` تطابق النمط `&(x, y)`، لذا `x` هو القيمة `3` و `y` هو القيمة `5`.

يمكننا أيضًا استخدام الأنماط في قوائم معاملات الإغلاقات بنفس الطريقة التي نستخدمها في قوائم معاملات الدوال لأن الإغلاقات مشابهة للدوال، كما نوقش في الفصل 13.

في هذه المرحلة، رأيت عدة طرق لاستخدام الأنماط، لكن الأنماط لا تعمل بنفس الطريقة في كل مكان يمكننا استخدامها فيه. في بعض الأماكن، يجب أن تكون الأنماط غير قابلة للدحض (irrefutable)؛ وفي ظروف أخرى، يمكن أن تكون قابلة للدحض (refutable). سنناقش هذين المفهومين بعد ذلك.

[ignoring-values-in-a-pattern]: ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern
