## أنواع البيانات العامة (Generic Data Types)

نستخدم الأنواع العمومية (generic types) لإنشاء تعريفات لعناصر مثل توقيعات الدوال أو الهياكل، والتي يمكننا استخدامها بعد ذلك مع العديد من أنواع البيانات الملموسة المختلفة. دعنا أولاً ننظر إلى كيفية تعريف الدوال والهياكل والتعدادات والأساليب باستخدام الأنواع العمومية (generic types). بعد ذلك، سنناقش كيف تؤثر الأنواع العمومية (generic types) على أداء الكود.

### في تعريفات الدوال

عند تعريف دالة تستخدم الأنواع العمومية (generic types)، نضع الأنواع العمومية (generic types) في توقيع الدالة حيث نحدد عادةً أنواع البيانات للمعاملات (parameters) والقيمة المُرجعة. القيام بذلك يجعل كودنا أكثر مرونة ويوفر المزيد من الوظائف للمستدعين لدالتنا مع منع تكرار الكود.

مواصلةً لدالتنا `largest`، يُظهر القائمة 10-4 دالتين تجدان أكبر قيمة في شريحة. سنجمع بعد ذلك هاتين الدالتين في دالة واحدة تستخدم الأنواع العمومية.

<Listing number="10-4" file-name="src/main.rs" caption="دالتان تختلفان فقط في أسمائهما وفي الأنواع في توقيعاتهما">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

</Listing>

دالة `largest_i32` هي التي استخرجناها في القائمة 10-3 والتي تجد أكبر `i32` في شريحة. تجد دالة `largest_char` أكبر `char` في شريحة. تحتوي أجسام الدوال على نفس الكود، لذا دعنا نزيل التكرار من خلال إدخال معامل نوع عمومي (generic type parameter) في دالة واحدة.

لجعل الأنواع معلمات في دالة جديدة واحدة، نحتاج إلى تسمية معامل النوع (type parameter)، تمامًا كما نفعل مع معاملات (parameters) القيمة لدالة. يمكنك استخدام أي معرف كاسم لمعامل النوع (type parameter). لكننا سنستخدم `T` لأنه، بحسب الاتفاق، أسماء معاملات الأنواع (type parameters) في Rust قصيرة، غالبًا حرف واحد فقط، واتفاقية تسمية الأنواع في Rust هي UpperCamelCase. اختصارًا لـ _type_ (نوع)، يُعتبر `T` الخيار الافتراضي لمعظم مبرمجي Rust.

عندما نستخدم معاملاً (parameter) في جسم الدالة، يجب أن نُعلن اسم المعامل في التوقيع حتى يعرف المصرِّف ما يعنيه هذا الاسم. وبالمثل، عندما نستخدم اسم معامل نوع (type parameter) في توقيع دالة، يجب أن نُعلن اسم معامل النوع (type parameter) قبل استخدامه. لتعريف دالة `largest` العامة (generic)، نضع تصريحات اسم النوع داخل الأقواس الزاوية، `<>`، بين اسم الدالة وقائمة المعاملات، هكذا:

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```

نقرأ هذا التعريف على أنه "الدالة `largest` عامة (generic) على نوع ما `T`". هذه الدالة لديها معامل (parameter) واحد يُدعى `list`، وهو شريحة من القيم من النوع `T`. ستُرجع دالة `largest` مرجعًا إلى قيمة من نفس النوع `T`.

تُظهر القائمة 10-5 تعريف دالة `largest` المجمعة باستخدام نوع البيانات العام (generic) في توقيعها. تُظهر القائمة أيضًا كيف يمكننا استدعاء الدالة إما بشريحة من قيم `i32` أو قيم `char`. لاحظ أن هذا الكود لن يُترجم بعد.

<Listing number="10-5" file-name="src/main.rs" caption="دالة `largest` باستخدام معاملات النوع العام (generic type parameters)؛ هذا لن يُترجم بعد">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

</Listing>

إذا قمنا بترجمة هذا الكود الآن، سنحصل على هذا الخطأ:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

يذكر نص المساعدة `std::cmp::PartialOrd`، وهي سمة (trait)، وسنتحدث عن السمات (traits) في القسم التالي. في الوقت الحالي، اعلم أن هذا الخطأ ينص على أن جسم `largest` لن يعمل مع جميع الأنواع المحتملة التي يمكن أن يكون عليها `T`. لأننا نريد مقارنة القيم من النوع `T` في الجسم، يمكننا استخدام الأنواع فقط التي يمكن ترتيب قيمها. لتمكين المقارنات، تحتوي المكتبة القياسية على سمة (trait) `std::cmp::PartialOrd` التي يمكنك تطبيقها (implementation) على الأنواع (راجع الملحق C لمزيد من المعلومات حول هذه السمة). لإصلاح القائمة 10-5، يمكننا اتباع اقتراح نص المساعدة وتقييد (bound) الأنواع الصالحة لـ `T` فقط لتلك التي تُطبق `PartialOrd`. ستُترجم القائمة بعد ذلك، لأن المكتبة القياسية تُطبق (implementation) `PartialOrd` على كل من `i32` و `char`.

### في تعريفات الهياكل

يمكننا أيضًا تعريف الهياكل لاستخدام معامل نوع عمومي (generic type parameter) في حقل واحد أو أكثر باستخدام صيغة `<>`. تُعرّف القائمة 10-6 هيكل `Point<T>` لاحتواء قيم الإحداثيات `x` و `y` من أي نوع.

<Listing number="10-6" file-name="src/main.rs" caption="هيكل `Point<T>` يحتوي على قيم `x` و `y` من النوع `T`">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

</Listing>

الصيغة لاستخدام الأنواع العمومية (generic types) في تعريفات الهياكل مشابهة لتلك المستخدمة في تعريفات الدوال. أولاً، نُعلن اسم معامل النوع (type parameter) داخل الأقواس الزاوية مباشرة بعد اسم الهيكل. ثم، نستخدم النوع العام (generic type) في تعريف الهيكل حيث سنحدد خلاف ذلك أنواع البيانات الملموسة.

لاحظ أنه نظرًا لأننا استخدمنا نوعًا عامًا (generic type) واحدًا فقط لتعريف `Point<T>`، فإن هذا التعريف يقول أن هيكل `Point<T>` عام (generic) على نوع ما `T`، والحقلين `x` و `y` هما _كلاهما_ من نفس النوع، مهما كان هذا النوع. إذا أنشأنا مثيلاً من `Point<T>` يحتوي على قيم من أنواع مختلفة، كما في القائمة 10-7، فلن يُترجم كودنا.

<Listing number="10-7" file-name="src/main.rs" caption="يجب أن يكون الحقلان `x` و `y` من نفس النوع لأن كليهما لديهما نفس نوع البيانات العام (generic) `T`.">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

</Listing>

في هذا المثال، عندما نعين القيمة الصحيحة `5` لـ `x`، نُعلم المصرِّف أن النوع العام (generic type) `T` سيكون عددًا صحيحًا لهذا المثيل من `Point<T>`. ثم، عندما نحدد `4.0` لـ `y`، والذي عرّفناه ليكون من نفس نوع `x`، سنحصل على خطأ عدم تطابق النوع مثل هذا:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

لتعريف هيكل `Point` حيث `x` و `y` كلاهما عامان (generic) ولكن يمكن أن يكونا من أنواع مختلفة، يمكننا استخدام معاملات نوع عامة (generic type parameters) متعددة. على سبيل المثال، في القائمة 10-8، نغير تعريف `Point` ليكون عامًا (generic) على النوعين `T` و `U` حيث `x` من النوع `T` و `y` من النوع `U`.

<Listing number="10-8" file-name="src/main.rs" caption="هيكل `Point<T, U>` عام على نوعين بحيث يمكن أن يكون `x` و `y` قيمًا من أنواع مختلفة">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

</Listing>

الآن جميع مثيلات `Point` الموضحة مسموح بها! يمكنك استخدام العديد من معاملات النوع العام (generic type parameters) في تعريف كما تريد، ولكن استخدام أكثر من بضعة يجعل كودك صعب القراءة. إذا وجدت أنك بحاجة إلى الكثير من الأنواع العمومية (generic types) في كودك، فقد يشير ذلك إلى أن كودك بحاجة إلى إعادة هيكلة إلى قطع أصغر.

### في تعريفات التعدادات

كما فعلنا مع الهياكل، يمكننا تعريف التعدادات لاحتواء أنواع البيانات العامة (generic data types) في متغيراتها. دعنا نلقي نظرة أخرى على تعداد `Option<T>` الذي توفره المكتبة القياسية، والذي استخدمناه في الفصل 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

يجب أن يكون هذا التعريف أكثر منطقية لك الآن. كما ترى، تعداد `Option<T>` عام (generic) على النوع `T` ولديه متغيران: `Some`، الذي يحتوي على قيمة واحدة من النوع `T`، ومتغير `None` الذي لا يحتوي على أي قيمة. باستخدام تعداد `Option<T>`، يمكننا التعبير عن المفهوم المجرد (abstract) لقيمة اختيارية، ولأن `Option<T>` عام (generic)، يمكننا استخدام هذا التجريد بغض النظر عن نوع القيمة الاختيارية.

يمكن أن تستخدم التعدادات أنواعًا عامة (generic types) متعددة أيضًا. تعريف تعداد `Result` الذي استخدمناه في الفصل 9 هو أحد الأمثلة:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

تعداد `Result` عام (generic) على نوعين، `T` و `E`، ولديه متغيران: `Ok`، الذي يحتوي على قيمة من النوع `T`، و `Err`، الذي يحتوي على قيمة من النوع `E`. يجعل هذا التعريف من المريح استخدام تعداد `Result` في أي مكان لدينا عملية قد تنجح (تُرجع قيمة من نوع ما `T`) أو تفشل (تُرجع خطأ من نوع ما `E`). في الواقع، هذا ما استخدمناه لفتح ملف في القائمة 9-3، حيث تم ملء `T` بالنوع `std::fs::File` عندما تم فتح الملف بنجاح وتم ملء `E` بالنوع `std::io::Error` عندما كانت هناك مشاكل في فتح الملف.

عندما تتعرف على مواقف في كودك مع تعريفات هياكل أو تعدادات متعددة تختلف فقط في أنواع القيم التي تحتوي عليها، يمكنك تجنب التكرار باستخدام الأنواع العمومية (generic types) بدلاً من ذلك.

### في تعريفات الأساليب

يمكننا تطبيق (implementation) الأساليب على الهياكل والتعدادات (كما فعلنا في الفصل 5) واستخدام الأنواع العمومية (generic types) في تعريفاتها أيضًا. تُظهر القائمة 10-9 هيكل `Point<T>` الذي عرّفناه في القائمة 10-6 مع أسلوب يُدعى `x` مُطبق (implementation) عليه.

<Listing number="10-9" file-name="src/main.rs" caption="تطبيق أسلوب يُدعى `x` على هيكل `Point<T>` والذي سيُرجع مرجعًا إلى حقل `x` من النوع `T`">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

</Listing>

هنا، عرّفنا أسلوبًا يُدعى `x` على `Point<T>` يُرجع مرجعًا إلى البيانات في الحقل `x`.

لاحظ أننا يجب أن نُعلن `T` مباشرة بعد `impl` حتى نتمكن من استخدام `T` لتحديد أننا نطبق (implementation) أساليب على النوع `Point<T>`. من خلال الإعلان عن `T` كنوع عام (generic type) بعد `impl`، يمكن لـ Rust تحديد أن النوع في الأقواس الزاوية في `Point` هو نوع عمومي (generic type) بدلاً من نوع ملموس. كان بإمكاننا اختيار اسم مختلف لهذا المعامل العام (generic parameter) غير المعامل العام المُعلن في تعريف الهيكل، لكن استخدام نفس الاسم تقليدي. إذا كتبت أسلوبًا داخل `impl` يُعلن نوعًا عامًا (generic type)، فسيتم تعريف هذا الأسلوب على أي مثيل من النوع، بغض النظر عن النوع الملموس الذي ينتهي به الأمر ليحل محل النوع العام (generic type).

يمكننا أيضًا تحديد قيود (bounds) على الأنواع العمومية (generic types) عند تعريف الأساليب على النوع. يمكننا، على سبيل المثال، تطبيق (implementation) الأساليب فقط على مثيلات `Point<f32>` بدلاً من مثيلات `Point<T>` بأي نوع عمومي (generic type). في القائمة 10-10، نستخدم النوع الملموس `f32`، مما يعني أننا لا نُعلن أي أنواع بعد `impl`.

<Listing number="10-10" file-name="src/main.rs" caption="كتلة `impl` تنطبق فقط على هيكل بنوع ملموس معين لمعامل النوع العام (generic type parameter) `T`">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

</Listing>

يعني هذا الكود أن النوع `Point<f32>` سيكون لديه أسلوب `distance_from_origin`؛ المثيلات الأخرى من `Point<T>` حيث `T` ليس من النوع `f32` لن يكون لديها هذا الأسلوب المُعرّف. يقيس الأسلوب مدى بُعد نقطتنا عن النقطة عند الإحداثيات (0.0، 0.0) ويستخدم عمليات رياضية متاحة فقط لأنواع الفاصلة العائمة.

معاملات النوع العام (generic type parameters) في تعريف الهيكل ليست دائمًا نفسها التي تستخدمها في توقيعات أساليب ذلك الهيكل نفسه. تستخدم القائمة 10-11 الأنواع العمومية (generic types) `X1` و `Y1` لهيكل `Point` و `X2` و `Y2` لتوقيع أسلوب `mixup` لجعل المثال أوضح. يُنشئ الأسلوب مثيل `Point` جديد بقيمة `x` من `Point` الـ `self` (من النوع `X1`) وقيمة `y` من `Point` المُمرر (من النوع `Y2`).

<Listing number="10-11" file-name="src/main.rs" caption="أسلوب يستخدم أنواعًا عامة مختلفة عن تعريف هيكله">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

</Listing>

في `main`، عرّفنا `Point` يحتوي على `i32` لـ `x` (بقيمة `5`) و `f64` لـ `y` (بقيمة `10.4`). متغير `p2` هو هيكل `Point` يحتوي على شريحة نصية لـ `x` (بقيمة `"Hello"`) و `char` لـ `y` (بقيمة `c`). استدعاء `mixup` على `p1` مع الوسيط `p2` يعطينا `p3`، والذي سيكون لديه `i32` لـ `x` لأن `x` جاء من `p1`. سيكون لمتغير `p3` `char` لـ `y` لأن `y` جاء من `p2`. سيطبع استدعاء ماكرو `println!` `p3.x = 5, p3.y = c`.

الهدف من هذا المثال هو إثبات حالة يتم فيها الإعلان عن بعض المعاملات العامة (generic parameters) مع `impl` والبعض الآخر يتم الإعلان عنه مع تعريف الأسلوب. هنا، المعاملات العامة (generic parameters) `X1` و `Y1` مُعلنة بعد `impl` لأنها تتماشى مع تعريف الهيكل. المعاملات العامة (generic parameters) `X2` و `Y2` مُعلنة بعد `fn mixup` لأنها ذات صلة فقط بالأسلوب.

### أداء الكود باستخدام الأنواع العمومية

قد تتساءل عما إذا كانت هناك تكلفة وقت التشغيل عند استخدام معاملات النوع العام (generic type parameters). الخبر السار هو أن استخدام الأنواع العمومية (generic types) لن يجعل برنامجك يعمل بشكل أبطأ مما سيكون عليه مع الأنواع الملموسة.

تحقق Rust ذلك من خلال إجراء التوحيد الشكلي (monomorphization) للكود باستخدام الأنواع العمومية (generic types) في وقت الترجمة. _التوحيد الشكلي_ هو عملية تحويل الكود العام (generic) إلى كود محدد عن طريق ملء الأنواع الملموسة المستخدمة عند الترجمة. في هذه العملية، يقوم المصرِّف بعكس الخطوات التي استخدمناها لإنشاء الدالة العامة (generic) في القائمة 10-5: ينظر المصرِّف إلى جميع الأماكن التي يتم فيها استدعاء الكود العام (generic) ويُنشئ كودًا للأنواع الملموسة التي يتم استدعاء الكود العام (generic) بها.

دعنا ننظر إلى كيفية عمل ذلك باستخدام تعداد `Option<T>` العام (generic) للمكتبة القياسية:

```rust
let integer = Some(5);
let float = Some(5.0);
```

عندما تُترجم Rust هذا الكود، تُجري التوحيد الشكلي. خلال تلك العملية، يقرأ المصرِّف القيم التي تم استخدامها في مثيلات `Option<T>` ويحدد نوعين من `Option<T>`: أحدهما `i32` والآخر `f64`. على هذا النحو، يوسع التعريف العام لـ `Option<T>` إلى تعريفين متخصصين لـ `i32` و `f64`، وبالتالي استبدال التعريف العام بالتعريفات المحددة.

تبدو النسخة الموحدة شكليًا من الكود مشابهة للتالي (يستخدم المصرِّف أسماء مختلفة عما نستخدمه هنا للتوضيح):

<Listing file-name="src/main.rs">

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

</Listing>

يتم استبدال `Option<T>` العام (generic) بالتعريفات المحددة التي أنشأها المصرِّف. لأن Rust تُترجم الكود العام (generic) إلى كود يحدد النوع في كل مثيل، لا ندفع أي تكلفة وقت التشغيل لاستخدام الأنواع العمومية (generic types). عندما يعمل الكود، يؤدي تمامًا كما لو كنا قد كررنا كل تعريف يدويًا. تجعل عملية التوحيد الشكلي الأنواع العمومية (generic types) في Rust فعالة للغاية في وقت التشغيل.
