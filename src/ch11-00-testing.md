# كتابة الاختبارات الآلية (Automated Tests)

في مقالته عام 1972 بعنوان "المبرمج المتواضع"، قال إدسخر دبليو ديكسترا أن "اختبار (testing) البرامج يمكن أن يكون طريقة فعالة جداً لإظهار وجود الأخطاء، لكنه غير كافٍ بشكل يائس لإظهار غيابها". هذا لا يعني أننا لا يجب أن نحاول الاختبار (testing) بقدر ما نستطيع!

_الصحة_ في برامجنا هي المدى الذي يقوم فيه كودنا بما ننوي له القيام به. تم تصميم Rust مع درجة عالية من الاهتمام بصحة البرامج، لكن الصحة معقدة وليست سهلة الإثبات. يتحمل نظام الأنواع في Rust جزءاً كبيراً من هذا العبء، لكن نظام الأنواع لا يمكنه اكتشاف كل شيء. وعلى هذا النحو، يتضمن Rust دعماً لكتابة اختبارات البرمجيات الآلية.

لنفترض أننا كتبنا دالة `add_two` التي تضيف 2 إلى أي رقم يتم تمريره إليها. توقيع هذه الدالة يقبل عدداً صحيحاً كمعامل ويعيد عدداً صحيحاً كنتيجة. عندما ننفذ ونجمع هذه الدالة، يقوم Rust بكل عمليات فحص الأنواع وفحص الاستعارة التي تعلمتها حتى الآن لضمان أننا، على سبيل المثال، لا نمرر قيمة `String` أو مرجعاً غير صالح لهذه الدالة. لكن Rust _لا يمكنه_ التحقق من أن هذه الدالة ستفعل بالضبط ما ننوي، وهو إعادة المعامل زائد 2 بدلاً من، على سبيل المثال، المعامل زائد 10 أو المعامل ناقص 50! هنا تأتي أهمية الاختبارات.

يمكننا كتابة اختبارات (tests) تؤكد (assert)، على سبيل المثال، أنه عندما نمرر `3` إلى دالة `add_two`، تكون القيمة المعادة هي `5`. يمكننا تشغيل هذه الاختبارات (tests) كلما أجرينا تغييرات على كودنا للتأكد من أن أي سلوك صحيح موجود لم يتغير.

الاختبار (testing) مهارة معقدة: على الرغم من أننا لا نستطيع تغطية كل التفاصيل حول كيفية كتابة اختبارات (tests) جيدة في فصل واحد، سنناقش في هذا الفصل آليات تسهيلات الاختبار (testing) في Rust. سنتحدث عن التعليقات التوضيحية والماكرو المتاح لك عند كتابة اختباراتك (tests)، والسلوك الافتراضي والخيارات المقدمة لتشغيل اختباراتك (tests)، وكيفية تنظيم الاختبارات (tests) إلى اختبارات الوحدة (unit tests) واختبارات التكامل (integration tests).
