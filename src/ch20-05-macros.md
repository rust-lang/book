## الماكرو

استخدمنا الماكرو مثل `println!` في جميع أنحاء هذا الكتاب، لكننا لم نستكشف بالكامل ما هو الماكرو وكيف يعمل. يشير المصطلح _macro_ (ماكرو) إلى عائلة من الميزات في Rust - الماكرو التصريحية (declarative macros) مع `macro_rules!` وثلاثة أنواع من الماكرو الإجرائية (procedural macros):

- ماكرو `#[derive]` المخصصة التي تحدد الكود المضاف مع سمة `derive` المستخدمة على البنيات و enums
- الماكرو الشبيهة بالسمات (Attribute-like macros) التي تعرف سمات مخصصة قابلة للاستخدام على أي عنصر
- الماكرو الشبيهة بالدوال (Function-like macros) التي تبدو مثل استدعاءات الدوال ولكنها تعمل على الرموز (tokens) المحددة كوسيطتها

سنتحدث عن كل من هذه بدورها، ولكن أولاً، دعنا ننظر إلى لماذا نحتاج حتى إلى الماكرو عندما يكون لدينا بالفعل دوال.

### الفرق بين الماكرو والدوال

أساسًا، الماكرو هي طريقة لكتابة كود يكتب كودًا آخر، وهو ما يُعرف بـ _البرمجة الوصفية_ (metaprogramming). في الملحق C، نناقش سمة `derive`، والتي تولد تطبيقًا لسِمَات مختلفة لك. لقد استخدمنا أيضًا الماكرو `println!` و `vec!` في جميع أنحاء الكتاب. كل هذه الماكرو _تتوسع_ (expand) لتنتج كودًا أكثر مما كتبته يدويًا.

البرمجة الوصفية مفيدة لتقليل كمية الكود التي يجب عليك كتابتها وصيانتها، وهو أيضًا أحد أدوار الدوال. ومع ذلك، للماكرو بعض القوى الإضافية التي لا تمتلكها الدوال.

يجب أن يصرح توقيع الدالة عن عدد ونوع المعاملات التي تمتلكها الدالة. من ناحية أخرى، يمكن للماكرو أن يأخذ عددًا متغيرًا من المعاملات: يمكننا استدعاء `println!("hello")` بوسيطة واحدة أو `println!("hello {}", name)` بوسيطتين. أيضًا، يتم توسيع الماكرو قبل أن يفسر المترجم معنى الكود، لذلك يمكن للماكرو، على سبيل المثال، تطبيق سِمَة على نوع معطى. لا تستطيع الدالة ذلك، لأنها تُستدعى في وقت التشغيل ويجب تطبيق السِمَة في وقت الترجمة.

الجانب السلبي لتطبيق ماكرو بدلاً من دالة هو أن تعريفات الماكرو أكثر تعقيدًا من تعريفات الدوال لأنك تكتب كود Rust يكتب كود Rust. بسبب هذا التوجيه غير المباشر، تكون تعريفات الماكرو بشكل عام أكثر صعوبة في القراءة والفهم والصيانة من تعريفات الدوال.

فرق مهم آخر بين الماكرو والدوال هو أنه يجب عليك تعريف الماكرو أو إحضارها إلى النطاق _قبل_ استدعائها في ملف، بخلاف الدوال التي يمكنك تعريفها في أي مكان واستدعائها في أي مكان.

<!-- Old headings. Do not remove or links may break. -->

<a id="declarative-macros-with-macro_rules-for-general-metaprogramming"></a>

### الماكرو التصريحية للبرمجة الوصفية العامة

الشكل الأكثر استخدامًا من الماكرو في Rust هو _الماكرو التصريحية_ (declarative macro). يُشار إليها أحيانًا أيضًا بـ "الماكرو بالمثال" (macros by example)، أو "ماكرو `macro_rules!`"، أو فقط "الماكرو". في جوهرها، تسمح لك الماكرو التصريحية بكتابة شيء مشابه لتعبير `match` في Rust. كما نوقش في الفصل 6، تعبيرات `match` هي بنيات تحكم تأخذ تعبيرًا، وتقارن القيمة الناتجة من التعبير بالأنماط، ثم تشغل الكود المرتبط بالنمط المطابق. تقارن الماكرو أيضًا قيمة بأنماط مرتبطة بكود معين: في هذه الحالة، القيمة هي كود مصدر Rust الحرفي الممرر إلى الماكرو؛ تتم مقارنة الأنماط مع بنية ذلك الكود المصدري؛ والكود المرتبط بكل نمط، عند المطابقة، يستبدل الكود الممرر إلى الماكرو. كل هذا يحدث أثناء الترجمة.

لتعريف ماكرو، تستخدم بناء `macro_rules!`. دعنا نستكشف كيفية استخدام `macro_rules!` من خلال النظر إلى كيفية تعريف ماكرو `vec!`. غطى الفصل 8 كيف يمكننا استخدام ماكرو `vec!` لإنشاء متجه جديد بقيم معينة. على سبيل المثال، ينشئ الماكرو التالي متجهًا جديدًا يحتوي على ثلاثة أعداد صحيحة:

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

يمكننا أيضًا استخدام ماكرو `vec!` لإنشاء متجه من عددين صحيحين أو متجه من خمس شرائح سلسلة. لن نتمكن من استخدام دالة لفعل نفس الشيء لأننا لن نعرف عدد أو نوع القيم مسبقًا.

توضح القائمة 20-35 تعريفًا مبسطًا قليلاً لماكرو `vec!`.

<Listing number="20-35" file-name="src/lib.rs" caption="نسخة مبسطة من تعريف ماكرو `vec!`">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-35/src/lib.rs}}
```

</Listing>

> ملاحظة: التعريف الفعلي لماكرو `vec!` في المكتبة القياسية يتضمن كودًا لتخصيص كمية الذاكرة الصحيحة مسبقًا. هذا الكود هو تحسين لا نضمنه هنا، لجعل المثال أبسط.

التعليق التوضيحي `#[macro_export]` يشير إلى أن هذا الماكرو يجب أن يكون متاحًا كلما تم إحضار الصندوق الذي يُعرَّف فيه الماكرو إلى النطاق. بدون هذا التعليق التوضيحي، لا يمكن إحضار الماكرو إلى النطاق.

ثم نبدأ تعريف الماكرو بـ `macro_rules!` واسم الماكرو الذي نعرفه _بدون_ علامة التعجب. الاسم، في هذه الحالة `vec`، يتبعه أقواس معقوفة تشير إلى جسم تعريف الماكرو.

البنية في جسم `vec!` مشابهة لبنية تعبير `match`. هنا لدينا ذراع واحد بالنمط `( $( $x:expr ),* )`، يتبعه `=>` وكتلة الكود المرتبطة بهذا النمط. إذا طابق النمط، سيتم إصدار كتلة الكود المرتبطة. بالنظر إلى أن هذا هو النمط الوحيد في هذا الماكرو، هناك طريقة صحيحة واحدة فقط للمطابقة؛ أي نمط آخر سيؤدي إلى خطأ. الماكرو الأكثر تعقيدًا سيكون لها أكثر من ذراع واحد.

بناء جملة النمط الصحيح في تعريفات الماكرو يختلف عن بناء جملة النمط المغطى في الفصل 19 لأن أنماط الماكرو تُطابق ضد بنية كود Rust بدلاً من القيم. دعنا نمر على ما تعنيه قطع النمط في القائمة 20-29؛ للحصول على بناء جملة النمط الكامل للماكرو، انظر [مرجع Rust][ref].

أولاً، نستخدم مجموعة من الأقواس لتشمل النمط بأكمله. نستخدم علامة الدولار (`$`) للإعلان عن متغير في نظام الماكرو الذي سيحتوي على كود Rust المطابق للنمط. علامة الدولار تجعل من الواضح أن هذا متغير ماكرو بدلاً من متغير Rust عادي. بعد ذلك يأتي مجموعة من الأقواس التي تلتقط القيم التي تطابق النمط داخل الأقواس للاستخدام في الكود البديل. داخل `$()` يوجد `$x:expr`، الذي يطابق أي تعبير Rust ويعطي التعبير الاسم `$x`.

الفاصلة التي تلي `$()` تشير إلى أن حرف فاصلة حرفي يجب أن يظهر بين كل نسخة من الكود الذي يطابق الكود في `$()`. تحدد `*` أن النمط يطابق صفرًا أو أكثر مما يسبق `*`.

عندما نستدعي هذا الماكرو بـ `vec![1, 2, 3];`، يطابق النمط `$x` ثلاث مرات مع التعبيرات الثلاثة `1`، `2`، و `3`.

الآن دعنا ننظر إلى النمط في جسم الكود المرتبط بهذا الذراع: يتم توليد `temp_vec.push()` داخل `$()*` لكل جزء يطابق `$()` في النمط صفرًا أو أكثر من المرات اعتمادًا على عدد مرات مطابقة النمط. يتم استبدال `$x` بكل تعبير مطابق. عندما نستدعي هذا الماكرو بـ `vec![1, 2, 3];`، سيكون الكود المولد الذي يستبدل استدعاء الماكرو هذا كما يلي:

```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

لقد عرفنا ماكرو يمكنه أخذ أي عدد من الوسائط من أي نوع ويمكنه توليد كود لإنشاء متجه يحتوي على العناصر المحددة.

لمعرفة المزيد حول كيفية كتابة الماكرو، راجع الوثائق عبر الإنترنت أو موارد أخرى، مثل ["كتاب Rust Macros الصغير"][tlborm] الذي بدأه Daniel Keep واستمر به Lukas Wirth.

### الماكرو الإجرائية لتوليد الكود من السمات

الشكل الثاني من الماكرو هو _الماكرو الإجرائية_ (procedural macro)، والتي تعمل أكثر مثل دالة (وهي نوع من الإجراء). تقبل الماكرو الإجرائية بعض الكود كمدخل، وتعمل على هذا الكود، وتنتج بعض الكود كمخرج بدلاً من المطابقة ضد الأنماط واستبدال الكود بكود آخر كما تفعل الماكرو التصريحية. الأنواع الثلاثة من الماكرو الإجرائية هي `derive` المخصصة، والشبيهة بالسمات، والشبيهة بالدوال، وجميعها تعمل بطريقة مشابهة.

عند إنشاء الماكرو الإجرائية، يجب أن تكون التعريفات في صندوقها الخاص بنوع صندوق خاص. هذا لأسباب تقنية معقدة نأمل في إزالتها في المستقبل. في القائمة 20-36، نوضح كيفية تعريف ماكرو إجرائي، حيث `some_attribute` هو نائب لاستخدام نوع ماكرو محدد.

<Listing number="20-36" file-name="src/lib.rs" caption="مثال على تعريف ماكرو إجرائي">

```rust,ignore
use proc_macro::TokenStream;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

</Listing>

الدالة التي تعرف ماكرو إجرائي تأخذ `TokenStream` كمدخل وتنتج `TokenStream` كمخرج. نوع `TokenStream` معرف بواسطة صندوق `proc_macro` المضمن مع Rust ويمثل تسلسل من الرموز (tokens). هذا هو جوهر الماكرو: الكود المصدري الذي يعمل عليه الماكرو يشكل `TokenStream` المدخل، والكود الذي ينتجه الماكرو هو `TokenStream` المخرج. الدالة لديها أيضًا سمة مرفقة بها تحدد نوع الماكرو الإجرائي الذي ننشئه. يمكن أن يكون لدينا أنواع متعددة من الماكرو الإجرائية في نفس الصندوق.

دعنا ننظر إلى الأنواع المختلفة من الماكرو الإجرائية. سنبدأ بماكرو `derive` مخصص ثم نشرح الاختلافات الصغيرة التي تجعل الأشكال الأخرى مختلفة.

<!-- Old headings. Do not remove or links may break. -->

<a id="how-to-write-a-custom-derive-macro"></a>

### ماكرو `derive` المخصصة

دعنا ننشئ صندوقًا يُسمى `hello_macro` يعرف سِمَة تُسمى `HelloMacro` بدالة مرتبطة واحدة تُسمى `hello_macro`. بدلاً من جعل مستخدمينا يطبقون سِمَة `HelloMacro` لكل من أنواعهم، سنوفر ماكرو إجرائيًا بحيث يمكن للمستخدمين التعليق على نوعهم بـ `#[derive(HelloMacro)]` للحصول على تطبيق افتراضي لدالة `hello_macro`. سيطبع التطبيق الافتراضي `Hello, Macro! My name is TypeName!` حيث `TypeName` هو اسم النوع الذي تم تعريف هذه السِمَة عليه. بمعنى آخر، سنكتب صندوقًا يمكّن مبرمجًا آخر من كتابة كود مثل القائمة 20-37 باستخدام صندوقنا.

<Listing number="20-37" file-name="src/main.rs" caption="الكود الذي سيتمكن مستخدم صندوقنا من كتابته عند استخدام ماكرونا الإجرائي">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-37/src/main.rs}}
```

</Listing>

سيطبع هذا الكود `Hello, Macro! My name is Pancakes!` عندما ننتهي. الخطوة الأولى هي إنشاء صندوق مكتبة جديد، مثل هذا:

```console
$ cargo new hello_macro --lib
```

بعد ذلك، في القائمة 20-38، سنعرف سِمَة `HelloMacro` ودالتها المرتبطة.

<Listing file-name="src/lib.rs" number="20-38" caption="سِمَة بسيطة سنستخدمها مع ماكرو `derive`">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-38/hello_macro/src/lib.rs}}
```

</Listing>

لدينا سِمَة ودالتها. في هذه المرحلة، يمكن لمستخدم صندوقنا تطبيق السِمَة لتحقيق الوظيفة المرغوبة، كما في القائمة 20-39.

<Listing number="20-39" file-name="src/main.rs" caption="كيف سيبدو إذا كتب المستخدمون تطبيقًا يدويًا لسِمَة `HelloMacro`">

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-39/pancakes/src/main.rs}}
```

</Listing>

ومع ذلك، سيحتاجون إلى كتابة كتلة التطبيق لكل نوع يريدون استخدامه مع `hello_macro`؛ نريد أن نوفر عليهم القيام بهذا العمل.

بالإضافة إلى ذلك، لا يمكننا بعد توفير دالة `hello_macro` بتطبيق افتراضي سيطبع اسم النوع الذي تُطبق عليه السِمَة: ليس لدى Rust قدرات انعكاس (reflection)، لذلك لا يمكنه البحث عن اسم النوع في وقت التشغيل. نحتاج إلى ماكرو لتوليد كود في وقت الترجمة.

الخطوة التالية هي تعريف الماكرو الإجرائي. في وقت كتابة هذا، تحتاج الماكرو الإجرائية إلى أن تكون في صندوقها الخاص. في النهاية، قد يتم رفع هذا القيد. الاتفاقية لهيكلة الصناديق والماكرو الصناديق هي كما يلي: لصندوق يُسمى `foo`، يُسمى صندوق الماكرو الإجرائي `derive` المخصص `foo_derive`. لنبدأ صندوقًا جديدًا يُسمى `hello_macro_derive` داخل مشروع `hello_macro` الخاص بنا:

```console
$ cargo new hello_macro_derive --lib
```

صندوقانا مرتبطان بشكل وثيق، لذلك ننشئ صندوق الماكرو الإجرائي داخل دليل صندوق `hello_macro` الخاص بنا. إذا غيرنا تعريف السِمَة في `hello_macro`، سيتعين علينا تغيير تطبيق الماكرو الإجرائي في `hello_macro_derive` أيضًا. سيحتاج الصندوقان إلى النشر بشكل منفصل، والمبرمجون الذين يستخدمون هذه الصناديق سيحتاجون إلى إضافة كليهما كاعتماديات وإحضارهما كليهما إلى النطاق. يمكننا بدلاً من ذلك أن يستخدم صندوق `hello_macro` صندوق `hello_macro_derive` كاعتمادية ويعيد تصدير كود الماكرو الإجرائي. ومع ذلك، الطريقة التي هيكلنا بها المشروع تجعل من الممكن للمبرمجين استخدام `hello_macro` حتى لو لم يريدوا وظيفة `derive`.

نحتاج إلى التصريح عن صندوق `hello_macro_derive` كصندوق ماكرو إجرائي. سنحتاج أيضًا إلى وظيفة من صناديق `syn` و `quote`، كما سترى خلال لحظة، لذلك نحتاج إلى إضافتها كاعتماديات. أضف ما يلي إلى ملف _Cargo.toml_ لـ `hello_macro_derive`:

<Listing file-name="hello_macro_derive/Cargo.toml">

```toml
{{#include ../listings/ch20-advanced-features/listing-20-40/hello_macro/hello_macro_derive/Cargo.toml:6:12}}
```

</Listing>

لبدء تعريف الماكرو الإجرائي، ضع الكود في القائمة 20-40 في ملف _src/lib.rs_ الخاص بك لصندوق `hello_macro_derive`. لاحظ أن هذا الكود لن يُترجم حتى نضيف تعريفًا لدالة `impl_hello_macro`.

<Listing number="20-40" file-name="hello_macro_derive/src/lib.rs" caption="كود يحتاجه معظم صناديق الماكرو الإجرائية من أجل معالجة كود Rust">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-40/hello_macro/hello_macro_derive/src/lib.rs}}
```

</Listing>

لاحظ أننا قسمنا الكود إلى دالة `hello_macro_derive`، المسؤولة عن تحليل `TokenStream`، ودالة `impl_hello_macro`، المسؤولة عن تحويل شجرة البناء (syntax tree): هذا يجعل كتابة ماكرو إجرائي أكثر ملاءمة. سيكون الكود في الدالة الخارجية (`hello_macro_derive` في هذه الحالة) هو نفسه لكل صندوق ماكرو إجرائي تراه أو تنشئه تقريبًا. الكود الذي تحدده في جسم الدالة الداخلية (`impl_hello_macro` في هذه الحالة) سيكون مختلفًا اعتمادًا على غرض الماكرو الإجرائي الخاص بك.

لقد قدمنا ثلاثة صناديق جديدة: `proc_macro`، [`syn`][syn]<!-- ignore -->، و [`quote`][quote]<!-- ignore -->. يأتي صندوق `proc_macro` مع Rust، لذلك لم نحتج إلى إضافته إلى الاعتماديات في _Cargo.toml_. صندوق `proc_macro` هو API المترجم الذي يسمح لنا بقراءة ومعالجة كود Rust من كودنا.

يحلل صندوق `syn` كود Rust من سلسلة إلى بنية بيانات يمكننا إجراء عمليات عليها. يحول صندوق `quote` بنيات بيانات `syn` إلى كود Rust. تجعل هذه الصناديق تحليل أي نوع من كود Rust قد نريد التعامل معه أبسط بكثير: كتابة محلل كامل لكود Rust ليس مهمة بسيطة.

ستُستدعى دالة `hello_macro_derive` عندما يحدد مستخدم مكتبتنا `#[derive(HelloMacro)]` على نوع. هذا ممكن لأننا علّقنا دالة `hello_macro_derive` هنا بـ `proc_macro_derive` وحددنا الاسم `HelloMacro`، الذي يطابق اسم سِمَتنا؛ هذا هو الاتفاق الذي تتبعه معظم الماكرو الإجرائية.

تحول دالة `hello_macro_derive` أولاً `input` من `TokenStream` إلى بنية بيانات يمكننا بعد ذلك تفسيرها وإجراء عمليات عليها. هذا هو المكان الذي يلعب فيه `syn` دوره. تأخذ دالة `parse` في `syn` `TokenStream` وتعيد بنية `DeriveInput` التي تمثل كود Rust المحلل. توضح القائمة 20-41 الأجزاء ذات الصلة من بنية `DeriveInput` التي نحصل عليها من تحليل سلسلة `struct Pancakes;`.

<Listing number="20-41" caption="نسخة `DeriveInput` التي نحصل عليها عند تحليل الكود الذي لديه سمة الماكرو في القائمة 20-37">

```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

</Listing>

تُظهر حقول هذه البنية أن كود Rust الذي قمنا بتحليله هو بنية وحدة (unit struct) مع `ident` (_معرف_، أي الاسم) لـ `Pancakes`. توجد حقول أكثر على هذه البنية لوصف جميع أنواع كود Rust؛ تحقق من [وثائق `syn` لـ `DeriveInput`][syn-docs] لمزيد من المعلومات.

قريبًا سنعرف دالة `impl_hello_macro`، وهي المكان الذي سنبني فيه كود Rust الجديد الذي نريد تضمينه. ولكن قبل ذلك، لاحظ أن المخرج لماكرو `derive` الخاص بنا هو أيضًا `TokenStream`. يتم إضافة `TokenStream` المُعاد إلى الكود الذي يكتبه مستخدمو صندوقنا، لذلك عندما يقومون بترجمة صندوقهم، سيحصلون على الوظيفة الإضافية التي نوفرها في `TokenStream` المعدل.

قد لاحظت أننا نستدعي `unwrap` لجعل دالة `hello_macro_derive` تذعر إذا فشل استدعاء دالة `syn::parse` هنا. من الضروري أن يذعر الماكرو الإجرائي الخاص بنا عند الأخطاء لأن دوال `proc_macro_derive` يجب أن تعيد `TokenStream` بدلاً من `Result` للتوافق مع API الماكرو الإجرائي. لقد بسطنا هذا المثال باستخدام `unwrap`؛ في كود الإنتاج، يجب عليك توفير رسائل خطأ أكثر تحديدًا حول ما حدث خطأ باستخدام `panic!` أو `expect`.

الآن بعد أن أصبح لدينا الكود لتحويل كود Rust المُعلّق من `TokenStream` إلى نسخة `DeriveInput`، دعنا نولد الكود الذي يطبق سِمَة `HelloMacro` على النوع المُعلّق، كما هو موضح في القائمة 20-42.

<Listing number="20-42" file-name="hello_macro_derive/src/lib.rs" caption="تطبيق سِمَة `HelloMacro` باستخدام كود Rust المحلل">

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-42/hello_macro/hello_macro_derive/src/lib.rs:here}}
```

</Listing>

نحصل على نسخة بنية `Ident` تحتوي على الاسم (المعرف) للنوع المُعلّق باستخدام `ast.ident`. تُظهر البنية في القائمة 20-41 أنه عندما نشغل دالة `impl_hello_macro` على الكود في القائمة 20-37، فإن `ident` الذي نحصل عليه سيكون لديه حقل `ident` بقيمة `"Pancakes"`. وبالتالي، سيحتوي المتغير `name` في القائمة 20-42 على نسخة بنية `Ident` التي، عند طباعتها، ستكون السلسلة `"Pancakes"`، اسم البنية في القائمة 20-37.

يتيح لنا ماكرو `quote!` تعريف كود Rust الذي نريد إرجاعه. يتوقع المترجم شيئًا مختلفًا عن النتيجة المباشرة لتنفيذ ماكرو `quote!`، لذلك نحتاج إلى تحويله إلى `TokenStream`. نفعل ذلك بـ استدعاء طريقة `into`، التي تستهلك هذا التمثيل الوسيط وتعيد قيمة من النوع المطلوب `TokenStream`.

يوفر ماكرو `quote!` أيضًا بعض ميكانيكية القوالب الرائعة جدًا: يمكننا إدخال `#name`، و `quote!` سيستبدله بالقيمة في المتغير `name`. يمكنك حتى إجراء بعض التكرار مشابه لطريقة عمل الماكرو العادية. تحقق من [وثائق صندوق `quote`][quote-docs] للحصول على مقدمة شاملة.

نريد أن يولد الماكرو الإجرائي الخاص بنا تطبيقًا لسِمَة `HelloMacro` للنوع الذي علّق عليه المستخدم، والذي يمكننا الحصول عليه باستخدام `#name`. يحتوي تطبيق السِمَة على دالة واحدة `hello_macro`، التي يحتوي جسمها على الوظيفة التي نريد توفيرها: طباعة `Hello, Macro! My name is` ثم اسم النوع المُعلّق.

ماكرو `stringify!` المستخدم هنا مدمج في Rust. يأخذ تعبير Rust، مثل `1 + 2`، وفي وقت الترجمة يحول التعبير إلى سلسلة حرفية، مثل `"1 + 2"`. هذا مختلف عن `format!` أو `println!`، وهما ماكرو تقيّم التعبير ثم تحول النتيجة إلى `String`. هناك احتمال أن مدخل `#name` قد يكون تعبيرًا للطباعة حرفيًا، لذلك نستخدم `stringify!`. استخدام `stringify!` يوفر أيضًا تخصيصًا من خلال تحويل `#name` إلى سلسلة حرفية في وقت الترجمة.

في هذه المرحلة، يجب أن يكمل `cargo build` بنجاح في كل من `hello_macro` و `hello_macro_derive`. دعنا نربط هذه الصناديق بالكود في القائمة 20-37 لرؤية الماكرو الإجرائي أثناء العمل! أنشئ مشروعًا ثنائيًا جديدًا في دليل _projects_ الخاص بك باستخدام `cargo new pancakes`. نحتاج إلى إضافة `hello_macro` و `hello_macro_derive` كاعتماديات في ملف _Cargo.toml_ لصندوق `pancakes`. إذا كنت تنشر نسخك من `hello_macro` و `hello_macro_derive` إلى [crates.io](https://crates.io/)<!-- ignore -->، فستكون اعتماديات عادية؛ إن لم يكن، يمكنك تحديدها كاعتماديات `path` على النحو التالي:

```toml
{{#include ../listings/ch20-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:6:8}}
```

ضع الكود في القائمة 20-37 في _src/main.rs_، وشغّل `cargo run`: يجب أن يطبع `Hello, Macro! My name is Pancakes!`. تم تضمين تطبيق سِمَة `HelloMacro` من الماكرو الإجرائي دون أن يحتاج صندوق `pancakes` لتطبيقه؛ أضاف `#[derive(HelloMacro)]` تطبيق السِمَة.

بعد ذلك، دعنا نستكشف كيف تختلف الأنواع الأخرى من الماكرو الإجرائية عن ماكرو `derive` المخصصة.

### الماكرو الشبيهة بالسمات

الماكرو الشبيهة بالسمات مشابهة لماكرو `derive` المخصصة، لكن بدلاً من توليد كود لسمة `derive`، فإنها تسمح لك بإنشاء سمات جديدة. إنها أيضًا أكثر مرونة: `derive` تعمل فقط للبنيات و enums؛ يمكن تطبيق السمات على عناصر أخرى أيضًا، مثل الدوال. إليك مثال على استخدام ماكرو شبيه بالسمات. لنفترض أن لديك سمة تُسمى `route` تُعلّق الدوال عند استخدام إطار عمل تطبيق ويب:

```rust,ignore
#[route(GET, "/")]
fn index() {
```

ستُعرَّف سمة `#[route]` هذه بواسطة الإطار كماكرو إجرائي. سيبدو توقيع دالة تعريف الماكرو هكذا:

```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

هنا، لدينا معاملان من النوع `TokenStream`. الأول للمحتويات السمة: جزء `GET, "/"`. الثاني هو جسم العنصر الذي ترتبط به السمة: في هذه الحالة، `fn index() {}` وبقية جسم الدالة.

بخلاف ذلك، تعمل الماكرو الشبيهة بالسمات بنفس طريقة ماكرو `derive` المخصصة: تنشئ صندوقًا بنوع صندوق `proc-macro` وتطبق دالة تولد الكود الذي تريده!

### الماكرو الشبيهة بالدوال

تعرف الماكرو الشبيهة بالدوال ماكرو تبدو مثل استدعاءات الدوال. بشكل مشابه لماكرو `macro_rules!`، فهي أكثر مرونة من الدوال؛ على سبيل المثال، يمكنها أخذ عدد غير معروف من الوسائط. ومع ذلك، لا يمكن تعريف ماكرو `macro_rules!` إلا باستخدام بناء جملة شبيه بالمطابقة الذي ناقشناه في قسم ["الماكرو التصريحية للبرمجة الوصفية العامة"][decl]<!-- ignore --> في وقت سابق. تأخذ الماكرو الشبيهة بالدوال معامل `TokenStream`، ويتلاعب تعريفها بـ `TokenStream` باستخدام كود Rust كما يفعل النوعان الآخران من الماكرو الإجرائية. مثال على ماكرو شبيه بالدوال هو ماكرو `sql!` الذي قد يُستدعى هكذا:

```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

سيحلل هذا الماكرو بيان SQL بداخله ويتحقق من أنه صحيح نحويًا، وهو معالجة أكثر تعقيدًا بكثير مما يمكن لماكرو `macro_rules!` القيام به. سيتم تعريف ماكرو `sql!` هكذا:

```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

هذا التعريف مشابه لتوقيع ماكرو `derive` المخصص: نستقبل الرموز الموجودة داخل الأقواس ونعيد الكود الذي أردنا توليده.

## الملخص

رائع! الآن لديك بعض ميزات Rust في صندوق أدواتك التي من المحتمل ألا تستخدمها كثيرًا، ولكنك ستعرف أنها متاحة في ظروف محددة جدًا. لقد قدمنا عدة مواضيع معقدة بحيث عندما تواجهها في اقتراحات رسائل الخطأ أو في كود أشخاص آخرين، ستتمكن من التعرف على هذه المفاهيم وبناء الجملة. استخدم هذا الفصل كمرجع لتوجيهك إلى الحلول.

بعد ذلك، سنضع كل ما ناقشناه خلال الكتاب موضع التطبيق ونقوم بمشروع آخر!

[ref]: ../reference/macros-by-example.html
[tlborm]: https://veykril.github.io/tlborm/
[syn]: https://crates.io/crates/syn
[quote]: https://crates.io/crates/quote
[syn-docs]: https://docs.rs/syn/2.0/syn/struct.DeriveInput.html
[quote-docs]: https://docs.rs/quote
[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming
