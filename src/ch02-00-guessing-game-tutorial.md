# การเขียนโปรแกรมเกมทายตัวเลข

มาเริ่มเข้าสู่ Rust ด้วยการทำโปรเจกต์แบบลงมือปฏิบัติจริงไปด้วยกัน! บทนี้จะแนะนำแนวคิดทั่วไปของ Rust หลายอย่างโดยแสดงให้คุณเห็นถึงวิธีการใช้งานในโปรแกรมจริง คุณจะได้เรียนรู้เกี่ยวกับ `let`, `match`, เมธอด, ฟังก์ชันที่เกี่ยวข้อง (associated functions), крейт ภายนอก (external crates) และอื่นๆ อีกมากมาย! ในบทต่อๆ ไป เราจะสำรวจแนวคิดเหล่านี้ในรายละเอียดเพิ่มเติม ในบทนี้ คุณจะได้ฝึกฝนพื้นฐานเพียงอย่างเดียว

เราจะ υλοποιώ (implement) ปัญหาการเขียนโปรแกรมคลาสสิกสำหรับผู้เริ่มต้น: เกมทายตัวเลข วิธีการทำงานคือ: โปรแกรมจะสร้างจำนวนเต็มสุ่มระหว่าง 1 ถึง 100 จากนั้นจะแจ้งให้ผู้เล่นป้อนค่าที่ทาย หลังจากป้อนค่าที่ทายแล้ว โปรแกรมจะระบุว่าค่าที่ทายนั้นต่ำหรือสูงเกินไป หากทายถูก เกมจะพิมพ์ข้อความแสดงความยินดีและจบการทำงาน

## การตั้งค่าโปรเจกต์ใหม่

ในการตั้งค่าโปรเจกต์ใหม่ ให้ไปที่ไดเรกทอรี _projects_ ที่คุณสร้างไว้ในบทที่ 1 และสร้างโปรเจกต์ใหม่โดยใช้ Cargo ดังนี้:

```console
$ cargo new guessing_game
$ cd guessing_game
```

คำสั่งแรก `cargo new` รับชื่อโปรเจกต์ (`guessing_game`) เป็นอาร์กิวเมนต์แรก คำสั่งที่สองเปลี่ยนไปยังไดเรกทอรีของโปรเจกต์ใหม่

ดูไฟล์ _Cargo.toml_ ที่สร้างขึ้น:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->

<span class="filename">ชื่อไฟล์: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

ดังที่คุณเห็นในบทที่ 1 `cargo new` จะสร้างโปรแกรม “Hello, world!” ให้คุณ ตรวจสอบไฟล์ _src/main.rs_:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

ตอนนี้เรามาคอมไพล์โปรแกรม “Hello, world!” นี้และรันในขั้นตอนเดียวกันโดยใช้คำสั่ง `cargo run`:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

คำสั่ง `run` มีประโยชน์เมื่อคุณต้องการทำซ้ำโปรเจกต์อย่างรวดเร็ว ดังที่เราจะทำในเกมนี้ โดยทดสอบแต่ละรอบอย่างรวดเร็วก่อนที่จะไปยังรอบถัดไป

เปิดไฟล์ _src/main.rs_ อีกครั้ง คุณจะเขียนโค้ดทั้งหมดในไฟล์นี้

## การประมวลผลค่าที่ทาย

ส่วนแรกของโปรแกรมเกมทายตัวเลขจะขออินพุตจากผู้ใช้ ประมวลผลอินพุตนั้น และตรวจสอบว่าอินพุตอยู่ในรูปแบบที่คาดไว้ ในการเริ่มต้น เราจะอนุญาตให้ผู้เล่นป้อนค่าที่ทาย ป้อนโค้ดใน Listing 2-1 ลงใน _src/main.rs_

<Listing number="2-1" file-name="src/main.rs" caption="โค้ดที่รับค่าทายจากผู้ใช้และพิมพ์ออกมา">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

</Listing>

โค้ดนี้มีข้อมูลจำนวนมาก ดังนั้นเรามาดูทีละบรรทัด ในการรับอินพุตจากผู้ใช้แล้วพิมพ์ผลลัพธ์เป็นเอาต์พุต เราจำเป็นต้องนำไลบรารี `io` (input/output) เข้ามาในขอบเขต (scope) ไลบรารี `io` มาจากไลบรารีมาตรฐาน ซึ่งเรียกว่า `std`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

โดยค่าเริ่มต้น Rust มีชุดของไอเท็มที่กำหนดไว้ในไลบรารีมาตรฐานซึ่งจะนำเข้ามาในขอบเขตของทุกโปรแกรม ชุดนี้เรียกว่า _prelude_ และคุณสามารถดูทุกอย่างในนั้นได้ [ในเอกสารประกอบไลบรารีมาตรฐาน][prelude]

หากไทป์ที่คุณต้องการใช้ไม่ได้อยู่ใน prelude คุณต้องนำไทป์นั้นเข้ามาในขอบเขตอย่างชัดเจนด้วยคำสั่ง `use` การใช้ไลบรารี `std::io` จะให้ฟีเจอร์ที่มีประโยชน์มากมายแก่คุณ รวมถึงความสามารถในการรับอินพุตจากผู้ใช้

ดังที่คุณเห็นในบทที่ 1 ฟังก์ชัน `main` คือจุดเริ่มต้นของโปรแกรม:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

синтаксис `fn` ประกาศฟังก์ชันใหม่ วงเล็บ `()` ระบุว่าไม่มีพารามิเตอร์ และวงเล็บปีกกา `{` เริ่มต้นเนื้อหาของฟังก์ชัน

ดังที่คุณได้เรียนรู้ในบทที่ 1 ด้วย `println!` เป็นมาโครที่พิมพ์สตริงออกทางหน้าจอ:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

โค้ดนี้กำลังพิมพ์พรอมต์ที่ระบุว่าเกมคืออะไรและขออินพุตจากผู้ใช้

### การเก็บค่าด้วยตัวแปร

ถัดไป เราจะสร้าง _ตัวแปร_ เพื่อเก็บอินพุตของผู้ใช้ ดังนี้:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

ตอนนี้โปรแกรมน่าสนใจขึ้นแล้ว! มีอะไรมากมายเกิดขึ้นในบรรทัดเล็กๆ นี้ เราใช้คำสั่ง `let` เพื่อสร้างตัวแปร นี่คืออีกตัวอย่างหนึ่ง:

```rust,ignore
let apples = 5;
```

บรรทัดนี้สร้างตัวแปรใหม่ชื่อ `apples` และผูกเข้ากับค่า 5 ใน Rust ตัวแปรจะเป็นแบบ immutable (ไม่สามารถเปลี่ยนแปลงค่าได้) โดยค่าเริ่มต้น หมายความว่าเมื่อเรากำหนดค่าให้กับตัวแปรแล้ว ค่าจะไม่เปลี่ยนแปลง เราจะพูดถึงแนวคิดนี้โดยละเอียดในส่วน [“ตัวแปรและการเปลี่ยนแปลงค่า”][variables-and-mutability]<!-- ignore --> ในบทที่ 3 หากต้องการทำให้ตัวแปรเป็น mutable (สามารถเปลี่ยนแปลงค่าได้) เราจะเพิ่ม `mut` หน้าชื่อตัวแปร:

```rust,ignore
let apples = 5; // immutable
let mut bananas = 5; // mutable
```

> หมายเหตุ: синтаксис `//` เริ่มต้นคอมเมนต์ที่จะดำเนินต่อไปจนถึงสิ้นสุดบรรทัด Rust จะละเว้นทุกอย่างในคอมเมนต์ เราจะพูดถึงคอมเมนต์ในรายละเอียดเพิ่มเติมใน [บทที่ 3][comments]<!-- ignore -->

กลับมาที่โปรแกรมเกมทายตัวเลข ตอนนี้คุณรู้แล้วว่า `let mut guess` จะสร้างตัวแปร mutable ชื่อ `guess` เครื่องหมายเท่ากับ (`=`) บอก Rust ว่าเราต้องการผูกบางสิ่งเข้ากับตัวแปรในตอนนี้ ทางด้านขวาของเครื่องหมายเท่ากับคือค่าที่ `guess` ถูกผูกไว้ ซึ่งเป็นผลลัพธ์ของการเรียก `String::new` ซึ่งเป็นฟังก์ชันที่คืนค่าอินสแตนซ์ใหม่ของ `String` [`String`][string]<!-- ignore --> คือไทป์สตริงที่ไลบรารีมาตรฐานมีให้ ซึ่งเป็นข้อความที่เข้ารหัสแบบ UTF-8 ที่สามารถขยายขนาดได้

синтаксиส `::` ในบรรทัด `::new` ระบุว่า `new` เป็นฟังก์ชันที่เกี่ยวข้อง (associated function) ของไทป์ `String` _ฟังก์ชันที่เกี่ยวข้อง_ คือฟังก์ชันที่ υλοποιώ (implement) บนไทป์ ในกรณีนี้คือ `String` ฟังก์ชัน `new` นี้สร้างสตริงใหม่ที่ว่างเปล่า คุณจะพบฟังก์ชัน `new` บนหลายไทป์เนื่องจากเป็นชื่อทั่วไปสำหรับฟังก์ชันที่สร้างค่าใหม่บางประเภท

โดยสรุป บรรทัด `let mut guess = String::new();` ได้สร้างตัวแปร mutable ที่ปัจจุบันผูกอยู่กับอินสแตนซ์ใหม่ที่ว่างเปล่าของ `String` โอ้โห!

### การรับอินพุตจากผู้ใช้

จำได้ว่าเรารวมฟังก์ชันการทำงาน input/output จากไลบรารีมาตรฐานด้วย `use std::io;` ในบรรทัดแรกของโปรแกรม ตอนนี้เราจะเรียกฟังก์ชัน `stdin` จากโมดูล `io` ซึ่งจะช่วยให้เราสามารถจัดการอินพุตของผู้ใช้ได้:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

หากเราไม่ได้นำเข้าโมดูล `io` ด้วย `use std::io;` ที่ตอนต้นของโปรแกรม เรายังคงสามารถใช้ฟังก์ชันได้โดยเขียนการเรียกฟังก์ชันนี้เป็น `std::io::stdin` ฟังก์ชัน `stdin` คืนค่าอินสแตนซ์ของ [`std::io::Stdin`][iostdin]<!-- ignore --> ซึ่งเป็นไทป์ที่แสดงถึง handle ไปยัง standard input สำหรับเทอร์มินัลของคุณ

ถัดไป บรรทัด `.read_line(&mut guess)` เรียกเมธอด [`read_line`][read_line]<!-- ignore --> บน standard input handle เพื่อรับอินพุตจากผู้ใช้ เรายังส่ง `&mut guess` เป็นอาร์กิวเมนต์ไปยัง `read_line` เพื่อบอกว่าจะเก็บอินพุตของผู้ใช้ไว้ในสตริงใด หน้าที่ทั้งหมดของ `read_line` คือการรับสิ่งที่ผู้ใช้พิมพ์เข้ามาใน standard input และต่อท้ายเข้าไปในสตริง (โดยไม่เขียนทับเนื้อหาเดิม) ดังนั้นเราจึงส่งสตริงนั้นเป็นอาร์กิวเมนต์ อาร์กิวเมนต์สตริงจำเป็นต้องเป็น mutable เพื่อให้เมธอดสามารถเปลี่ยนแปลงเนื้อหาของสตริงได้

`&` บ่งชี้ว่าอาร์กิวเมนต์นี้เป็น _reference_ (การอ้างอิง) ซึ่งเป็นวิธีการให้โค้ดหลายส่วนของคุณเข้าถึงข้อมูลชิ้นเดียวได้โดยไม่จำเป็นต้องคัดลอกข้อมูลนั้นไปยังหน่วยความจำหลายครั้ง References เป็นฟีเจอร์ที่ซับซ้อน และข้อได้เปรียบหลักประการหนึ่งของ Rust คือความปลอดภัยและความง่ายในการใช้ references คุณไม่จำเป็นต้องรู้รายละเอียดเหล่านั้นมากนักเพื่อทำโปรแกรมนี้ให้เสร็จ สำหรับตอนนี้ สิ่งที่คุณต้องรู้คือ references ก็เหมือนกับตัวแปร คือเป็น immutable โดยค่าเริ่มต้น ดังนั้น คุณต้องเขียน `&mut guess` แทนที่จะเป็น `&guess` เพื่อทำให้มันเป็น mutable (บทที่ 4 จะอธิบาย references อย่างละเอียดมากขึ้น)

<!-- Old heading. Do not remove or links may break. -->

<a id="handling-potential-failure-with-the-result-type"></a>

### การจัดการความล้มเหลวที่อาจเกิดขึ้นด้วย `Result`

เรายังคงทำงานกับบรรทัดโค้ดนี้อยู่ ตอนนี้เรากำลังพูดถึงบรรทัดข้อความที่สาม แต่โปรดทราบว่ามันยังคงเป็นส่วนหนึ่งของบรรทัดโค้ดเชิงตรรกะเดียว ส่วนถัดไปคือเมธอดนี้:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

เราสามารถเขียนโค้ดนี้เป็น:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

อย่างไรก็ตาม บรรทัดยาวๆ หนึ่งบรรทัดนั้นอ่านยาก ดังนั้นจึงควรแบ่งมันออก มักจะเป็นการดีที่จะขึ้นบรรทัดใหม่และเพิ่มช่องว่างอื่นๆ เพื่อช่วยแบ่งบรรทัดยาวๆ เมื่อคุณเรียกเมธอดด้วย синтаксис `.method_name()` ตอนนี้เรามาดูกันว่าบรรทัดนี้ทำอะไร

ดังที่ได้กล่าวไว้ก่อนหน้านี้ `read_line` จะใส่สิ่งที่ผู้ใช้ป้อนเข้าไปในสตริงที่เราส่งให้ แต่มันยังคืนค่า `Result` ด้วย [`Result`][result]<!-- ignore --> คือ _enumeration_ (การแจงนับ)<!-- ignore --> หรือที่มักเรียกว่า _enum_ ซึ่งเป็นไทป์ที่สามารถอยู่ในสถานะที่เป็นไปได้หลายสถานะ เราเรียกแต่ละสถานะที่เป็นไปได้ว่า _variant_ (แวเรียนต์)

[บทที่ 6][enums]<!-- ignore --> จะครอบคลุม enums ในรายละเอียดเพิ่มเติม จุดประสงค์ของไทป์ `Result` เหล่านี้คือการเข้ารหัสข้อมูลการจัดการข้อผิดพลาด

variants ของ `Result` คือ `Ok` และ `Err` variant `Ok` บ่งชี้ว่าการดำเนินการสำเร็จ และมันมีค่าที่สร้างขึ้นสำเร็จอยู่ภายใน variant `Err` หมายความว่าการดำเนินการล้มเหลว และมันมีข้อมูลเกี่ยวกับว่าการดำเนินการล้มเหลวอย่างไรหรือเพราะเหตุใด

ค่าของไทป์ `Result` ก็เหมือนกับค่าของไทป์ใดๆ คือมีเมธอดที่กำหนดไว้บนนั้น อินสแตนซ์ของ `Result` มีเมธอด [`expect`][expect]<!-- ignore --> ที่คุณสามารถเรียกได้ หากอินสแตนซ์ของ `Result` นี้เป็นค่า `Err` `expect` จะทำให้โปรแกรมหยุดทำงาน (crash) และแสดงข้อความที่คุณส่งเป็นอาร์กิวเมนต์ไปยัง `expect` หากเมธอด `read_line` คืนค่า `Err` มันน่าจะเป็นผลมาจากข้อผิดพลาดที่มาจากระบบปฏิบัติการพื้นฐาน หากอินสแตนซ์ของ `Result` นี้เป็นค่า `Ok` `expect` จะนำค่าที่ `Ok` ถืออยู่และคืนค่าเฉพาะค่านั้นให้คุณเพื่อที่คุณจะสามารถใช้งานได้ ในกรณีนี้ ค่านั้นคือจำนวนไบต์ในอินพุตของผู้ใช้

หากคุณไม่เรียก `expect` โปรแกรมจะคอมไพล์ แต่คุณจะได้รับคำเตือน:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Rust เตือนว่าคุณยังไม่ได้ใช้ค่า `Result` ที่คืนค่าจาก `read_line` ซึ่งบ่งชี้ว่าโปรแกรมยังไม่ได้จัดการข้อผิดพลาดที่อาจเกิดขึ้น

วิธีที่ถูกต้องในการระงับคำเตือนคือการเขียนโค้ดจัดการข้อผิดพลาดจริงๆ แต่ในกรณีของเรา เราเพียงแค่ต้องการให้โปรแกรมนี้หยุดทำงานเมื่อเกิดปัญหาขึ้น ดังนั้นเราจึงสามารถใช้ `expect` ได้ คุณจะได้เรียนรู้เกี่ยวกับการกู้คืนจากข้อผิดพลาดใน [บทที่ 9][recover]<!-- ignore -->

### การพิมพ์ค่าด้วย Placeholder ของ `println!`

นอกเหนือจากวงเล็บปีกกาปิดแล้ว ยังมีอีกเพียงบรรทัดเดียวที่จะพูดถึงในโค้ดจนถึงตอนนี้:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

บรรทัดนี้พิมพ์สตริงที่ตอนนี้มีอินพุตของผู้ใช้อยู่ ชุดวงเล็บปีกกา `{}` เป็น placeholder: ลองนึกภาพ `{}` ว่าเป็นก้ามปูเล็กๆ ที่ยึดค่าไว้ เมื่อพิมพ์ค่าของตัวแปร ชื่อตัวแปรสามารถอยู่ภายในวงเล็บปีกกาได้ เมื่อพิมพ์ผลลัพธ์ของการประเมินนิพจน์ ให้ใส่วงเล็บปีกกาว่างๆ ในสตริงรูปแบบ จากนั้นตามด้วยรายการนิพจน์ที่คั่นด้วยจุลภาคเพื่อพิมพ์ในแต่ละ placeholder วงเล็บปีกกาว่างๆ ตามลำดับเดียวกัน การพิมพ์ตัวแปรและผลลัพธ์ของนิพจน์ในการเรียก `println!` ครั้งเดียวจะมีลักษณะดังนี้:

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

โค้ดนี้จะพิมพ์ `x = 5 and y + 2 = 12`

### การทดสอบส่วนแรก

มาทดสอบส่วนแรกของเกมทายตัวเลขกัน รันโดยใช้ `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

ณ จุดนี้ ส่วนแรกของเกมเสร็จสิ้นแล้ว: เรากำลังรับอินพุตจากคีย์บอร์ดแล้วพิมพ์ออกมา

## การสร้างเลขลับ

ถัดไป เราต้องสร้างเลขลับที่ผู้ใช้จะพยายามทาย เลขลับควรแตกต่างกันทุกครั้งเพื่อให้เกมสนุกกับการเล่นมากกว่าหนึ่งครั้ง เราจะใช้เลขสุ่มระหว่าง 1 ถึง 100 เพื่อให้เกมไม่ยากเกินไป Rust ยังไม่มีฟังก์ชันการทำงานเกี่ยวกับเลขสุ่มในไลบรารีมาตรฐาน อย่างไรก็ตาม ทีม Rust มี [`rand` crate][randcrate] ที่มีฟังก์ชันการทำงานดังกล่าว

### การใช้ Crate เพื่อให้ได้ฟังก์ชันการทำงานเพิ่มเติม

จำไว้ว่า крейт คือชุดของไฟล์ซอร์สโค้ด Rust โปรเจกต์ที่เรากำลังสร้างอยู่นี้เป็น _binary crate_ ซึ่งเป็นไฟล์ εκτελέσιμο (executable) `rand` crate เป็น _library crate_ ซึ่งมีโค้ดที่ตั้งใจจะใช้ในโปรแกรมอื่นและไม่สามารถ εκτελέσιμο (execute) ได้ด้วยตัวเอง

การประสานงานของ Cargo กับ крейт ภายนอกคือจุดที่ Cargo โดดเด่นอย่างแท้จริง ก่อนที่เราจะสามารถเขียนโค้ดที่ใช้ `rand` ได้ เราจำเป็นต้องแก้ไขไฟล์ _Cargo.toml_ เพื่อรวม `rand` crate เป็นการพึ่งพา (dependency) เปิดไฟล์นั้นตอนนี้และเพิ่มบรรทัดต่อไปนี้ที่ด้านล่าง ใต้ส่วนหัว `[dependencies]` ที่ Cargo สร้างให้คุณ อย่าลืมระบุ `rand` ให้ตรงตามที่เราทำที่นี่ พร้อมหมายเลขเวอร์ชันนี้ มิฉะนั้นตัวอย่างโค้ดในบทช่วยสอนนี้อาจไม่ทำงาน:

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">ชื่อไฟล์: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:8:}}
```

ในไฟล์ _Cargo.toml_ ทุกอย่างที่ตามหลังส่วนหัวจะเป็นส่วนหนึ่งของส่วนนั้นซึ่งจะดำเนินต่อไปจนกว่าจะเริ่มส่วนอื่น ใน `[dependencies]` คุณบอก Cargo ว่าโปรเจกต์ของคุณ εξαρτώμαι (depend on) крейт ภายนอกใดบ้าง และต้องการ крейт เหล่านั้นเวอร์ชันใด ในกรณีนี้ เราระบุ `rand` crate ด้วยตัวระบุเวอร์ชันเชิงความหมาย (semantic version specifier) `0.8.5` Cargo เข้าใจ [Semantic Versioning][semver]<!-- ignore --> (บางครั้งเรียกว่า _SemVer_) ซึ่งเป็นมาตรฐานสำหรับการเขียนหมายเลขเวอร์ชัน ตัวระบุ `0.8.5` แท้จริงแล้วเป็นตัวย่อของ `^0.8.5` ซึ่งหมายถึงเวอร์ชันใดๆ ที่อย่างน้อย 0.8.5 แต่ต่ำกว่า 0.9.0

Cargo พิจารณาว่าเวอร์ชันเหล่านี้มี API สาธารณะที่เข้ากันได้กับเวอร์ชัน 0.8.5 และข้อกำหนดนี้ช่วยให้มั่นใจได้ว่าคุณจะได้รับ patch release ล่าสุดที่จะยังคงคอมไพล์กับโค้ดในบทนี้ได้ เวอร์ชัน 0.9.0 หรือสูงกว่าใดๆ ไม่รับประกันว่าจะม API เดียวกันกับที่ตัวอย่างต่อไปนี้ใช้

ตอนนี้ โดยไม่ต้องเปลี่ยนแปลงโค้ดใดๆ เรามา build โปรเจกต์กัน ดังที่แสดงใน Listing 2-2

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->

<Listing number="2-2" caption="ผลลัพธ์จากการรัน `cargo build` หลังจากเพิ่ม rand crate เป็นการพึ่งพา">

```console
$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
```

</Listing>

คุณอาจเห็นหมายเลขเวอร์ชันที่แตกต่างกัน (แต่ทั้งหมดจะเข้ากันได้กับโค้ด ขอบคุณ SemVer!) และบรรทัดที่แตกต่างกัน (ขึ้นอยู่กับระบบปฏิบัติการ) และบรรทัดอาจอยู่ในลำดับที่แตกต่างกัน

เมื่อเรารวมการพึ่งพาภายนอกเข้ามา Cargo จะดึงเวอร์ชันล่าสุดของทุกสิ่งที่การพึ่งพานั้นต้องการจาก _registry_ ซึ่งเป็นสำเนาของข้อมูลจาก [Crates.io][cratesio] Crates.io คือที่ที่ผู้คนในระบบนิเวศของ Rust โพสต์โปรเจกต์ Rust แบบโอเพนซอร์สของตนเพื่อให้ผู้อื่นใช้งาน

หลังจากอัปเดต registry แล้ว Cargo จะตรวจสอบส่วน `[dependencies]` และดาวน์โหลด крейт ใดๆ ที่ระบุไว้ซึ่งยังไม่ได้ดาวน์โหลด ในกรณีนี้ แม้ว่าเราจะระบุเพียง `rand` เป็นการพึ่งพา Cargo ก็ยังดึง крейт อื่นๆ ที่ `rand` εξαρτώμαι (depend on) เพื่อทำงานด้วย หลังจากดาวน์โหลด крейт แล้ว Rust จะคอมไพล์พวกมันแล้วจึงคอมไพล์โปรเจกต์พร้อมกับการพึ่งพาที่มีอยู่

หากคุณรัน `cargo build` อีกครั้งทันทีโดยไม่มีการเปลี่ยนแปลงใดๆ คุณจะไม่ได้รับผลลัพธ์ใดๆ นอกจากบรรทัด `Finished` Cargo รู้ว่ามันได้ดาวน์โหลดและคอมไพล์การพึ่งพาแล้ว และคุณยังไม่ได้เปลี่ยนแปลงอะไรเกี่ยวกับการพึ่งพาเหล่านั้นในไฟล์ _Cargo.toml_ ของคุณ Cargo ยังรู้ด้วยว่าคุณยังไม่ได้เปลี่ยนแปลงอะไรเกี่ยวกับโค้ดของคุณ ดังนั้นมันจึงไม่คอมไพล์ซ้ำเช่นกัน เมื่อไม่มีอะไรต้องทำ มันก็จะจบการทำงาน

หากคุณเปิดไฟล์ _src/main.rs_ ทำการเปลี่ยนแปลงเล็กน้อย แล้วบันทึกและ build อีกครั้ง คุณจะเห็นผลลัพธ์เพียงสองบรรทัด:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
```

บรรทัดเหล่านี้แสดงให้เห็นว่า Cargo อัปเดตเฉพาะ build ด้วยการเปลี่ยนแปลงเล็กน้อยของคุณในไฟล์ _src/main.rs_ การพึ่งพาของคุณไม่มีการเปลี่ยนแปลง ดังนั้น Cargo จึงรู้ว่าสามารถนำสิ่งที่ดาวน์โหลดและคอมไพล์ไว้แล้วสำหรับสิ่งเหล่านั้นกลับมาใช้ใหม่ได้

#### การรับประกัน Builds ที่ทำซ้ำได้ด้วยไฟล์ _Cargo.lock_

Cargo มีกลไกที่ช่วยให้มั่นใจได้ว่าคุณสามารถ build artifact เดิมซ้ำได้ทุกครั้งที่คุณหรือใครก็ตาม build โค้ดของคุณ: Cargo จะใช้เฉพาะเวอร์ชันของการพึ่งพาที่คุณระบุไว้จนกว่าคุณจะระบุเป็นอย่างอื่น ตัวอย่างเช่น สมมติว่าสัปดาห์หน้า `rand` crate เวอร์ชัน 0.8.6 ออกมา และเวอร์ชันนั้นมีการแก้ไขข้อบกพร่องที่สำคัญ แต่ก็มี regression ที่จะทำให้โค้ดของคุณเสียหายด้วย เพื่อจัดการกับสิ่งนี้ Rust จะสร้างไฟล์ _Cargo.lock_ ในครั้งแรกที่คุณรัน `cargo build` ดังนั้นตอนนี้เราจึงมีไฟล์นี้ในไดเรกทอรี _guessing_game_

เมื่อคุณ build โปรเจกต์เป็นครั้งแรก Cargo จะค้นหาเวอร์ชันทั้งหมดของการพึ่งพาที่ตรงตามเกณฑ์แล้วเขียนลงในไฟล์ _Cargo.lock_ เมื่อคุณ build โปรเจกต์ของคุณในอนาคต Cargo จะเห็นว่าไฟล์ _Cargo.lock_ มีอยู่และจะใช้เวอร์ชันที่ระบุไว้ที่นั่นแทนที่จะทำงานทั้งหมดเพื่อค้นหาเวอร์ชันอีกครั้ง ซึ่งช่วยให้คุณมี build ที่ทำซ้ำได้โดยอัตโนมัติ กล่าวอีกนัยหนึ่งคือ โปรเจกต์ของคุณจะยังคงอยู่ที่ 0.8.5 จนกว่าคุณจะอัปเกรดอย่างชัดเจน ต้องขอบคุณไฟล์ _Cargo.lock_ เนื่องจากไฟล์ _Cargo.lock_ มีความสำคัญต่อ builds ที่ทำซ้ำได้ จึงมักจะถูก check in เข้าสู่ source control พร้อมกับโค้ดส่วนที่เหลือในโปรเจกต์ของคุณ

#### การอัปเดต Crate เพื่อรับเวอร์ชันใหม่

เมื่อคุณ _ต้องการ_ อัปเดต крейт Cargo มีคำสั่ง `update` ซึ่งจะละเว้นไฟล์ _Cargo.lock_ และค้นหาเวอร์ชันล่าสุดทั้งหมดที่ตรงกับข้อกำหนดของคุณใน _Cargo.toml_ จากนั้น Cargo จะเขียนเวอร์ชันเหล่านั้นลงในไฟล์ _Cargo.lock_ ในกรณีนี้ Cargo จะค้นหาเฉพาะเวอร์ชันที่มากกว่า 0.8.5 และน้อยกว่า 0.9.0 หาก `rand` crate ได้เปิดตัวเวอร์ชันใหม่สองเวอร์ชันคือ 0.8.6 และ 0.9.0 คุณจะเห็นสิ่งต่อไปนี้หากคุณรัน `cargo update`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```console
$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -> v0.8.6 (available: v0.9.0)
```

Cargo ละเว้นรุ่น 0.9.0 ณ จุดนี้ คุณจะสังเกตเห็นการเปลี่ยนแปลงในไฟล์ _Cargo.lock_ ของคุณด้วย โดยระบุว่าเวอร์ชันของ `rand` crate ที่คุณใช้อยู่ตอนนี้คือ 0.8.6 หากต้องการใช้ `rand` เวอร์ชัน 0.9.0 หรือเวอร์ชันใดๆ ในซีรีส์ 0.9._x_ คุณจะต้องอัปเดตไฟล์ _Cargo.toml_ ให้มีลักษณะดังนี้แทน:

```toml
[dependencies]
rand = "0.9.0"
```

ครั้งต่อไปที่คุณรัน `cargo build` Cargo จะอัปเดต registry ของ крейт ที่มีอยู่และประเมินข้อกำหนด `rand` ของคุณใหม่ตามเวอร์ชันใหม่ที่คุณระบุ

ยังมีอะไรอีกมากมายที่จะกล่าวถึง [Cargo][doccargo]<!-- ignore --> และ [ระบบนิเวศของมัน][doccratesio]<!-- ignore --> ซึ่งเราจะพูดถึงในบทที่ 14 แต่สำหรับตอนนี้ นั่นคือทั้งหมดที่คุณต้องรู้ Cargo ทำให้การนำไลบรารีกลับมาใช้ใหม่เป็นเรื่องง่ายมาก ดังนั้น Rustaceans จึงสามารถเขียนโปรเจกต์ขนาดเล็กที่ประกอบขึ้นจากแพ็กเกจจำนวนหนึ่งได้

### การสร้างเลขสุ่ม

มาเริ่มใช้ `rand` เพื่อสร้างตัวเลขให้ทายกัน ขั้นตอนต่อไปคือการอัปเดต _src/main.rs_ ดังที่แสดงใน Listing 2-3

<Listing number="2-3" file-name="src/main.rs" caption="การเพิ่มโค้ดเพื่อสร้างเลขสุ่ม">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}
```

</Listing>

ขั้นแรก เราเพิ่มบรรทัด `use rand::Rng;` เทรต `Rng` กำหนดเมธอดที่เครื่องสร้างเลขสุ่ม υλοποιώ (implement) และเทรตนี้ต้องอยู่ในขอบเขตเพื่อให้เราสามารถใช้เมธอดเหล่านั้นได้ บทที่ 10 จะครอบคลุมเทรตโดยละเอียด

ถัดไป เรากำลังเพิ่มสองบรรทัดตรงกลาง ในบรรทัดแรก เราเรียกฟังก์ชัน `rand::thread_rng` ที่ให้เครื่องสร้างเลขสุ่มเฉพาะที่เราจะใช้: เครื่องที่อยู่เฉพาะเธรดปัจจุบันของการ εκτέλεση (execution) และถูก seed โดยระบบปฏิบัติการ จากนั้นเราเรียกเมธอด `gen_range` บนเครื่องสร้างเลขสุ่ม เมธอดนี้ถูกกำหนดโดยเทรต `Rng` ที่เรานำเข้ามาในขอบเขตด้วยคำสั่ง `use rand::Rng;` เมธอด `gen_range` รับนิพจน์ช่วง (range expression) เป็นอาร์กิวเมนต์และสร้างเลขสุ่มในช่วงนั้น ประเภทของนิพจน์ช่วงที่เราใช้อยู่ที่นี่อยู่ในรูปแบบ `start..=end` และรวมขอบเขตล่างและบน ดังนั้นเราจึงต้องระบุ `1..=100` เพื่อขอตัวเลขระหว่าง 1 ถึง 100

> หมายเหตุ: คุณจะไม่รู้ได้เลยว่าจะใช้เทรตใดและจะเรียกเมธอดและฟังก์ชันใดจาก крейт ดังนั้นแต่ละ крейт จึงมีเอกสารประกอบพร้อมคำแนะนำในการใช้งาน ฟีเจอร์ที่น่าสนใจอีกอย่างของ Cargo คือการรันคำสั่ง `cargo doc --open` จะ build เอกสารประกอบที่จัดทำโดยการพึ่งพาทั้งหมดของคุณในเครื่องและเปิดในเบราว์เซอร์ของคุณ หากคุณสนใจฟังก์ชันการทำงานอื่นๆ ใน `rand` crate เช่น ให้รัน `cargo doc --open` แล้วคลิก `rand` ในแถบด้านข้างทางซ้าย

บรรทัดใหม่ที่สองพิมพ์เลขลับ สิ่งนี้มีประโยชน์ในขณะที่เรากำลังพัฒนาโปรแกรมเพื่อให้สามารถทดสอบได้ แต่เราจะลบออกจากเวอร์ชันสุดท้าย มันคงไม่สนุกเท่าไหร่ถ้าโปรแกรมพิมพ์คำตอบออกมาทันทีที่เริ่ม!

ลองรันโปรแกรมสองสามครั้ง:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

คุณควรจะได้เลขสุ่มที่แตกต่างกัน และทั้งหมดควรเป็นตัวเลขระหว่าง 1 ถึง 100 เยี่ยมมาก!

## การเปรียบเทียบค่าที่ทายกับเลขลับ

ตอนนี้เรามีอินพุตจากผู้ใช้และเลขสุ่มแล้ว เราสามารถเปรียบเทียบมันได้ ขั้นตอนนี้แสดงอยู่ใน Listing 2-4 โปรดทราบว่าโค้ดนี้จะยังไม่คอมไพล์ ดังที่เราจะอธิบาย

<Listing number="2-4" file-name="src/main.rs" caption="การจัดการค่าส่งคืนที่เป็นไปได้ของการเปรียบเทียบตัวเลขสองตัว">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}
```

</Listing>

ขั้นแรก เราเพิ่มคำสั่ง `use` อีกหนึ่งคำสั่ง โดยนำไทป์ชื่อ `std::cmp::Ordering` เข้ามาในขอบเขตจากไลบรารีมาตรฐาน ไทป์ `Ordering` เป็น enum อีกตัวหนึ่งและมี variants คือ `Less`, `Greater` และ `Equal` นี่คือผลลัพธ์สามอย่างที่เป็นไปได้เมื่อคุณเปรียบเทียบสองค่า

จากนั้นเราเพิ่มห้าบรรทัดใหม่ที่ด้านล่างซึ่งใช้ไทป์ `Ordering` เมธอด `cmp` เปรียบเทียบสองค่าและสามารถเรียกใช้กับอะไรก็ได้ที่สามารถเปรียบเทียบได้ มันรับ reference ไปยังสิ่งที่คุณต้องการเปรียบเทียบด้วย: ในที่นี้มันกำลังเปรียบเทียบ `guess` กับ `secret_number` จากนั้นมันจะคืนค่า variant ของ enum `Ordering` ที่เรานำเข้ามาในขอบเขตด้วยคำสั่ง `use` เราใช้นิพจน์ [`match`][match]<!-- ignore --> เพื่อตัดสินใจว่าจะทำอะไรต่อไปโดยพิจารณาจาก variant ของ `Ordering` ที่คืนค่ามาจากการเรียก `cmp` ด้วยค่าใน `guess` และ `secret_number`

นิพจน์ `match` ประกอบด้วย _arms_ (แขนง) arm ประกอบด้วย _pattern_ (รูปแบบ) ที่จะจับคู่ และโค้ดที่ควรจะรันหากค่าที่ให้มากับ `match` ตรงกับ pattern ของ arm นั้น Rust นำค่าที่ให้มากับ `match` และดู pattern ของแต่ละ arm ตามลำดับ Patterns และโครงสร้าง `match` เป็นฟีเจอร์ที่ทรงพลังของ Rust: มันช่วยให้คุณแสดงสถานการณ์ที่หลากหลายที่โค้ดของคุณอาจพบเจอและทำให้แน่ใจว่าคุณจัดการกับมันทั้งหมด ฟีเจอร์เหล่านี้จะครอบคลุมโดยละเอียดในบทที่ 6 และบทที่ 19 ตามลำดับ

เรามาดูตัวอย่างการใช้นิพจน์ `match` ที่เราใช้ที่นี่ สมมติว่าผู้ใช้ทาย 50 และเลขลับที่สร้างแบบสุ่มในครั้งนี้คือ 38

เมื่อโค้ดเปรียบเทียบ 50 กับ 38 เมธอด `cmp` จะคืนค่า `Ordering::Greater` เพราะ 50 มากกว่า 38 นิพจน์ `match` จะได้รับค่า `Ordering::Greater` และเริ่มตรวจสอบ pattern ของแต่ละ arm มันดู pattern ของ arm แรก `Ordering::Less` และเห็นว่าค่า `Ordering::Greater` ไม่ตรงกับ `Ordering::Less` ดังนั้นมันจึงละเว้นโค้ดใน arm นั้นและไปยัง arm ถัดไป pattern ของ arm ถัดไปคือ `Ordering::Greater` ซึ่ง _ตรงกับ_ `Ordering::Greater`! โค้ดที่เกี่ยวข้องใน arm นั้นจะ εκτελέσιμο (execute) และพิมพ์ `Too big!` ออกทางหน้าจอ นิพจน์ `match` จะสิ้นสุดหลังจากการจับคู่ที่สำเร็จครั้งแรก ดังนั้นมันจะไม่ดู arm สุดท้ายในสถานการณ์นี้

อย่างไรก็ตาม โค้ดใน Listing 2-4 จะยังไม่คอมไพล์ ลองดูกัน:

<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->

```console
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
```

แกนหลักของข้อผิดพลาดระบุว่ามี _ไทป์ที่ไม่ตรงกัน_ (mismatched types) Rust มีระบบไทป์ที่เข้มงวดและเป็นแบบ static อย่างไรก็ตาม มันก็มีการอนุมานไทป์ (type inference) ด้วย เมื่อเราเขียน `let mut guess = String::new()` Rust สามารถอนุมานได้ว่า `guess` ควรจะเป็น `String` และไม่ได้บังคับให้เราเขียนไทป์ ในทางกลับกัน `secret_number` เป็นไทป์ตัวเลข ไทป์ตัวเลขของ Rust สองสามไทป์สามารถมีค่าระหว่าง 1 ถึง 100 ได้: `i32` ตัวเลข 32 บิต; `u32` ตัวเลข 32 บิตแบบไม่มีเครื่องหมาย; `i64` ตัวเลข 64 บิต; และอื่นๆ หากไม่ได้ระบุเป็นอย่างอื่น Rust จะใช้ `i32` เป็นค่าเริ่มต้น ซึ่งเป็นไทป์ของ `secret_number` เว้นแต่คุณจะเพิ่มข้อมูลไทป์ที่อื่นที่จะทำให้ Rust อนุมานไทป์ตัวเลขที่แตกต่างออกไป เหตุผลของข้อผิดพลาดคือ Rust ไม่สามารถเปรียบเทียบสตริงกับไทป์ตัวเลขได้

ท้ายที่สุดแล้ว เราต้องการแปลง `String` ที่โปรแกรมอ่านเป็นอินพุตให้เป็นไทป์ตัวเลขเพื่อให้เราสามารถเปรียบเทียบกับเลขลับในเชิงตัวเลขได้ เราทำได้โดยเพิ่มบรรทัดนี้เข้าไปในเนื้อหาของฟังก์ชัน `main`:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}
```

บรรทัดนั้นคือ:

```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

เราสร้างตัวแปรชื่อ `guess` แต่เดี๋ยวก่อน โปรแกรมมีตัวแปรชื่อ `guess` อยู่แล้วไม่ใช่หรือ? ใช่แล้ว แต่ Rust ช่วยให้เราสามารถ _shadow_ (บดบัง) ค่าก่อนหน้าของ `guess` ด้วยค่าใหม่ได้ _Shadowing_ ช่วยให้เราใช้ชื่อตัวแปร `guess` ซ้ำได้ แทนที่จะบังคับให้เราสร้างตัวแปรที่ไม่ซ้ำกันสองตัว เช่น `guess_str` และ `guess` เป็นต้น เราจะครอบคลุมเรื่องนี้ในรายละเอียดเพิ่มเติมใน [บทที่ 3][shadowing]<!-- ignore --> แต่สำหรับตอนนี้ โปรดทราบว่าฟีเจอร์นี้มักใช้เมื่อคุณต้องการแปลงค่าจากไทป์หนึ่งไปยังอีกไทป์หนึ่ง

เราผูกตัวแปรใหม่นี้เข้ากับนิพจน์ `guess.trim().parse()` `guess` ในนิพจน์หมายถึงตัวแปร `guess` ดั้งเดิมที่มีอินพุตเป็นสตริง เมธอด `trim` บนอินสแตนซ์ `String` จะกำจัดช่องว่างใดๆ ที่จุดเริ่มต้นและจุดสิ้นสุด ซึ่งเราต้องทำก่อนที่เราจะสามารถแปลงสตริงเป็น `u32` ซึ่งสามารถมีได้เฉพาะข้อมูลตัวเลขเท่านั้น ผู้ใช้ต้องกด <kbd>enter</kbd> เพื่อให้ `read_line` พอใจและป้อนค่าที่ทาย ซึ่งจะเพิ่มอักขระขึ้นบรรทัดใหม่ (newline character) เข้าไปในสตริง ตัวอย่างเช่น หากผู้ใช้พิมพ์ <kbd>5</kbd> แล้วกด <kbd>enter</kbd> `guess` จะมีลักษณะดังนี้: `5\n` `\n` แทน “newline” (บน Windows การกด <kbd>enter</kbd> จะส่งผลให้เกิด carriage return และ newline, `\r\n`) เมธอด `trim` จะกำจัด `\n` หรือ `\r\n` ทำให้เหลือเพียง `5`

เมธอด [`parse` บนสตริง][parse]<!-- ignore --> แปลงสตริงเป็นไทป์อื่น ที่นี่เราใช้มันเพื่อแปลงจากสตริงเป็นตัวเลข เราจำเป็นต้องบอก Rust ถึงไทป์ตัวเลขที่แน่นอนที่เราต้องการโดยใช้ `let guess: u32` เครื่องหมายโคลอน (`:`) หลัง `guess` บอก Rust ว่าเราจะใส่คำอธิบายประกอบไทป์ของตัวแปร Rust มีไทป์ตัวเลขในตัวสองสามไทป์ `u32` ที่เห็นที่นี่คือจำนวนเต็ม 32 บิตแบบไม่มีเครื่องหมาย เป็นตัวเลือกเริ่มต้นที่ดีสำหรับจำนวนบวกขนาดเล็ก คุณจะได้เรียนรู้เกี่ยวกับไทป์ตัวเลขอื่นๆ ใน [บทที่ 3][integers]<!-- ignore -->

นอกจากนี้ คำอธิบายประกอบ `u32` ในโปรแกรมตัวอย่างนี้และการเปรียบเทียบกับ `secret_number` หมายความว่า Rust จะอนุมานว่า `secret_number` ควรจะเป็น `u32` ด้วยเช่นกัน ดังนั้นตอนนี้การเปรียบเทียบจะเป็นระหว่างสองค่าที่มีไทป์เดียวกัน!

เมธอด `parse` จะทำงานได้เฉพาะกับอักขระที่สามารถแปลงเป็นตัวเลขได้อย่างสมเหตุสมผลเท่านั้น ดังนั้นจึงสามารถทำให้เกิดข้อผิดพลาดได้ง่าย หากสตริงมี `A👍%` เป็นต้น จะไม่มีทางแปลงเป็นตัวเลขได้ เนื่องจากอาจล้มเหลว เมธอด `parse` จึงคืนค่าไทป์ `Result` เช่นเดียวกับเมธอด `read_line` (ที่กล่าวถึงก่อนหน้านี้ใน [“การจัดการความล้มเหลวที่อาจเกิดขึ้นด้วย `Result`”](#handling-potential-failure-with-result)<!-- ignore-->) เราจะจัดการกับ `Result` นี้ในลักษณะเดียวกันโดยใช้เมธอด `expect` อีกครั้ง หาก `parse` คืนค่า `Err` `Result` variant เนื่องจากไม่สามารถสร้างตัวเลขจากสตริงได้ การเรียก `expect` จะทำให้เกมหยุดทำงานและพิมพ์ข้อความที่เราให้ไว้ หาก `parse` สามารถแปลงสตริงเป็นตัวเลขได้สำเร็จ มันจะคืนค่า `Ok` variant ของ `Result` และ `expect` จะคืนค่าตัวเลขที่เราต้องการจากค่า `Ok` นั้น

มาลองรันโปรแกรมกันตอนนี้:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

เยี่ยม! แม้ว่าจะมีการเพิ่มช่องว่างก่อนค่าที่ทาย โปรแกรมก็ยังคงคิดออกว่าผู้ใช้ทาย 76 ลองรันโปรแกรมสองสามครั้งเพื่อตรวจสอบพฤติกรรมที่แตกต่างกันด้วยอินพุตประเภทต่างๆ: ทายตัวเลขให้ถูกต้อง ทายตัวเลขที่สูงเกินไป และทายตัวเลขที่ต่ำเกินไป

ตอนนี้เรามีเกมส่วนใหญ่ทำงานได้แล้ว แต่ผู้ใช้สามารถทายได้เพียงครั้งเดียว มาเปลี่ยนสิ่งนั้นด้วยการเพิ่มลูปกันเถอะ!

## การอนุญาตให้ทายหลายครั้งด้วยการวนซ้ำ (Looping)

keyword `loop` สร้างลูปที่ไม่สิ้นสุด เราจะเพิ่มลูปเพื่อให้ผู้ใช้มีโอกาสทายตัวเลขมากขึ้น:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}
```

ดังที่คุณเห็น เราได้ย้ายทุกอย่างตั้งแต่พรอมต์อินพุตการทายเป็นต้นไปเข้าไปในลูป อย่าลืมเยื้องบรรทัดภายในลูปเข้าไปอีกสี่ช่องว่างแต่ละบรรทัดแล้วรันโปรแกรมอีกครั้ง โปรแกรมจะขอให้ทายอีกครั้งไปเรื่อยๆ ซึ่งจริงๆ แล้วเป็นการสร้างปัญหาใหม่ ดูเหมือนว่าผู้ใช้จะไม่สามารถออกได้!

ผู้ใช้สามารถขัดจังหวะโปรแกรมได้เสมอโดยใช้คีย์ลัด <kbd>ctrl</kbd>-<kbd>c</kbd> แต่มีอีกวิธีหนึ่งในการหลบหนีจากสัตว์ประหลาดที่ไม่รู้จักพอตัวนี้ ดังที่กล่าวไว้ในการอภิปรายเรื่อง `parse` ใน [“การเปรียบเทียบค่าที่ทายกับเลขลับ”](#comparing-the-guess-to-the-secret-number)<!-- ignore -->: หากผู้ใช้ป้อนคำตอบที่ไม่ใช่ตัวเลข โปรแกรมจะหยุดทำงาน เราสามารถใช้ประโยชน์จากสิ่งนั้นเพื่อให้ผู้ใช้สามารถออกได้ ดังที่แสดงไว้ที่นี่:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

การพิมพ์ `quit` จะเป็นการออกจากเกม แต่ดังที่คุณจะสังเกตเห็น การป้อนอินพุตที่ไม่ใช่ตัวเลขอื่นๆ ก็จะทำเช่นเดียวกัน นี่เป็นสิ่งที่ไม่เหมาะสมอย่างยิ่ง เราต้องการให้เกมหยุดทำงานเมื่อทายตัวเลขถูกต้องด้วย

### การออกหลังจากทายถูก

มาเขียนโปรแกรมให้เกมออกเมื่อผู้ใช้ชนะโดยเพิ่มคำสั่ง `break`:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}
```

การเพิ่มบรรทัด `break` หลัง `You win!` ทำให้โปรแกรมออกจากลูปเมื่อผู้ใช้ทายเลขลับถูกต้อง การออกจากลูปยังหมายถึงการออกจากโปรแกรมด้วย เนื่องจากลูปเป็นส่วนสุดท้ายของ `main`

### การจัดการอินพุตที่ไม่ถูกต้อง

เพื่อปรับปรุงพฤติกรรมของเกมให้ดียิ่งขึ้น แทนที่จะทำให้โปรแกรมหยุดทำงานเมื่อผู้ใช้ป้อนข้อมูลที่ไม่ใช่ตัวเลข เรามาทำให้เกมละเว้นข้อมูลที่ไม่ใช่ตัวเลขเพื่อให้ผู้ใช้สามารถทายต่อไปได้ เราสามารถทำได้โดยแก้ไขบรรทัดที่ `guess` ถูกแปลงจาก `String` เป็น `u32` ดังที่แสดงใน Listing 2-5

<Listing number="2-5" file-name="src/main.rs" caption="การละเว้นค่าทายที่ไม่ใช่ตัวเลขและขอให้ทายอีกครั้งแทนที่จะทำให้โปรแกรมหยุดทำงาน">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}
```

</Listing>

เราเปลี่ยนจากการเรียก `expect` เป็นนิพจน์ `match` เพื่อเปลี่ยนจากการหยุดทำงานเมื่อเกิดข้อผิดพลาดเป็นการจัดการข้อผิดพลาด จำไว้ว่า `parse` คืนค่าไทป์ `Result` และ `Result` เป็น enum ที่มี variants คือ `Ok` และ `Err` เรากำลังใช้นิพจน์ `match` ที่นี่ เช่นเดียวกับที่เราทำกับผลลัพธ์ `Ordering` ของเมธอด `cmp`

หาก `parse` สามารถแปลงสตริงเป็นตัวเลขได้สำเร็จ มันจะคืนค่า `Ok` ที่มีตัวเลขผลลัพธ์อยู่ ค่า `Ok` นั้นจะตรงกับ pattern ของ arm แรก และนิพจน์ `match` จะคืนค่า `num` ที่ `parse` สร้างขึ้นและใส่ไว้ในค่า `Ok` ตัวเลขนั้นจะไปอยู่ในตำแหน่งที่เราต้องการในตัวแปร `guess` ใหม่ที่เรากำลังสร้าง

หาก `parse` _ไม่_ สามารถแปลงสตริงเป็นตัวเลขได้ มันจะคืนค่า `Err` ที่มีข้อมูลเพิ่มเติมเกี่ยวกับข้อผิดพลาด ค่า `Err` ไม่ตรงกับ pattern `Ok(num)` ใน arm แรกของ `match` แต่มันตรงกับ pattern `Err(_)` ใน arm ที่สอง เครื่องหมายอันเดอร์สกอร์ `_` เป็นค่าที่จับคู่ได้ทั้งหมด ในตัวอย่างนี้ เรากำลังบอกว่าเราต้องการจับคู่ค่า `Err` ทั้งหมด ไม่ว่าจะมีข้อมูลอะไรอยู่ข้างในก็ตาม ดังนั้นโปรแกรมจะ εκτελέσιμο (execute) โค้ดของ arm ที่สอง `continue` ซึ่งบอกโปรแกรมให้ไปยังรอบถัดไปของ `loop` และขอให้ทายอีกครั้ง ดังนั้น โดยสรุปแล้ว โปรแกรมจะละเว้นข้อผิดพลาดทั้งหมดที่ `parse` อาจพบเจอ!

ตอนนี้ทุกอย่างในโปรแกรมควรทำงานตามที่คาดไว้ มาลองดูกัน:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

ยอดเยี่ยม! ด้วยการปรับแต่งเล็กน้อยครั้งสุดท้าย เราจะทำเกมทายตัวเลขให้เสร็จสมบูรณ์ จำได้ไหมว่าโปรแกรมยังคงพิมพ์เลขลับอยู่ นั่นทำงานได้ดีสำหรับการทดสอบ แต่มันทำให้เกมเสียไป มาลบ `println!` ที่แสดงเลขลับออกกัน Listing 2-6 แสดงโค้ดสุดท้าย

<Listing number="2-6" file-name="src/main.rs" caption="โค้ดเกมทายตัวเลขฉบับสมบูรณ์">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}
```

</Listing>

ณ จุดนี้ คุณได้สร้างเกมทายตัวเลขสำเร็จแล้ว ขอแสดงความยินดี!

## สรุป

โปรเจกต์นี้เป็นวิธีการลงมือปฏิบัติจริงเพื่อแนะนำแนวคิดใหม่ๆ ของ Rust มากมายให้คุณ: `let`, `match`, ฟังก์ชัน, การใช้ крейт ภายนอก และอื่นๆ อีกมากมาย ในบทต่อๆ ไป คุณจะได้เรียนรู้เกี่ยวกับแนวคิดเหล่านี้ในรายละเอียดเพิ่มเติม บทที่ 3 ครอบคลุมแนวคิดที่ภาษาโปรแกรมส่วนใหญ่มี เช่น ตัวแปร, ชนิดข้อมูล และฟังก์ชัน และแสดงวิธีการใช้งานใน Rust บทที่ 4 สำรวจ ownership ซึ่งเป็นฟีเจอร์ที่ทำให้ Rust แตกต่างจากภาษาอื่น บทที่ 5 พูดถึง structs และ синтаксис เมธอด และบทที่ 6 อธิบายวิธีการทำงานของ enums

[prelude]: ../std/prelude/index.html
[variables-and-mutability]: ch03-01-variables-and-mutability.html#variables-and-mutability
[comments]: ch03-04-comments.html
[string]: ../std/string/struct.String.html
[iostdin]: ../std/io/struct.Stdin.html
[read_line]: ../std/io/struct.Stdin.html#method.read_line
[result]: ../std/result/enum.Result.html
[enums]: ch06-00-enums.html
[expect]: ../std/result/enum.Result.html#method.expect
[recover]: ch09-02-recoverable-errors-with-result.html
[randcrate]: https://crates.io/crates/rand
[semver]: http://semver.org
[cratesio]: https://crates.io/
[doccargo]: https://doc.rust-lang.org/cargo/
[doccratesio]: https://doc.rust-lang.org/cargo/reference/publishing.html
[match]: ch06-02-match.html
[shadowing]: ch03-01-variables-and-mutability.html#shadowing
[parse]: ../std/primitive.str.html#method.parse
[integers]: ch03-02-data-types.html#integer-types
