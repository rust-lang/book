# المؤشرات الذكية

المؤشر (pointer) هو مفهوم عام لمتغير يحتوي على عنوان في الذاكرة. هذا العنوان يشير إلى، أو "يؤشر على" بيانات أخرى. النوع الأكثر شيوعًا من المؤشرات في Rust هو المرجع (reference)، والذي تعلمته في الفصل 4. تُشار إلى المراجع بالرمز `&` وتستعير القيمة التي تشير إليها. لا تمتلك أي قدرات خاصة غير الإشارة إلى البيانات، وليس لها أي عبء إضافي.

من ناحية أخرى، _المؤشرات الذكية_ (Smart pointers) هي هياكل بيانات تتصرف كمؤشر ولكن لديها أيضًا بيانات وصفية (metadata) وقدرات إضافية. مفهوم المؤشرات الذكية ليس فريدًا لـ Rust: نشأت المؤشرات الذكية في C++ وموجودة في لغات أخرى أيضًا. لدى Rust مجموعة متنوعة من المؤشرات الذكية المعرّفة في المكتبة القياسية التي توفر وظائف تتجاوز تلك التي توفرها المراجع. لاستكشاف المفهوم العام، سننظر في زوجين من الأمثلة المختلفة للمؤشرات الذكية، بما في ذلك نوع المؤشر الذكي _لعد المراجع_ (reference counting). يتيح لك هذا المؤشر السماح للبيانات بأن يكون لها مالكين متعددين من خلال تتبع عدد المالكين، وعندما لا يبقى أي مالكين، يتم تنظيف البيانات.

في Rust، مع مفهوم الملكية (ownership) والاستعارة (borrowing)، هناك اختلاف إضافي بين المراجع والمؤشرات الذكية: بينما المراجع تستعير البيانات فقط، في كثير من الحالات المؤشرات الذكية _تمتلك_ البيانات التي تشير إليها.

عادةً ما يتم تنفيذ المؤشرات الذكية باستخدام structs. على عكس struct عادي، تنفذ المؤشرات الذكية سِمات `Deref` و `Drop`. سِمة `Deref` تسمح لنسخة من struct المؤشر الذكي بالتصرف كمرجع حتى تتمكن من كتابة الكود الخاص بك للعمل مع المراجع أو المؤشرات الذكية. سِمة `Drop` تسمح لك بتخصيص الكود الذي يتم تشغيله عندما تخرج نسخة من المؤشر الذكي عن النطاق. في هذا الفصل، سنناقش كلتا هاتين السمتين ونوضح لماذا هما مهمتان للمؤشرات الذكية.

نظرًا لأن نمط المؤشر الذكي هو نمط تصميم عام يستخدم بشكل متكرر في Rust، فلن يغطي هذا الفصل كل المؤشرات الذكية الموجودة. العديد من المكتبات لديها مؤشراتها الذكية الخاصة، ويمكنك حتى كتابة مؤشراتك الذكية الخاصة. سنغطي المؤشرات الذكية الأكثر شيوعًا في المكتبة القياسية:

- `Box<T>`، لتخصيص القيم على الكومة (heap)
- `Rc<T>`، نوع عد المراجع الذي يتيح الملكية المتعددة
- `Ref<T>` و `RefMut<T>`، يتم الوصول إليها من خلال `RefCell<T>`، وهو نوع يفرض قواعد الاستعارة في وقت التشغيل بدلاً من وقت الترجمة

بالإضافة إلى ذلك، سنغطي نمط _القابلية للتغيير الداخلية_ (interior mutability) حيث يعرض نوع غير قابل للتغيير واجهة برمجية (API) لتغيير قيمة داخلية. سنناقش أيضًا دورات المراجع (reference cycles): كيف يمكن أن تتسبب في تسرب الذاكرة وكيفية منعها.

لنبدأ!
