## `RefCell<T>` ونمط القابلية للتغيير الداخلية

_القابلية للتغيير الداخلية_ (Interior mutability) هي نمط تصميم في Rust يسمح لك بتغيير البيانات حتى عندما تكون هناك مراجع غير قابلة للتغيير لتلك البيانات؛ عادةً، هذا الإجراء ممنوع بموجب قواعد الاستعارة. لتغيير البيانات، يستخدم النمط كود `unsafe` داخل هيكل بيانات لثني قواعد Rust المعتادة التي تحكم التغيير والاستعارة. يشير الكود غير الآمن (Unsafe code) للمترجم أننا نفحص القواعد يدويًا بدلاً من الاعتماد على المترجم للتحقق منها لنا؛ سنناقش الكود غير الآمن بمزيد من التفصيل في الفصل 20.

يمكننا استخدام الأنواع التي تستخدم نمط القابلية للتغيير الداخلية فقط عندما يمكننا ضمان اتباع قواعد الاستعارة في وقت التشغيل، حتى لو لم يتمكن المترجم من ضمان ذلك. يتم بعد ذلك تضمين الكود `unsafe` المعني في واجهة برمجية آمنة (safe API)، والنوع الخارجي لا يزال غير قابل للتغيير.

دعنا نستكشف هذا المفهوم من خلال النظر في نوع `RefCell<T>` الذي يتبع نمط القابلية للتغيير الداخلية.

<!-- Old headings. Do not remove or links may break. -->

<a id="enforcing-borrowing-rules-at-runtime-with-refcellt"></a>

### فرض قواعد الاستعارة في وقت التشغيل

على عكس `Rc<T>`، يمثل نوع `RefCell<T>` ملكية واحدة على البيانات التي يحتفظ بها. إذن، ما الذي يجعل `RefCell<T>` مختلفًا عن نوع مثل `Box<T>`؟ تذكر قواعد الاستعارة التي تعلمتها في الفصل 4:

- في أي وقت معين، يمكن أن يكون لديك _إما_ مرجع قابل للتغيير واحد أو أي عدد من المراجع غير القابلة للتغيير (ولكن ليس كلاهما).
- يجب أن تكون المراجع دائمًا صالحة.

مع المراجع و `Box<T>`، يتم فرض ثوابت قواعد الاستعارة في وقت الترجمة. مع `RefCell<T>`، يتم فرض هذه الثوابت _في وقت التشغيل_. مع المراجع، إذا كسرت هذه القواعد، ستحصل على خطأ مترجم. مع `RefCell<T>`، إذا كسرت هذه القواعد، سينهار برنامجك (panic) ويخرج.

مزايا التحقق من قواعد الاستعارة في وقت الترجمة هي أن الأخطاء سيتم اكتشافها في وقت مبكر من عملية التطوير، وليس هناك تأثير على أداء وقت التشغيل لأن جميع التحليلات تكتمل مسبقًا. لهذه الأسباب، التحقق من قواعد الاستعارة في وقت الترجمة هو الخيار الأفضل في غالبية الحالات، وهذا هو سبب كون هذا هو الافتراضي في Rust.

ميزة التحقق من قواعد الاستعارة في وقت التشغيل بدلاً من ذلك هي أنه يُسمح بعد ذلك ببعض السيناريوهات الآمنة للذاكرة، حيث كانت ستُمنع بواسطة الفحوصات في وقت الترجمة. التحليل الثابت (Static analysis)، مثل مترجم Rust، متحفظ بطبيعته. بعض خصائص الكود من المستحيل اكتشافها عن طريق تحليل الكود: المثال الأكثر شهرة هو مشكلة التوقف (Halting Problem)، والتي تتجاوز نطاق هذا الكتاب ولكنها موضوع مثير للاهتمام للبحث.

لأن بعض التحليلات مستحيلة، إذا لم يتمكن مترجم Rust من التأكد من امتثال الكود لقواعد الملكية، فقد يرفض برنامجًا صحيحًا؛ بهذه الطريقة، يكون متحفظًا. إذا قبلت Rust برنامجًا غير صحيح، لن يتمكن المستخدمون من الوثوق بالضمانات التي تقدمها Rust. ومع ذلك، إذا رفضت Rust برنامجًا صحيحًا، سيُزعج المبرمج، لكن لا يمكن أن يحدث شيء كارثي. نوع `RefCell<T>` مفيد عندما تكون متأكدًا من أن كودك يتبع قواعد الاستعارة لكن المترجم غير قادر على الفهم والضمان.

مثل `Rc<T>`، `RefCell<T>` مخصص للاستخدام فقط في سيناريوهات أحادية الخيط وسيعطيك خطأ وقت ترجمة إذا حاولت استخدامه في سياق متعدد الخيوط. سنتحدث عن كيفية الحصول على وظائف `RefCell<T>` في برنامج متعدد الخيوط في الفصل 16.

إليك ملخص للأسباب لاختيار `Box<T>` أو `Rc<T>` أو `RefCell<T>`:

- `Rc<T>` يتيح مالكين متعددين لنفس البيانات؛ `Box<T>` و `RefCell<T>` لديهما مالكين فرديين.
- `Box<T>` يسمح باستعارات غير قابلة للتغيير أو قابلة للتغيير يتم فحصها في وقت الترجمة؛ `Rc<T>` يسمح فقط باستعارات غير قابلة للتغيير يتم فحصها في وقت الترجمة؛ `RefCell<T>` يسمح باستعارات غير قابلة للتغيير أو قابلة للتغيير يتم فحصها في وقت التشغيل.
- لأن `RefCell<T>` يسمح باستعارات قابلة للتغيير يتم فحصها في وقت التشغيل، يمكنك تغيير القيمة داخل `RefCell<T>` حتى عندما يكون `RefCell<T>` غير قابل للتغيير.

تغيير القيمة داخل قيمة غير قابلة للتغيير هو نمط القابلية للتغيير الداخلية. دعنا ننظر في موقف يكون فيه القابلية للتغيير الداخلية مفيدة ونفحص كيف يكون ذلك ممكنًا.

<!-- Old headings. Do not remove or links may break. -->

<a id="interior-mutability-a-mutable-borrow-to-an-immutable-value"></a>

### استخدام القابلية للتغيير الداخلية

نتيجة لقواعد الاستعارة هي أنه عندما يكون لديك قيمة غير قابلة للتغيير، لا يمكنك استعارتها بشكل قابل للتغيير. على سبيل المثال، هذا الكود لن يُترجم:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}
```

إذا حاولت ترجمة هذا الكود، ستحصل على الخطأ التالي:

```console
{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}
```

ومع ذلك، هناك مواقف يكون فيها من المفيد لقيمة أن تغير نفسها في وسائلها ولكن تبدو غير قابلة للتغيير للكود الآخر. لن يتمكن الكود خارج وسائل القيمة من تغيير القيمة. استخدام `RefCell<T>` هو إحدى الطرق للحصول على القدرة على الحصول على قابلية للتغيير الداخلية، لكن `RefCell<T>` لا يتجاوز قواعد الاستعارة بالكامل: فاحص الاستعارة (borrow checker) في المترجم يسمح بهذه القابلية للتغيير الداخلية، ويتم فحص قواعد الاستعارة في وقت التشغيل بدلاً من ذلك. إذا انتهكت القواعد، ستحصل على `panic!` بدلاً من خطأ مترجم.

دعنا نعمل من خلال مثال عملي حيث يمكننا استخدام `RefCell<T>` لتغيير قيمة غير قابلة للتغيير ونرى لماذا يكون ذلك مفيدًا.

<!-- Old headings. Do not remove or links may break. -->

<a id="a-use-case-for-interior-mutability-mock-objects"></a>

#### الاختبار باستخدام الكائنات الوهمية

أحيانًا خلال الاختبار سيستخدم المبرمج نوعًا بدلاً من نوع آخر، من أجل مراقبة سلوك معين والتأكد من أنه منفذ بشكل صحيح. يسمى هذا النوع البديل _اختبار مزدوج_ (test double). فكر فيه بمعنى بديل الحركات الخطرة (stunt double) في صناعة الأفلام، حيث يتدخل شخص ويستبدل ممثلاً للقيام بمشهد صعب بشكل خاص. تقف البدائل الاختبارية بدلاً من الأنواع الأخرى عندما نقوم بتشغيل الاختبارات. _الكائنات الوهمية_ (Mock objects) هي أنواع محددة من البدائل الاختبارية التي تسجل ما يحدث خلال اختبار بحيث يمكنك التأكد من حدوث الإجراءات الصحيحة.

ليس لدى Rust كائنات بنفس المعنى الذي تمتلكه اللغات الأخرى للكائنات، وليس لدى Rust وظيفة كائن وهمي مدمجة في المكتبة القياسية كما تفعل بعض اللغات الأخرى. ومع ذلك، يمكنك بالتأكيد إنشاء struct سيخدم نفس أغراض الكائن الوهمي.

هذا هو السيناريو الذي سنختبره: سننشئ مكتبة تتتبع قيمة مقابل قيمة قصوى وترسل رسائل بناءً على مدى قرب القيمة الحالية من القيمة القصوى. يمكن استخدام هذه المكتبة لتتبع حصة المستخدم لعدد استدعاءات API المسموح لهم بإجرائها، على سبيل المثال.

ستوفر مكتبتنا فقط وظيفة تتبع مدى قرب القيمة من القيمة القصوى وما يجب أن تكون الرسائل في أي أوقات. من المتوقع أن توفر التطبيقات التي تستخدم مكتبتنا الآلية لإرسال الرسائل: يمكن للتطبيق إظهار الرسالة للمستخدم مباشرة، أو إرسال بريد إلكتروني، أو إرسال رسالة نصية، أو القيام بشيء آخر. لا تحتاج المكتبة لمعرفة هذا التفصيل. كل ما تحتاجه هو شيء ينفذ سِمة سنوفرها، تسمى `Messenger`. توضح القائمة 15-20 كود المكتبة.

<Listing number="15-20" file-name="src/lib.rs" caption="مكتبة لتتبع مدى قرب القيمة من قيمة قصوى والتحذير عندما تكون القيمة عند مستويات معينة">

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}
```

</Listing>

جزء مهم من هذا الكود هو أن سِمة `Messenger` لديها وسيلة واحدة تسمى `send` تأخذ مرجعًا غير قابل للتغيير إلى `self` ونص الرسالة. هذه السِمة هي الواجهة التي يحتاج كائننا الوهمي لتنفيذها بحيث يمكن استخدام الوهمي بنفس الطريقة التي يُستخدم بها الكائن الحقيقي. الجزء المهم الآخر هو أننا نريد اختبار سلوك وسيلة `set_value` على `LimitTracker`. يمكننا تغيير ما نمرره لمعامل `value`، لكن `set_value` لا تعيد شيئًا لنا لإجراء تأكيدات عليه. نريد أن نكون قادرين على القول أنه إذا أنشأنا `LimitTracker` مع شيء ينفذ سِمة `Messenger` وقيمة معينة لـ `max`، يُخبر المرسل بإرسال الرسائل المناسبة عندما نمرر أرقامًا مختلفة لـ `value`.

نحتاج إلى كائن وهمي، بدلاً من إرسال بريد إلكتروني أو رسالة نصية عندما نستدعي `send`، سيتتبع فقط الرسائل التي يُطلب منه إرسالها. يمكننا إنشاء نسخة جديدة من الكائن الوهمي، وإنشاء `LimitTracker` يستخدم الكائن الوهمي، واستدعاء وسيلة `set_value` على `LimitTracker`، ثم التحقق من أن الكائن الوهمي لديه الرسائل التي نتوقعها. توضح القائمة 15-21 محاولة لتنفيذ كائن وهمي للقيام بذلك فقط، لكن فاحص الاستعارة لن يسمح به.

<Listing number="15-21" file-name="src/lib.rs" caption="محاولة لتنفيذ `MockMessenger` غير مسموح به من قبل فاحص الاستعارة">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}
```

</Listing>

يعرّف كود الاختبار هذا struct `MockMessenger` الذي لديه حقل `sent_messages` مع `Vec` من قيم `String` لتتبع الرسائل التي يُطلب منه إرسالها. نعرّف أيضًا دالة مرتبطة `new` لجعل إنشاء قيم `MockMessenger` جديدة تبدأ بقائمة رسائل فارغة مريحًا. ثم ننفذ سِمة `Messenger` لـ `MockMessenger` بحيث يمكننا إعطاء `MockMessenger` إلى `LimitTracker`. في تعريف وسيلة `send`، نأخذ الرسالة الممررة كمعامل ونخزنها في قائمة `MockMessenger` من `sent_messages`.

في الاختبار، نختبر ما يحدث عندما يُخبر `LimitTracker` بتعيين `value` إلى شيء يزيد عن 75 بالمائة من قيمة `max`. أولاً، ننشئ `MockMessenger` جديد، والذي سيبدأ بقائمة رسائل فارغة. بعد ذلك، ننشئ `LimitTracker` جديد ونعطيه مرجعًا إلى `MockMessenger` الجديد وقيمة `max` من `100`. نستدعي وسيلة `set_value` على `LimitTracker` بقيمة `80`، وهي أكثر من 75 بالمائة من 100. بعد ذلك، نؤكد أن قائمة الرسائل التي يتتبعها `MockMessenger` يجب أن يكون لديها الآن رسالة واحدة فيها.

ومع ذلك، هناك مشكلة واحدة مع هذا الاختبار، كما هو موضح هنا:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}
```

لا يمكننا تعديل `MockMessenger` لتتبع الرسائل، لأن وسيلة `send` تأخذ مرجعًا غير قابل للتغيير إلى `self`. كما لا يمكننا أخذ الاقتراح من نص الخطأ لاستخدام `&mut self` في كل من وسيلة `impl` وتعريف السِمة. نحن لا نريد تغيير سِمة `Messenger` فقط من أجل الاختبار. بدلاً من ذلك، نحتاج إلى إيجاد طريقة لجعل كود الاختبار الخاص بنا يعمل بشكل صحيح مع تصميمنا الحالي.

هذا موقف يمكن أن تساعد فيه القابلية للتغيير الداخلية! سنخزن `sent_messages` داخل `RefCell<T>`، وبعد ذلك ستتمكن وسيلة `send` من تعديل `sent_messages` لتخزين الرسائل التي رأيناها. توضح القائمة 15-22 كيف يبدو ذلك.

<Listing number="15-22" file-name="src/lib.rs" caption="استخدام `RefCell<T>` لتغيير قيمة داخلية بينما تُعتبر القيمة الخارجية غير قابلة للتغيير">

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}
```

</Listing>

حقل `sent_messages` الآن من نوع `RefCell<Vec<String>>` بدلاً من `Vec<String>`. في دالة `new`، ننشئ نسخة `RefCell<Vec<String>>` جديدة حول المتجه الفارغ.

لتنفيذ وسيلة `send`، المعامل الأول لا يزال استعارة غير قابلة للتغيير لـ `self`، والتي تطابق تعريف السِمة. نستدعي `borrow_mut` على `RefCell<Vec<String>>` في `self.sent_messages` للحصول على مرجع قابل للتغيير إلى القيمة داخل `RefCell<Vec<String>>`، وهي المتجه. بعد ذلك، يمكننا استدعاء `push` على المرجع القابل للتغيير إلى المتجه لتتبع الرسائل المرسلة خلال الاختبار.

التغيير الأخير الذي يتعين علينا إجراؤه هو في التأكيد: لمعرفة عدد العناصر في المتجه الداخلي، نستدعي `borrow` على `RefCell<Vec<String>>` للحصول على مرجع غير قابل للتغيير إلى المتجه.

الآن بعد أن رأيت كيفية استخدام `RefCell<T>`، دعنا نتعمق في كيفية عمله!

<!-- Old headings. Do not remove or links may break. -->

<a id="keeping-track-of-borrows-at-runtime-with-refcellt"></a>

#### تتبع الاستعارات في وقت التشغيل

عند إنشاء مراجع غير قابلة للتغيير وقابلة للتغيير، نستخدم صيغة `&` و `&mut`، على التوالي. مع `RefCell<T>`، نستخدم وسيلتي `borrow` و `borrow_mut`، اللتان تنتميان إلى الواجهة البرمجية الآمنة التي تنتمي إلى `RefCell<T>`. تعيد وسيلة `borrow` نوع المؤشر الذكي `Ref<T>`، وتعيد `borrow_mut` نوع المؤشر الذكي `RefMut<T>`. كلا النوعين ينفذان `Deref`، لذلك يمكننا معاملتهما كمراجع عادية.

يتتبع `RefCell<T>` عدد المؤشرات الذكية `Ref<T>` و `RefMut<T>` النشطة حاليًا. في كل مرة نستدعي فيها `borrow`، يزيد `RefCell<T>` عدده لعدد الاستعارات غير القابلة للتغيير النشطة. عندما تخرج قيمة `Ref<T>` عن النطاق، ينخفض عدد الاستعارات غير القابلة للتغيير بمقدار 1. تمامًا مثل قواعد الاستعارة في وقت الترجمة، يتيح لنا `RefCell<T>` الحصول على العديد من الاستعارات غير القابلة للتغيير أو استعارة قابلة للتغيير واحدة في أي نقطة زمنية.

إذا حاولنا انتهاك هذه القواعد، بدلاً من الحصول على خطأ مترجم كما سنفعل مع المراجع، سينهار تنفيذ `RefCell<T>` في وقت التشغيل. توضح القائمة 15-23 تعديلاً لتنفيذ `send` في القائمة 15-22. نحاول عمدًا إنشاء استعارتين قابلتين للتغيير نشطتين لنفس النطاق لتوضيح أن `RefCell<T>` يمنعنا من القيام بذلك في وقت التشغيل.

<Listing number="15-23" file-name="src/lib.rs" caption="إنشاء مرجعين قابلين للتغيير في نفس النطاق لرؤية أن `RefCell<T>` سينهار">

```rust,ignore,panics
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}
```

</Listing>

ننشئ متغيرًا `one_borrow` للمؤشر الذكي `RefMut<T>` المعاد من `borrow_mut`. بعد ذلك، ننشئ استعارة قابلة للتغيير أخرى بنفس الطريقة في المتغير `two_borrow`. هذا يصنع مرجعين قابلين للتغيير في نفس النطاق، وهو غير مسموح. عندما نشغل اختبارات مكتبتنا، سيُترجم الكود في القائمة 15-23 بدون أي أخطاء، لكن الاختبار سيفشل:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}
```

لاحظ أن الكود انهار مع الرسالة `already borrowed: BorrowMutError`. هذه هي الطريقة التي يتعامل بها `RefCell<T>` مع انتهاكات قواعد الاستعارة في وقت التشغيل.

اختيار اكتشاف أخطاء الاستعارة في وقت التشغيل بدلاً من وقت الترجمة، كما فعلنا هنا، يعني أنك ستكتشف الأخطاء في كودك لاحقًا في عملية التطوير: ربما لن يكون ذلك حتى يتم نشر كودك للإنتاج. كما سيتكبد كودك عقوبة أداء صغيرة في وقت التشغيل نتيجة لتتبع الاستعارات في وقت التشغيل بدلاً من وقت الترجمة. ومع ذلك، استخدام `RefCell<T>` يجعل من الممكن كتابة كائن وهمي يمكنه تعديل نفسه لتتبع الرسائل التي رآها أثناء استخدامه في سياق حيث يُسمح فقط بالقيم غير القابلة للتغيير. يمكنك استخدام `RefCell<T>` على الرغم من مقايضاته للحصول على وظائف أكثر مما توفره المراجع العادية.

<!-- Old headings. Do not remove or links may break. -->

<a id="having-multiple-owners-of-mutable-data-by-combining-rc-t-and-ref-cell-t"></a>
<a id="allowing-multiple-owners-of-mutable-data-with-rct-and-refcellt"></a>

### السماح بمالكين متعددين للبيانات القابلة للتغيير

طريقة شائعة لاستخدام `RefCell<T>` هي بالاقتران مع `Rc<T>`. تذكر أن `Rc<T>` يتيح لك الحصول على مالكين متعددين لبعض البيانات، لكنه يمنح فقط وصولاً غير قابل للتغيير لتلك البيانات. إذا كان لديك `Rc<T>` يحتفظ بـ `RefCell<T>`، يمكنك الحصول على قيمة يمكن أن يكون لها مالكون متعددون _و_ يمكنك تغييرها!

على سبيل المثال، تذكر مثال قائمة cons في القائمة 15-18 حيث استخدمنا `Rc<T>` للسماح لقوائم متعددة بمشاركة ملكية قائمة أخرى. لأن `Rc<T>` يحتفظ فقط بقيم غير قابلة للتغيير، لا يمكننا تغيير أي من القيم في القائمة بمجرد إنشائها. دعنا نضيف `RefCell<T>` لقدرتها على تغيير القيم في القوائم. توضح القائمة 15-24 أنه باستخدام `RefCell<T>` في تعريف `Cons`، يمكننا تعديل القيمة المخزنة في جميع القوائم.

<Listing number="15-24" file-name="src/main.rs" caption="استخدام `Rc<RefCell<i32>>` لإنشاء `List` يمكننا تغييرها">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-24/src/main.rs}}
```

</Listing>

ننشئ قيمة هي نسخة من `Rc<RefCell<i32>>` ونخزنها في متغير يسمى `value` بحيث يمكننا الوصول إليها مباشرة لاحقًا. بعد ذلك، ننشئ `List` في `a` مع متغير `Cons` يحتفظ بـ `value`. نحتاج إلى استنساخ `value` بحيث كل من `a` و `value` لديهما ملكية القيمة الداخلية `5` بدلاً من نقل الملكية من `value` إلى `a` أو جعل `a` تستعير من `value`.

نغلف القائمة `a` في `Rc<T>` بحيث عندما ننشئ القوائم `b` و `c`، يمكن لكليهما الإشارة إلى `a`، وهو ما فعلناه في القائمة 15-18.

بعد أن أنشأنا القوائم في `a` و `b` و `c`، نريد إضافة 10 إلى القيمة في `value`. نقوم بذلك عن طريق استدعاء `borrow_mut` على `value`، والذي يستخدم ميزة فك المرجع التلقائي التي ناقشناها في ["أين معامل `->`؟"][wheres-the---operator]<!-- ignore --> في الفصل 5 لفك مرجع `Rc<T>` إلى قيمة `RefCell<T>` الداخلية. تعيد وسيلة `borrow_mut` مؤشرًا ذكيًا `RefMut<T>`، ونستخدم معامل فك المرجع عليه ونغير القيمة الداخلية.

عندما نطبع `a` و `b` و `c`، يمكننا أن نرى أن جميعها لديها القيمة المعدلة `15` بدلاً من `5`:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}
```

هذه التقنية رائعة جدًا! باستخدام `RefCell<T>`، لدينا قيمة `List` غير قابلة للتغيير ظاهريًا. لكن يمكننا استخدام الوسائل على `RefCell<T>` التي توفر الوصول إلى قابليتها للتغيير الداخلية بحيث يمكننا تعديل بياناتنا عندما نحتاج إلى ذلك. تحمينا الفحوصات في وقت التشغيل لقواعد الاستعارة من سباقات البيانات، وأحيانًا يستحق تبادل القليل من السرعة لهذه المرونة في هياكل بياناتنا. لاحظ أن `RefCell<T>` لا يعمل للكود متعدد الخيوط! `Mutex<T>` هو النسخة الآمنة للخيوط من `RefCell<T>`، وسنناقش `Mutex<T>` في الفصل 16.

[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
