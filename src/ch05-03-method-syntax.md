## الدوال (Methods)

الدوال تشبه الوظائف: نعلنها باستخدام الكلمة المفتاحية `fn` واسم، ويمكن أن تحتوي على معاملات وقيمة إرجاع، وتحتوي على بعض الشيفرة التي تُنفَّذ عندما يتم استدعاء الدالة من مكان آخر. على عكس الوظائف، يتم تعريف الدوال ضمن سياق بنية (أو enum أو كائن trait، والتي نغطيها في [الفصل 6][enums]<!-- ignore --> و[الفصل 18][trait-objects]<!-- ignore -->، على التوالي)، ومعاملها الأول دائمًا `self`، والذي يمثل نسخة البنية التي يتم استدعاء الدالة عليها.

<!-- Old headings. Do not remove or links may break. -->

<a id="defining-methods"></a>

### صيغة الدوال (Method Syntax)

لنغير الوظيفة `area` التي تحتوي على نسخة من `Rectangle` كمعامل، وبدلاً من ذلك نجعلها دالة `area` معرَّفة على البنية `Rectangle`، كما هو موضح في القائمة 5-13.

<Listing number="5-13" file-name="src/main.rs" caption="تعريف دالة `area` على البنية `Rectangle`">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-13/src/main.rs}}
```

</Listing>

لتعريف الوظيفة ضمن سياق `Rectangle`، نبدأ كتلة `impl` (تطبيق) لـ `Rectangle`. كل شيء ضمن كتلة `impl` هذه سيرتبط بنوع `Rectangle`. ثم، ننقل الوظيفة `area` داخل أقواس `impl` المعقوفة ونغير المعامل الأول (والوحيد في هذه الحالة) ليكون `self` في التوقيع وفي كل مكان داخل الجسم. في `main`، حيث استدعينا الوظيفة `area` ومررنا `rect1` كوسيط، يمكننا بدلاً من ذلك استخدام _صيغة الدوال_ لاستدعاء الدالة `area` على نسخة `Rectangle` الخاصة بنا. صيغة الدوال تأتي بعد النسخة: نضيف نقطة متبوعة باسم الدالة، والأقواس، وأي وسائط.

في التوقيع لـ `area`، نستخدم `&self` بدلاً من `rectangle: &Rectangle`. الـ `&self` هو في الواقع اختصار لـ `self: &Self`. داخل كتلة `impl`، النوع `Self` هو اسم مستعار للنوع الذي تكون كتلة `impl` من أجله. يجب أن يكون للدوال معامل باسم `self` من النوع `Self` كمعامل أول لها، لذلك تتيح لك Rust اختصار هذا بالاسم `self` فقط في موضع المعامل الأول. لاحظ أننا ما زلنا بحاجة إلى استخدام `&` أمام الاختصار `self` للإشارة إلى أن هذه الدالة تستعير نسخة `Self`، تمامًا كما فعلنا في `rectangle: &Rectangle`. يمكن للدوال أن تأخذ ملكية `self`، أو تستعير `self` بشكل غير قابل للتعديل، كما فعلنا هنا، أو تستعير `self` بشكل قابل للتعديل، تمامًا كما يمكنها مع أي معامل آخر.

اخترنا `&self` هنا لنفس السبب الذي استخدمنا فيه `&Rectangle` في نسخة الوظيفة: لا نريد أخذ الملكية، ونريد فقط قراءة البيانات في البنية، وليس الكتابة إليها. إذا أردنا تغيير النسخة التي استدعينا الدالة عليها كجزء مما تفعله الدالة، سنستخدم `&mut self` كمعامل أول. وجود دالة تأخذ ملكية النسخة باستخدام `self` فقط كمعامل أول أمر نادر؛ هذه التقنية تُستخدم عادةً عندما تحول الدالة `self` إلى شيء آخر وتريد منع المستدعي من استخدام النسخة الأصلية بعد التحويل.

السبب الرئيسي لاستخدام الدوال بدلاً من الوظائف، بالإضافة إلى توفير صيغة الدوال وعدم الحاجة إلى تكرار نوع `self` في توقيع كل دالة، هو للتنظيم. لقد وضعنا جميع الأشياء التي يمكننا القيام بها مع نسخة من نوع في كتلة `impl` واحدة بدلاً من جعل المستخدمين المستقبليين لشيفرتنا يبحثون عن قدرات `Rectangle` في أماكن مختلفة في المكتبة التي نوفرها.

لاحظ أنه يمكننا اختيار إعطاء دالة نفس اسم أحد حقول البنية. على سبيل المثال، يمكننا تعريف دالة على `Rectangle` تسمى أيضًا `width`:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-06-method-field-interaction/src/main.rs:here}}
```

</Listing>

هنا، نختار جعل الدالة `width` تُرجع `true` إذا كانت القيمة في حقل `width` للنسخة أكبر من `0` و`false` إذا كانت القيمة `0`: يمكننا استخدام حقل داخل دالة بنفس الاسم لأي غرض. في `main`، عندما نتبع `rect1.width` بأقواس، يعرف Rust أننا نعني الدالة `width`. عندما لا نستخدم الأقواس، يعرف Rust أننا نعني الحقل `width`.

غالبًا، ولكن ليس دائمًا، عندما نعطي دالة نفس اسم الحقل، نريدها أن تُرجع القيمة في الحقل فقط ولا تفعل شيئًا آخر. تسمى الدوال مثل هذه _getters_، ولا تنفذها Rust تلقائيًا لحقول البنية كما تفعل بعض اللغات الأخرى. تكون الـ Getters مفيدة لأنه يمكنك جعل الحقل خاصًا ولكن الدالة عامة وبالتالي تمكين الوصول للقراءة فقط إلى هذا الحقل كجزء من واجهة API العامة للنوع. سنناقش ما هو العام والخاص وكيفية تحديد حقل أو دالة كعامة أو خاصة في [الفصل 7][public]<!-- ignore -->.

> ### أين هو العامل `->` (Operator)؟
>
> في C و C++، يُستخدم عاملان مختلفان لاستدعاء الدوال: تستخدم `.` إذا كنت تستدعي دالة على الكائن مباشرة و`->` إذا كنت تستدعي الدالة على مؤشر إلى الكائن وتحتاج إلى إلغاء الإشارة إلى المؤشر أولاً. بعبارة أخرى، إذا كان `object` مؤشرًا، فإن `object->something()` مشابه لـ `(*object).something()`.
>
> لا تحتوي Rust على ما يعادل العامل `->`؛ بدلاً من ذلك، تحتوي Rust على ميزة تسمى _الإشارة التلقائية وإلغاء الإشارة التلقائية_. استدعاء الدوال هو أحد الأماكن القليلة في Rust بهذا السلوك.
>
> إليك كيف يعمل: عندما تستدعي دالة باستخدام `object.something()`، تضيف Rust تلقائيًا `&` أو `&mut` أو `*` بحيث يتطابق `object` مع توقيع الدالة. بعبارة أخرى، ما يلي هو نفسه:
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> الأول يبدو أكثر وضوحًا. سلوك الإشارة التلقائية هذا يعمل لأن الدوال لها مستقبل واضح - نوع `self`. بالنظر إلى المستقبل واسم الدالة، يمكن لـ Rust معرفة بشكل نهائي ما إذا كانت الدالة تقرأ (`&self`)، أو تعدل (`&mut self`)، أو تستهلك (`self`). حقيقة أن Rust تجعل الاستعارة ضمنية لمستقبلي الدوال هي جزء كبير من جعل الملكية مريحة في الممارسة.

### دوال مع معاملات إضافية

لنتدرب على استخدام الدوال من خلال تطبيق دالة ثانية على البنية `Rectangle`. هذه المرة نريد أن تأخذ نسخة من `Rectangle` نسخة أخرى من `Rectangle` وتُرجع `true` إذا كان `Rectangle` الثاني يمكن أن يتناسب تمامًا داخل `self` (`Rectangle` الأول)؛ وإلا، يجب أن تُرجع `false`. أي، بمجرد أن نُعرّف الدالة `can_hold`، نريد أن نكون قادرين على كتابة البرنامج الموضح في القائمة 5-14.

<Listing number="5-14" file-name="src/main.rs" caption="استخدام الدالة `can_hold` التي لم تُكتب بعد">

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-14/src/main.rs}}
```

</Listing>

الناتج المتوقع سيبدو كالتالي لأن كلا البعدين لـ `rect2` أصغر من أبعاد `rect1`, لكن `rect3` أعرض من `rect1`:

```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

نعلم أننا نريد تعريف دالة، لذلك ستكون داخل كتلة `impl Rectangle`. اسم الدالة سيكون `can_hold`، وستأخذ استعارة غير قابلة للتعديل من `Rectangle` آخر كمعامل. يمكننا معرفة نوع المعامل بالنظر إلى الشيفرة التي تستدعي الدالة: `rect1.can_hold(&rect2)` تمرر `&rect2`، وهي استعارة غير قابلة للتعديل لـ `rect2`، نسخة من `Rectangle`. هذا منطقي لأننا نحتاج فقط إلى قراءة `rect2` (بدلاً من الكتابة، والتي تعني أننا سنحتاج إلى استعارة قابلة للتعديل)، ونريد أن يحتفظ `main` بملكية `rect2` حتى نتمكن من استخدامه مرة أخرى بعد استدعاء الدالة `can_hold`. قيمة الإرجاع لـ `can_hold` ستكون Boolean، وسيتحقق التطبيق مما إذا كان عرض وارتفاع `self` أكبر من عرض وارتفاع `Rectangle` الآخر، على التوالي. لنضف الدالة الجديدة `can_hold` إلى كتلة `impl` من القائمة 5-13، الموضحة في القائمة 5-15.

<Listing number="5-15" file-name="src/main.rs" caption="تطبيق الدالة `can_hold` على `Rectangle` التي تأخذ نسخة أخرى من `Rectangle` كمعامل">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-15/src/main.rs:here}}
```

</Listing>

عندما نشغل هذه الشيفرة مع الوظيفة `main` في القائمة 5-14، سنحصل على الناتج المرغوب. يمكن للدوال أن تأخذ معاملات متعددة نضيفها إلى التوقيع بعد معامل `self`، وتعمل هذه المعاملات تمامًا مثل المعاملات في الوظائف.

### الوظائف المرتبطة (Associated Functions)

جميع الوظائف المعرَّفة داخل كتلة `impl` تسمى _وظائف مرتبطة_ لأنها مرتبطة بالنوع المسمى بعد `impl`. يمكننا تعريف وظائف مرتبطة لا تحتوي على `self` كمعامل أول لها (وبالتالي ليست دوال) لأنها لا تحتاج إلى نسخة من النوع للعمل معها. لقد استخدمنا بالفعل وظيفة واحدة مثل هذه: الوظيفة `String::from` المعرَّفة على نوع `String`.

الوظائف المرتبطة التي ليست دوالاً غالبًا ما تُستخدم للبناة (constructors) التي ستُرجع نسخة جديدة من البنية. غالبًا ما تسمى هذه `new`، لكن `new` ليس اسمًا خاصًا وليس مدمجًا في اللغة. على سبيل المثال، يمكننا اختيار توفير وظيفة مرتبطة باسم `square` سيكون لها معامل بُعد واحد وتستخدمه كعرض وارتفاع، مما يجعل من الأسهل إنشاء `Rectangle` مربع بدلاً من الحاجة إلى تحديد نفس القيمة مرتين:

<span class="filename">اسم الملف: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-03-associated-functions/src/main.rs:here}}
```

الكلمات المفتاحية `Self` في نوع الإرجاع وفي جسم الوظيفة هي أسماء مستعارة للنوع الذي يظهر بعد الكلمة المفتاحية `impl`، والذي في هذه الحالة هو `Rectangle`.

لاستدعاء هذه الوظيفة المرتبطة، نستخدم صيغة `::` مع اسم البنية؛ `let sq = Rectangle::square(3);` هو مثال. هذه الوظيفة مُحدَّدة النطاق بواسطة البنية: صيغة `::` تُستخدم لكل من الوظائف المرتبطة والنطاقات التي تم إنشاؤها بواسطة الوحدات (modules). سنناقش الوحدات في [الفصل 7][modules]<!-- ignore -->.

### كتل `impl` متعددة

يُسمح لكل بنية أن تحتوي على كتل `impl` متعددة. على سبيل المثال، القائمة 5-15 مكافئة للشيفرة الموضحة في القائمة 5-16، التي تحتوي على كل دالة في كتلة `impl` خاصة بها.

<Listing number="5-16" caption="إعادة كتابة القائمة 5-15 باستخدام كتل `impl` متعددة">

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-16/src/main.rs:here}}
```

</Listing>

لا يوجد سبب لفصل هذه الدوال إلى كتل `impl` متعددة هنا، لكن هذه صيغة صحيحة. سنرى حالة تكون فيها كتل `impl` المتعددة مفيدة في الفصل 10، حيث نناقش الأنواع العامة والخصائص (traits).

## الخلاصة

تتيح لك البنيات إنشاء أنواع مخصصة ذات معنى لمجالك. باستخدام البنيات، يمكنك الاحتفاظ بأجزاء البيانات المرتبطة متصلة ببعضها البعض وتسمية كل جزء لجعل شيفرتك واضحة. في كتل `impl`، يمكنك تعريف وظائف مرتبطة بنوعك، والدوال هي نوع من الوظائف المرتبطة التي تتيح لك تحديد السلوك الذي تمتلكه نسخ بنياتك.

لكن البنيات ليست الطريقة الوحيدة لإنشاء أنواع مخصصة: لننتقل إلى ميزة enum في Rust لإضافة أداة أخرى إلى صندوق أدواتك.

[enums]: ch06-00-enums.html
[trait-objects]: ch18-02-trait-objects.md
[public]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
[modules]: ch07-02-defining-modules-to-control-scope-and-privacy.html
