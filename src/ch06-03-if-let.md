## تدفق تحكم موجز مع `if let` و `let else`

تتيح لك صياغة `if let` دمج `if` و `let` في طريقة أقل إسهاباً للتعامل مع القيم
التي تطابق نمطاً واحداً بينما تتجاهل الباقي. فكر في البرنامج في القائمة 6-6
الذي يطابق قيمة `Option<u8>` في متغير `config_max` ولكنه يريد فقط تنفيذ الكود
إذا كانت القيمة هي متغير `Some`.

<Listing number="6-6" caption="`match` يهتم فقط بتنفيذ الكود عندما تكون القيمة `Some`">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
```

</Listing>

إذا كانت القيمة `Some`، نطبع القيمة في متغير `Some` عن طريق ربط القيمة بالمتغير
`max` في النمط. لا نريد فعل أي شيء مع قيمة `None`. لإرضاء تعبير `match`، يجب
أن نضيف `_ => ()` بعد معالجة متغير واحد فقط، وهو كود نموذجي مزعج للإضافة.

بدلاً من ذلك، يمكننا كتابة هذا بطريقة أقصر باستخدام `if let`. الكود التالي
يتصرف بنفس طريقة `match` في القائمة 6-6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
```

تأخذ صياغة `if let` نمطاً وتعبيراً مفصولين بعلامة يساوي. تعمل بنفس طريقة
`match`، حيث يُعطى التعبير إلى `match` والنمط هو ذراعها الأول. في هذه الحالة،
النمط هو `Some(max)`، و `max` يرتبط بالقيمة داخل `Some`. يمكننا حينها استخدام
`max` في جسم كتلة `if let` بنفس الطريقة التي استخدمنا بها `max` في ذراع
`match` المقابل. الكود في كتلة `if let` يعمل فقط إذا طابقت القيمة النمط.

استخدام `if let` يعني كتابة أقل، وإزاحة أقل، وكود نموذجي أقل. ومع ذلك، تفقد
الفحص الشامل الذي يفرضه `match` والذي يضمن أنك لا تنسى التعامل مع أي حالات.
الاختيار بين `match` و `if let` يعتمد على ما تفعله في موقفك الخاص وما إذا كان
الحصول على الإيجاز هو مقايضة مناسبة لفقدان الفحص الشامل.

بعبارة أخرى، يمكنك التفكير في `if let` على أنها سكر نحوي لـ `match` التي
تشغل الكود عندما تطابق القيمة نمطاً واحداً ثم تتجاهل جميع القيم الأخرى.

يمكننا تضمين `else` مع `if let`. كتلة الكود التي تذهب مع `else` هي نفس كتلة
الكود التي ستذهب مع حالة `_` في تعبير `match` الذي يعادل `if let` و `else`.
تذكر تعريف تعداد `Coin` في القائمة 6-4، حيث احتوى متغير `Quarter` أيضاً على
قيمة `UsState`. إذا أردنا عد جميع العملات غير الربع التي نراها بينما نعلن
أيضاً عن ولاية الربع، يمكننا فعل ذلك باستخدام تعبير `match`، كهذا:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
```

أو يمكننا استخدام تعبير `if let` و `else`، كهذا:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
```

## البقاء على "المسار السعيد" مع `let...else`

النمط الشائع هو إجراء بعض الحسابات عندما تكون القيمة موجودة وإعادة قيمة
افتراضية بخلاف ذلك. متابعة مع مثالنا للعملات مع قيمة `UsState`، إذا أردنا قول
شيء مضحك اعتماداً على عمر الولاية على الربع، قد نقدم دالة على `UsState` للتحقق
من عمر الولاية، كهذا:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-07/src/main.rs:state}}
```

ثم قد نستخدم `if let` لمطابقة نوع العملة، مقدمين متغير `state` داخل جسم
الشرط، كما في القائمة 6-7.

<Listing number="6-7" caption="التحقق مما إذا كانت ولاية موجودة في عام 1900 باستخدام شروط متداخلة داخل `if let`">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-07/src/main.rs:describe}}
```

</Listing>

هذا ينجز المهمة، لكنه دفع العمل إلى جسم بيان `if let`، وإذا كان العمل المراد
إنجازه أكثر تعقيداً، قد يكون من الصعب تتبع كيفية ارتباط الفروع ذات المستوى
الأعلى تماماً. يمكننا أيضاً الاستفادة من حقيقة أن التعبيرات تنتج قيمة إما
لإنتاج `state` من `if let` أو للعودة مبكراً، كما في القائمة 6-8. (يمكنك فعل
شيء مماثل مع `match` أيضاً.)

<Listing number="6-8" caption="استخدام `if let` لإنتاج قيمة أو العودة مبكراً">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-08/src/main.rs:describe}}
```

</Listing>

هذا مزعج قليلاً للمتابعة بطريقته الخاصة! فرع واحد من `if let` ينتج قيمة،
والآخر يعود من الدالة بالكامل.

لجعل هذا النمط الشائع أفضل للتعبير عنه، تمتلك Rust `let...else`. صياغة
`let...else` تأخذ نمطاً على الجانب الأيسر وتعبيراً على اليمين، مشابه جداً لـ
`if let`، لكنها لا تمتلك فرع `if`، فقط فرع `else`. إذا طابق النمط، سيربط
القيمة من النمط في النطاق الخارجي. إذا _لم_ يطابق النمط، سيتدفق البرنامج إلى
ذراع `else`، والذي يجب أن يعود من الدالة.

في القائمة 6-9، يمكنك رؤية كيف تبدو القائمة 6-8 عند استخدام `let...else` بدلاً
من `if let`.

<Listing number="6-9" caption="استخدام `let...else` لتوضيح التدفق عبر الدالة">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-09/src/main.rs:describe}}
```

</Listing>

لاحظ أنها تبقى على "المسار السعيد" في الجسم الرئيسي للدالة بهذه الطريقة، بدون
تدفق تحكم مختلف بشكل كبير لفرعين كما فعل `if let`.

إذا كان لديك موقف حيث برنامجك لديه منطق مطول جداً للتعبير عنه باستخدام
`match`، تذكر أن `if let` و `let...else` موجودان أيضاً في صندوق أدوات Rust
الخاص بك.

## الخلاصة

لقد غطينا الآن كيفية استخدام التعدادات لإنشاء أنواع مخصصة يمكن أن تكون واحدة
من مجموعة من القيم المعدودة. لقد أظهرنا كيف يساعدك نوع `Option<T>` الخاص
بالمكتبة القياسية على استخدام نظام الأنواع لمنع الأخطاء. عندما تحتوي قيم
التعداد على بيانات بداخلها، يمكنك استخدام `match` أو `if let` لاستخراج
واستخدام تلك القيم، اعتماداً على عدد الحالات التي تحتاج إلى التعامل معها.

يمكن لبرامج Rust الخاصة بك الآن التعبير عن المفاهيم في مجالك باستخدام البنى
والتعدادات. إنشاء أنواع مخصصة للاستخدام في واجهة برمجة التطبيقات الخاصة بك
يضمن سلامة الأنواع: سيتأكد المصرِّف من أن دوالك تحصل فقط على قيم من النوع الذي
تتوقعه كل دالة.

من أجل توفير واجهة برمجة تطبيقات منظمة جيداً لمستخدميك تكون مباشرة للاستخدام
وتكشف بالضبط فقط ما سيحتاجه مستخدموك، لننتقل الآن إلى وحدات Rust.
