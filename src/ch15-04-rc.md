## `Rc<T>`، المؤشر الذكي (Smart Pointer) الذي يعد المراجع (Reference Counting)

في غالبية الحالات، الملكية واضحة: تعرف بالضبط أي متغير يمتلك قيمة معينة. ومع ذلك، هناك حالات قد يكون فيها لقيمة واحدة مالكين متعددين. على سبيل المثال، في هياكل بيانات الرسم البياني (graph)، قد تشير حواف متعددة إلى نفس العقدة (node)، وتلك العقدة مملوكة مفاهيميًا من قبل جميع الحواف التي تشير إليها. لا ينبغي تنظيف العقدة ما لم لا يكن لديها أي حواف تشير إليها وبالتالي ليس لها مالكين.

يجب عليك تمكين الملكية المتعددة صراحةً باستخدام نوع Rust `Rc<T>`، وهو اختصار لـ _عد المراجع_ (reference counting). يتتبع نوع `Rc<T>` عدد المراجع (reference count) إلى قيمة لتحديد ما إذا كانت القيمة لا تزال قيد الاستخدام أم لا. إذا كان هناك صفر مراجع لقيمة، يمكن تنظيف القيمة دون أن تصبح أي مراجع غير صالحة.

تخيل `Rc<T>` كجهاز تلفزيون في غرفة عائلية. عندما يدخل شخص واحد لمشاهدة التلفزيون، يشغله. يمكن للآخرين الدخول إلى الغرفة ومشاهدة التلفزيون. عندما يغادر الشخص الأخير الغرفة، يطفئ التلفزيون لأنه لم يعد قيد الاستخدام. إذا أطفأ شخص ما التلفزيون بينما لا يزال الآخرون يشاهدونه، سيكون هناك ضجة من مشاهدي التلفزيون المتبقين!

نستخدم نوع `Rc<T>` عندما نريد تخصيص بعض البيانات على الكومة لأجزاء متعددة من برنامجنا للقراءة ولا يمكننا تحديد في وقت الترجمة أي جزء سينتهي من استخدام البيانات أخيرًا. إذا كنا نعرف أي جزء سينتهي أخيرًا، يمكننا فقط جعل هذا الجزء هو مالك البيانات، وستسري قواعد الملكية العادية المفروضة في وقت الترجمة.

لاحظ أن `Rc<T>` مخصص للاستخدام فقط في سيناريوهات أحادية الخيط (single-threaded). عندما نناقش التزامن في الفصل 16، سنغطي كيفية القيام بعد المراجع (reference counting) في البرامج متعددة الخيوط.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-rct-to-share-data"></a>

### مشاركة البيانات

لنعد إلى مثال قائمة cons في القائمة 15-5. تذكر أننا عرّفناها باستخدام `Box<T>`. هذه المرة، سننشئ قائمتين تشتركان في ملكية قائمة ثالثة. من الناحية المفاهيمية، يبدو هذا مشابهًا للشكل 15-3.

<img alt="A linked list with the label 'a' pointing to three elements. The first element contains the integer 5 and points to the second element. Th
e second element contains the integer 10 and points to the third element. The third element contains the value 'Nil' that signifies the end of the l
ist; it does not point anywhere. A linked list with the label 'b' points to an element that contains the integer 3 and points to the first element o
f list 'a'. A linked list with the label 'c' points to an element that contains the integer 4 and also points to the first element of list 'a' so th
at the tails of lists 'b' and 'c' are both list 'a'." src="img/trpl15-03.svg" class="center" />

<span class="caption">الشكل 15-3: قائمتان، `b` و `c`، تشتركان في ملكية قائمة ثالثة، `a`</span>

سننشئ القائمة `a` التي تحتوي على `5` ثم `10`. بعد ذلك، سننشئ قائمتين أخريين: `b` التي تبدأ بـ `3` و `c` التي تبدأ بـ `4`. ستستمر كل من القائمتين `b` و `c` إلى القائمة `a` الأولى التي تحتوي على `5` و `10`. بعبارة أخرى، ستشترك كلتا القائمتين في القائمة الأولى التي تحتوي على `5` و `10`.

محاولة تنفيذ هذا السيناريو باستخدام تعريفنا لـ `List` مع `Box<T>` لن تعمل، كما هو موضح في القائمة 15-17.

<Listing number="15-17" file-name="src/main.rs" caption="إثبات أنه غير مسموح لنا بوجود قائمتين باستخدام `Box<T>` تحاولان مشاركة ملكية قائمة ثالثة">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

</Listing>

عندما نترجم هذا الكود، نحصل على هذا الخطأ:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

متغيرات `Cons` تمتلك البيانات التي تحتفظ بها، لذلك عندما ننشئ القائمة `b`، يتم نقل `a` إلى `b` و `b` تمتلك `a`. بعد ذلك، عندما نحاول استخدام `a` مرة أخرى عند إنشاء `c`، لا يُسمح لنا بذلك لأن `a` تم نقله.

يمكننا تغيير تعريف `Cons` للاحتفاظ بمراجع بدلاً من ذلك، لكن بعد ذلك سيتعين علينا تحديد معاملات مدة الصلاحية. من خلال تحديد معاملات مدة الصلاحية، سنحدد أن كل عنصر في القائمة سيعيش على الأقل بقدر القائمة بأكملها. هذا هو الحال بالنسبة للعناصر والقوائم في القائمة 15-17، ولكن ليس في كل سيناريو.

بدلاً من ذلك، سنغير تعريفنا لـ `List` لاستخدام `Rc<T>` بدلاً من `Box<T>`، كما هو موضح في القائمة 15-18. سيحتفظ كل متغير `Cons` الآن بقيمة و `Rc<T>` يشير إلى `List`. عندما ننشئ `b`، بدلاً من أخذ ملكية `a`، سنستنسخ `Rc<List>` الذي تحتفظ به `a`، وبذلك نزيد عدد المراجع من واحد إلى اثنين ونسمح لـ `a` و `b` بمشاركة ملكية البيانات في تلك `Rc<List>`. سنستنسخ `a` أيضًا عند إنشاء `c`، مما يزيد عدد المراجع (reference count) من اثنين إلى ثلاثة. في كل مرة نستدعي فيها `Rc::clone`، سيزيد عدد المراجع (reference count) للبيانات داخل `Rc<List>`، ولن يتم تنظيف البيانات ما لم يكن هناك صفر مراجع إليها.

<Listing number="15-18" file-name="src/main.rs" caption="تعريف `List` يستخدم `Rc<T>`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

</Listing>

نحتاج إلى إضافة عبارة `use` لإدخال `Rc<T>` إلى النطاق لأنها ليست في الـ prelude. في `main`، ننشئ القائمة التي تحتفظ بـ `5` و `10` ونخزنها في `Rc<List>` جديد في `a`. بعد ذلك، عندما ننشئ `b` و `c`، نستدعي دالة `Rc::clone` ونمرر مرجعًا إلى `Rc<List>` في `a` كمعامل.

كان يمكننا استدعاء `a.clone()` بدلاً من `Rc::clone(&a)`، لكن اصطلاح Rust هو استخدام `Rc::clone` في هذه الحالة. تنفيذ `Rc::clone` لا يقوم بنسخة عميقة (deep copy) لجميع البيانات مثل معظم تنفيذات الأنواع لـ `clone`. استدعاء `Rc::clone` يزيد فقط عدد المراجع (reference count)، وهو ما لا يستغرق وقتًا طويلاً. يمكن أن تستغرق النسخ العميقة للبيانات وقتًا طويلاً. باستخدام `Rc::clone` لعد المراجع (reference counting)، يمكننا التمييز بصريًا بين أنواع الاستنساخ للنسخ العميق وأنواع الاستنساخ التي تزيد عدد المراجع (reference count). عند البحث عن مشاكل الأداء في الكود، نحتاج فقط إلى النظر في استنساخ النسخ العميق ويمكننا تجاهل الاستدعاءات إلى `Rc::clone`.

<!-- Old headings. Do not remove or links may break. -->

<a id="cloning-an-rct-increases-the-reference-count"></a>

### الاستنساخ لزيادة عدد المراجع (Reference Count)

لنغير مثالنا العملي في القائمة 15-18 بحيث يمكننا رؤية أعداد المراجع (reference counts) تتغير بينما ننشئ ونسقط (drop) المراجع إلى `Rc<List>` في `a`.

في القائمة 15-19، سنغير `main` بحيث يكون لديها نطاق داخلي حول القائمة `c`؛ بعد ذلك، يمكننا رؤية كيف يتغير عدد المراجع عندما تخرج `c` عن النطاق.

<Listing number="15-19" file-name="src/main.rs" caption="طباعة عدد المراجع">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

</Listing>

في كل نقطة في البرنامج حيث يتغير عدد المراجع (reference count)، نطبع عدد المراجع (reference count)، الذي نحصل عليه عن طريق استدعاء دالة `Rc::strong_count`. تسمى هذه الدالة `strong_count` بدلاً من `count` لأن نوع `Rc<T>` لديه أيضًا `weak_count`؛ سنرى ما يُستخدم لـ `weak_count` في ["منع دورات المراجع باستخدام `Weak<T>`"][preventing-ref-cycles]<!-- ignore -->.

يطبع هذا الكود ما يلي:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

يمكننا أن نرى أن `Rc<List>` في `a` لديها عدد مراجع (reference count) أولي يبلغ 1؛ بعد ذلك، في كل مرة نستدعي فيها `clone`، يرتفع العدد بمقدار 1. عندما تخرج `c` عن النطاق، ينخفض العدد بمقدار 1. لا يتعين علينا استدعاء دالة لتقليل عدد المراجع (reference count) كما علينا استدعاء `Rc::clone` لزيادة عدد المراجع (reference count): تنفيذ سِمة `Drop` يقلل عدد المراجع (reference count) تلقائيًا عندما تخرج قيمة `Rc<T>` عن النطاق.

ما لا يمكننا رؤيته في هذا المثال هو أنه عندما تخرج `b` ثم `a` عن النطاق في نهاية `main`، يكون العدد 0، ويتم تنظيف `Rc<List>` تمامًا. باستخدام `Rc<T>` يسمح لقيمة واحدة بأن يكون لها مالكين متعددين، ويضمن عد المراجع (reference count) أن القيمة تبقى صالحة طالما أن أيًا من المالكين لا يزال موجودًا.

عبر المراجع غير القابلة للتغيير، يسمح لك `Rc<T>` بمشاركة البيانات بين أجزاء متعددة من برنامجك للقراءة فقط. إذا سمح `Rc<T>` لك بأن يكون لديك مراجع قابلة للتغيير متعددة أيضًا، فقد تنتهك إحدى قواعد الاستعارة التي تمت مناقشتها في الفصل 4: الاستعارات القابلة للتغيير المتعددة لنفس المكان يمكن أن تتسبب في سباقات البيانات (data races) والتناقضات. لكن القدرة على تغيير البيانات مفيدة جدًا! في القسم التالي، سنناقش نمط القابلية للتغيير الداخلية (interior mutability) ونوع `RefCell<T>` الذي يمكنك استخدامه بالاقتران مع `Rc<T>` للعمل مع قيد عدم القابلية للتغيير هذا.

[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
