<!-- Old headings. Do not remove or links may break. -->

<a id="treating-smart-pointers-like-regular-references-with-the-deref-trait"></a>
<a id="treating-smart-pointers-like-regular-references-with-deref"></a>

## معاملة المؤشرات الذكية كمراجع عادية

تنفيذ سِمة `Deref` يسمح لك بتخصيص سلوك _معامل فك المرجع_ (dereference operator) `*` (لا يجب الخلط بينه وبين معامل الضرب أو glob). من خلال تنفيذ `Deref` بطريقة تسمح بمعاملة المؤشر الذكي كمرجع عادي، يمكنك كتابة كود يعمل على المراجع واستخدام هذا الكود مع المؤشرات الذكية أيضًا.

دعنا ننظر أولاً في كيفية عمل معامل فك المرجع مع المراجع العادية. بعد ذلك، سنحاول تعريف نوع مخصص يتصرف مثل `Box<T>` ونرى لماذا لا يعمل معامل فك المرجع كمرجع على نوعنا المعرّف حديثًا. سنستكشف كيف يجعل تنفيذ سِمة `Deref` من الممكن للمؤشرات الذكية أن تعمل بطرق مشابهة للمراجع. بعد ذلك، سننظر في ميزة التحويل الضمني لفك المرجع (deref coercion) في Rust وكيف تتيح لنا العمل مع المراجع أو المؤشرات الذكية.

<!-- Old headings. Do not remove or links may break. -->

<a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a>
<a id="following-the-pointer-to-the-value"></a>

### تتبع المرجع إلى القيمة

المرجع العادي هو نوع من المؤشرات، وطريقة واحدة للتفكير في المؤشر هي كسهم إلى قيمة مخزنة في مكان آخر. في القائمة 15-6، ننشئ مرجعًا إلى قيمة `i32` ثم نستخدم معامل فك المرجع لتتبع المرجع إلى القيمة.

<Listing number="15-6" file-name="src/main.rs" caption="استخدام معامل فك المرجع لتتبع مرجع إلى قيمة `i32`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}
```

</Listing>

المتغير `x` يحتفظ بقيمة `i32` وهي `5`. نضبط `y` ليساوي مرجعًا إلى `x`. يمكننا التأكيد على أن `x` يساوي `5`. ومع ذلك، إذا أردنا إجراء تأكيد على القيمة في `y`، يجب أن نستخدم `*y` لتتبع المرجع إلى القيمة التي يشير إليها (وبالتالي، _فك المرجع_ dereference) حتى يتمكن المترجم من مقارنة القيمة الفعلية. بمجرد أن نفك مرجع `y`، يكون لدينا وصول إلى قيمة الأعداد الصحيحة التي يشير إليها `y` والتي يمكننا مقارنتها بـ `5`.

إذا حاولنا كتابة `assert_eq!(5, y);` بدلاً من ذلك، سنحصل على خطأ الترجمة هذا:

```console
{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}
```

مقارنة رقم ومرجع إلى رقم غير مسموح بها لأنهما نوعان مختلفان. يجب أن نستخدم معامل فك المرجع لتتبع المرجع إلى القيمة التي يشير إليها.

### استخدام `Box<T>` كمرجع

يمكننا إعادة كتابة الكود في القائمة 15-6 لاستخدام `Box<T>` بدلاً من مرجع؛ يعمل معامل فك المرجع المستخدم على `Box<T>` في القائمة 15-7 بنفس الطريقة التي يعمل بها معامل فك المرجع المستخدم على المرجع في القائمة 15-6.

<Listing number="15-7" file-name="src/main.rs" caption="استخدام معامل فك المرجع على `Box<i32>`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}
```

</Listing>

الفرق الرئيسي بين القائمة 15-7 والقائمة 15-6 هو أننا هنا نضبط `y` ليكون نسخة من صندوق يشير إلى قيمة منسوخة من `x` بدلاً من مرجع يشير إلى قيمة `x`. في التأكيد الأخير، يمكننا استخدام معامل فك المرجع لتتبع مؤشر الصندوق بنفس الطريقة التي فعلناها عندما كان `y` مرجعًا. بعد ذلك، سنستكشف ما هو مميز في `Box<T>` يتيح لنا استخدام معامل فك المرجع من خلال تعريف نوع الصندوق الخاص بنا.

### تعريف المؤشر الذكي الخاص بنا

لنبني نوع غلاف (wrapper type) مشابهًا لنوع `Box<T>` المقدم من المكتبة القياسية لتجربة كيف تتصرف أنواع المؤشرات الذكية بشكل مختلف عن المراجع بشكل افتراضي. بعد ذلك، سننظر في كيفية إضافة القدرة على استخدام معامل فك المرجع.

> ملاحظة: هناك اختلاف كبير واحد بين نوع `MyBox<T>` الذي نحن على وشك بناءه والـ `Box<T>` الحقيقي: نسختنا لن تخزن بياناتها على الكومة. نحن نركز في هذا المثال على `Deref`، لذلك فإن مكان تخزين البيانات فعليًا أقل أهمية من السلوك الشبيه بالمؤشر.

نوع `Box<T>` معرّف في النهاية كـ struct مجموعة (tuple struct) مع عنصر واحد، لذلك تعرّف القائمة 15-8 نوع `MyBox<T>` بنفس الطريقة. سنعرّف أيضًا دالة `new` لتتطابق مع دالة `new` المعرّفة على `Box<T>`.

<Listing number="15-8" file-name="src/main.rs" caption="تعريف نوع `MyBox<T>`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}
```

</Listing>

نعرّف struct باسم `MyBox` ونعلن عن معامل عام (generic parameter) `T` لأننا نريد أن يحتفظ نوعنا بقيم من أي نوع. نوع `MyBox` هو struct مجموعة مع عنصر واحد من نوع `T`. دالة `MyBox::new` تأخذ معامل واحد من نوع `T` وتعيد نسخة `MyBox` تحتفظ بالقيمة الممررة.

دعنا نحاول إضافة دالة `main` في القائمة 15-7 إلى القائمة 15-8 وتغييرها لاستخدام نوع `MyBox<T>` الذي عرّفناه بدلاً من `Box<T>`. الكود في القائمة 15-9 لن يُترجم، لأن Rust لا تعرف كيفية فك مرجع `MyBox`.

<Listing number="15-9" file-name="src/main.rs" caption="محاولة استخدام `MyBox<T>` بنفس الطريقة التي استخدمنا بها المراجع و `Box<T>`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}
```

</Listing>

إليك خطأ الترجمة الناتج:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}
```

نوعنا `MyBox<T>` لا يمكن فك مرجعه لأننا لم ننفذ هذه القدرة على نوعنا. لتمكين فك المرجع باستخدام معامل `*`، ننفذ سِمة `Deref`.

<!-- Old headings. Do not remove or links may break. -->

<a id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a>

### تنفيذ سِمة `Deref`

كما تمت مناقشته في ["تنفيذ سِمة على نوع"][impl-trait]<!-- ignore --> في الفصل 10، لتنفيذ سِمة نحتاج إلى توفير تنفيذات للوسائل المطلوبة للسِمة. سِمة `Deref`، المقدمة من المكتبة القياسية، تتطلب منا تنفيذ وسيلة واحدة باسم `deref` تستعير `self` وتعيد مرجعًا إلى البيانات الداخلية. تحتوي القائمة 15-10 على تنفيذ لـ `Deref` لإضافته إلى تعريف `MyBox<T>`.

<Listing number="15-10" file-name="src/main.rs" caption="تنفيذ `Deref` على `MyBox<T>`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
```

</Listing>

صيغة `type Target = T;` تعرّف نوعًا مرتبطًا (associated type) لسِمة `Deref` لاستخدامه. الأنواع المرتبطة هي طريقة مختلفة قليلاً للإعلان عن معامل عام، لكن لا داعي للقلق بشأنها الآن؛ سنغطيها بمزيد من التفصيل في الفصل 20.

نملأ جسم وسيلة `deref` بـ `&self.0` حتى تعيد `deref` مرجعًا إلى القيمة التي نريد الوصول إليها باستخدام معامل `*`؛ تذكر من ["إنشاء أنواع مختلفة باستخدام Tuple Structs"][tuple-structs]<!-- ignore --> في الفصل 5 أن `.0` يصل إلى القيمة الأولى في struct مجموعة. دالة `main` في القائمة 15-9 التي تستدعي `*` على قيمة `MyBox<T>` تُترجم الآن، والتأكيدات تنجح!

بدون سِمة `Deref`، يمكن للمترجم فقط فك مرجع المراجع `&`. وسيلة `deref` تعطي المترجم القدرة على أخذ قيمة من أي نوع ينفذ `Deref` واستدعاء وسيلة `deref` للحصول على مرجع `&` يعرف كيفية فك مرجعه.

عندما أدخلنا `*y` في القائمة 15-9، خلف الكواليس شغّلت Rust فعليًا هذا الكود:

```rust,ignore
*(y.deref())
```

تستبدل Rust معامل `*` بدعوة إلى وسيلة `deref` ثم فك مرجع بسيط حتى لا نضطر للتفكير فيما إذا كنا بحاجة إلى استدعاء وسيلة `deref` أم لا. تتيح لنا هذه الميزة في Rust كتابة كود يعمل بشكل متطابق سواء كان لدينا مرجع عادي أو نوع ينفذ `Deref`.

السبب في أن وسيلة `deref` تعيد مرجعًا إلى قيمة، وأن فك المرجع البسيط خارج الأقواس في `*(y.deref())` لا يزال ضروريًا، له علاقة بنظام الملكية. إذا أعادت وسيلة `deref` القيمة مباشرة بدلاً من مرجع إلى القيمة، سيتم نقل القيمة خارج `self`. لا نريد أخذ ملكية القيمة الداخلية داخل `MyBox<T>` في هذه الحالة أو في معظم الحالات التي نستخدم فيها معامل فك المرجع.

لاحظ أن معامل `*` يُستبدل بدعوة إلى وسيلة `deref` ثم دعوة إلى معامل `*` مرة واحدة فقط، في كل مرة نستخدم فيها `*` في كودنا. لأن استبدال معامل `*` لا يتكرر بشكل لا نهائي، ينتهي بنا الأمر ببيانات من نوع `i32`، والتي تطابق `5` في `assert_eq!` في القائمة 15-9.

<!-- Old headings. Do not remove or links may break. -->

<a id="implicit-deref-coercions-with-functions-and-methods"></a>
<a id="using-deref-coercions-in-functions-and-methods"></a>

### استخدام التحويل الضمني لفك المرجع في الدوال والوسائل

_التحويل الضمني لفك المرجع_ (Deref coercion) يحول مرجعًا إلى نوع ينفذ سِمة `Deref` إلى مرجع إلى نوع آخر. على سبيل المثال، يمكن للتحويل الضمني لفك المرجع تحويل `&String` إلى `&str` لأن `String` تنفذ سِمة `Deref` بطريقة تعيد `&str`. التحويل الضمني لفك المرجع هو ميزة راحة تؤديها Rust على معاملات الدوال والوسائل، ويعمل فقط على الأنواع التي تنفذ سِمة `Deref`. يحدث تلقائيًا عندما نمرر مرجعًا إلى قيمة نوع معين كمعامل إلى دالة أو وسيلة لا تتطابق مع نوع المعامل في تعريف الدالة أو الوسيلة. تحول سلسلة من الاستدعاءات إلى وسيلة `deref` النوع الذي قدمناه إلى النوع الذي يحتاجه المعامل.

تمت إضافة التحويل الضمني لفك المرجع إلى Rust حتى لا يحتاج المبرمجون الذين يكتبون استدعاءات الدوال والوسائل إلى إضافة العديد من المراجع الصريحة وفك المراجع باستخدام `&` و `*`. تتيح لنا ميزة التحويل الضمني لفك المرجع أيضًا كتابة المزيد من الكود الذي يمكن أن يعمل مع المراجع أو المؤشرات الذكية.

لرؤية التحويل الضمني لفك المرجع في العمل، دعنا نستخدم نوع `MyBox<T>` الذي عرّفناه في القائمة 15-8 بالإضافة إلى تنفيذ `Deref` الذي أضفناه في القائمة 15-10. توضح القائمة 15-11 تعريف دالة لها معامل شريحة نصية (string slice).

<Listing number="15-11" file-name="src/main.rs" caption="دالة `hello` التي لها معامل `name` من نوع `&str`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}
```

</Listing>

يمكننا استدعاء دالة `hello` مع شريحة نصية كمعامل، مثل `hello("Rust");`، على سبيل المثال. التحويل الضمني لفك المرجع يجعل من الممكن استدعاء `hello` بمرجع إلى قيمة من نوع `MyBox<String>`، كما هو موضح في القائمة 15-12.

<Listing number="15-12" file-name="src/main.rs" caption="استدعاء `hello` بمرجع إلى قيمة `MyBox<String>`، والذي يعمل بسبب التحويل الضمني لفك المرجع">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}
```

</Listing>

هنا نستدعي دالة `hello` مع المعامل `&m`، وهو مرجع إلى قيمة `MyBox<String>`. لأننا نفذنا سِمة `Deref` على `MyBox<T>` في القائمة 15-10، يمكن لـ Rust تحويل `&MyBox<String>` إلى `&String` عن طريق استدعاء `deref`. توفر المكتبة القياسية تنفيذًا لـ `Deref` على `String` يعيد شريحة نصية، وهذا في وثائق API لـ `Deref`. تستدعي Rust `deref` مرة أخرى لتحويل `&String` إلى `&str`, والتي تطابق تعريف دالة `hello`.

إذا لم تنفذ Rust التحويل الضمني لفك المرجع، سنضطر لكتابة الكود في القائمة 15-13 بدلاً من الكود في القائمة 15-12 لاستدعاء `hello` بقيمة من نوع `&MyBox<String>`.

<Listing number="15-13" file-name="src/main.rs" caption="الكود الذي سنضطر لكتابته إذا لم يكن لدى Rust التحويل الضمني لفك المرجع">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}
```

</Listing>

`(*m)` يفك مرجع `MyBox<String>` إلى `String`. ثم، يأخذ `&` و `[..]` شريحة نصية من `String` تساوي النص بأكمله لمطابقة توقيع `hello`. هذا الكود بدون التحويلات الضمنية لفك المرجع أصعب في القراءة والكتابة والفهم مع كل هذه الرموز المعنية. يتيح التحويل الضمني لفك المرجع لـ Rust التعامل مع هذه التحويلات لنا تلقائيًا.

عندما يتم تعريف سِمة `Deref` للأنواع المعنية، ستحلل Rust الأنواع وتستخدم `Deref::deref` بقدر ما هو ضروري للحصول على مرجع يطابق نوع المعامل. عدد المرات التي يجب فيها إدراج `Deref::deref` يتم حله في وقت الترجمة، لذلك لا توجد عقوبة أداء في وقت التشغيل للاستفادة من التحويل الضمني لفك المرجع!

<!-- Old headings. Do not remove or links may break. -->

<a id="how-deref-coercion-interacts-with-mutability"></a>

### التعامل مع التحويل الضمني لفك المرجع مع المراجع القابلة للتغيير

بطريقة مشابهة لكيفية استخدام سِمة `Deref` لتجاوز معامل `*` على المراجع غير القابلة للتغيير، يمكنك استخدام سِمة `DerefMut` لتجاوز معامل `*` على المراجع القابلة للتغيير.

تقوم Rust بالتحويل الضمني لفك المرجع عندما تجد أنواعًا وتنفيذات سِمات في ثلاث حالات:

1. من `&T` إلى `&U` عندما `T: Deref<Target=U>`
2. من `&mut T` إلى `&mut U` عندما `T: DerefMut<Target=U>`
3. من `&mut T` إلى `&U` عندما `T: Deref<Target=U>`

الحالتان الأوليان متماثلتان باستثناء أن الثانية تنفذ القابلية للتغيير. تنص الحالة الأولى على أنه إذا كان لديك `&T`، و `T` تنفذ `Deref` إلى نوع `U`، يمكنك الحصول على `&U` بشفافية. تنص الحالة الثانية على أن نفس التحويل الضمني لفك المرجع يحدث للمراجع القابلة للتغيير.

الحالة الثالثة أصعب: ستحول Rust أيضًا مرجعًا قابلًا للتغيير إلى مرجع غير قابل للتغيير. لكن العكس _غير_ ممكن: لن تحول المراجع غير القابلة للتغيير أبدًا إلى مراجع قابلة للتغيير. بسبب قواعد الاستعارة، إذا كان لديك مرجع قابل للتغيير، يجب أن يكون هذا المرجع القابل للتغيير هو المرجع الوحيد لتلك البيانات (وإلا، لن يُترجم البرنامج). تحويل مرجع قابل للتغيير واحد إلى مرجع غير قابل للتغيير واحد لن يكسر أبدًا قواعد الاستعارة. تحويل مرجع غير قابل للتغيير إلى مرجع قابل للتغيير سيتطلب أن يكون المرجع غير القابل للتغيير الأولي هو المرجع غير القابل للتغيير الوحيد لتلك البيانات، لكن قواعد الاستعارة لا تضمن ذلك. لذلك، لا يمكن لـ Rust وضع افتراض أن تحويل مرجع غير قابل للتغيير إلى مرجع قابل للتغيير ممكن.

[impl-trait]: ch10-02-traits.html#implementing-a-trait-on-a-type
[tuple-structs]: ch05-01-defining-structs.html#creating-different-types-with-tuple-structs
