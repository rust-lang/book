## الأنواع المتقدمة

نظام الأنواع في Rust لديه بعض الميزات التي ذكرناها حتى الآن ولكن لم نناقشها بعد. سنبدأ بمناقشة newtypes بشكل عام بينما نفحص لماذا هي مفيدة كأنواع. ثم سننتقل إلى الأسماء المستعارة للأنواع (type aliases)، وهي ميزة مشابهة لـ newtypes ولكن بدلالات مختلفة قليلاً. سنناقش أيضًا نوع `!` والأنواع ذات الحجم الديناميكي.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-the-newtype-pattern-for-type-safety-and-abstraction"></a>

### أمان الأنواع والتجريد مع نمط Newtype

يفترض هذا القسم أنك قرأت القسم السابق ["تطبيق السِمَات الخارجية مع نمط Newtype"][newtype]<!-- ignore -->. نمط newtype مفيد أيضًا للمهام بعيدًا عما ناقشناه حتى الآن، بما في ذلك فرض أمان الأنواع بشكل ثابت بأن القيم لا يتم الخلط بينها أبدًا والإشارة إلى وحدات القيمة. رأيت مثالاً على استخدام newtypes للإشارة إلى الوحدات في القائمة 20-16: تذكر أن بنيات `Millimeters` و `Meters` غلفت قيم `u32` في newtype. إذا كتبنا دالة بمعامل من نوع `Millimeters`، لن نتمكن من ترجمة برنامج يحاول عن طريق الخطأ استدعاء تلك الدالة بقيمة من نوع `Meters` أو `u32` عادي.

يمكننا أيضًا استخدام نمط newtype لتجريد بعض تفاصيل التطبيق لنوع: يمكن للنوع الجديد الكشف عن API عام مختلف عن API النوع الداخلي الخاص.

يمكن لـ Newtypes أيضًا إخفاء التطبيق الداخلي. على سبيل المثال، يمكننا توفير نوع `People` لتغليف `HashMap<i32, String>` الذي يخزن معرف شخص مرتبط باسمه. الكود الذي يستخدم `People` سيتفاعل فقط مع API العام الذي نوفره، مثل طريقة لإضافة سلسلة اسم إلى مجموعة `People`؛ لن يحتاج هذا الكود إلى معرفة أننا نخصص معرف `i32` للأسماء داخليًا. نمط newtype هو طريقة خفيفة لتحقيق التغليف (encapsulation) لإخفاء تفاصيل التطبيق، والتي ناقشناها في قسم ["التغليف الذي يخفي تفاصيل التطبيق"][encapsulation-that-hides-implementation-details]<!-- ignore --> في الفصل 18.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-type-synonyms-with-type-aliases"></a>

### المرادفات والأسماء المستعارة للأنواع

يوفر Rust القدرة على التصريح عن _اسم مستعار للنوع_ (type alias) لإعطاء نوع موجود اسمًا آخر. لهذا نستخدم الكلمة المفتاحية `type`. على سبيل المثال، يمكننا إنشاء الاسم المستعار `Kilometers` لـ `i32` هكذا:

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}
```

الآن الاسم المستعار `Kilometers` هو _مرادف_ (synonym) لـ `i32`؛ على عكس أنواع `Millimeters` و `Meters` التي أنشأناها في القائمة 20-16، `Kilometers` ليس نوعًا منفصلاً جديدًا. القيم التي لها النوع `Kilometers` ستُعامل بنفس طريقة معاملة قيم النوع `i32`:

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}
```

لأن `Kilometers` و `i32` هما نفس النوع، يمكننا إضافة قيم من كلا النوعين ويمكننا تمرير قيم `Kilometers` إلى دوال تأخذ معاملات `i32`. ومع ذلك، باستخدام هذه الطريقة، لا نحصل على فوائد فحص الأنواع التي نحصل عليها من نمط newtype الذي ناقشناه سابقًا. بمعنى آخر، إذا خلطنا قيم `Kilometers` و `i32` في مكان ما، لن يعطينا المصرِّف خطأ.

حالة الاستخدام الرئيسية للمرادفات النوع هي تقليل التكرار. على سبيل المثال، قد يكون لدينا نوع طويل مثل هذا:

```rust,ignore
Box<dyn Fn() + Send + 'static>
```

كتابة هذا النوع الطويل في توقيعات الدوال وكتعليقات النوع في جميع أنحاء الكود يمكن أن يكون متعبًا وعرضة للأخطاء. تخيل وجود مشروع مليء بكود مثل ذلك في القائمة 20-25.

<Listing number="20-25" caption="استخدام نوع طويل في أماكن كثيرة">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-25/src/main.rs:here}}
```

</Listing>

الاسم المستعار للنوع يجعل هذا الكود أكثر قابلية للإدارة من خلال تقليل التكرار. في القائمة 20-26، قدمنا اسمًا مستعارًا يُسمى `Thunk` للنوع المطول ويمكننا استبدال جميع استخدامات النوع بالاسم المستعار الأقصر `Thunk`.

<Listing number="20-26" caption="تقديم اسم مستعار للنوع، `Thunk`، لتقليل التكرار">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-26/src/main.rs:here}}
```

</Listing>

هذا الكود أسهل بكثير للقراءة والكتابة! اختيار اسم ذي معنى للاسم المستعار للنوع يمكن أن يساعد في توصيل نيتك أيضًا (_thunk_ هي كلمة للكود الذي سيتم تقييمه في وقت لاحق، لذلك إنه اسم مناسب لإغلاق يتم تخزينه).

تُستخدم الأسماء المستعارة للأنواع أيضًا بشكل شائع مع النوع `Result<T, E>` لتقليل التكرار. ضع في اعتبارك وحدة `std::io` في المكتبة القياسية. عمليات الإدخال/الإخراج غالبًا ما تعيد `Result<T, E>` للتعامل مع المواقف عندما تفشل العمليات في العمل. لدى هذه المكتبة بنية `std::io::Error` التي تمثل جميع أخطاء الإدخال/الإخراج الممكنة. العديد من الدوال في `std::io` ستعيد `Result<T, E>` حيث `E` هو `std::io::Error`، مثل هذه الدوال في سِمَة `Write`:

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-05-write-trait/src/lib.rs}}
```

يتكرر `Result<..., Error>` كثيرًا. على هذا النحو، لدى `std::io` تصريح الاسم المستعار للنوع هذا:

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}
```

لأن هذا التصريح في وحدة `std::io`، يمكننا استخدام الاسم المستعار المؤهل بالكامل `std::io::Result<T>`؛ أي، `Result<T, E>` مع ملء `E` بـ `std::io::Error`. توقيعات دالة سِمَة `Write` ينتهي بها الأمر بأن تبدو هكذا:

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}
```

الاسم المستعار للنوع يساعد بطريقتين: يجعل الكود أسهل للكتابة _ويعطينا_ واجهة متسقة عبر كل `std::io`. لأنه اسم مستعار، إنه فقط `Result<T, E>` آخر، مما يعني أنه يمكننا استخدام أي طرق تعمل على `Result<T, E>` معه، بالإضافة إلى بناء جملة خاص مثل معامل `?`.

### نوع Never الذي لا يعود أبدًا

لدى Rust نوع خاص يُسمى `!` والذي يُعرف في مصطلحات نظرية الأنواع بـ _النوع الفارغ_ (empty type) لأنه ليس لديه قيم. نفضل أن نسميه _نوع never_ (never type) لأنه يقف في مكان نوع الإرجاع عندما لا تعود دالة أبدًا. إليك مثال:

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-07-never-type/src/lib.rs:here}}
```

يُقرأ هذا الكود على أنه "الدالة `bar` تعيد never". الدوال التي تعيد never تُسمى _الدوال المتباعدة_ (diverging functions). لا يمكننا إنشاء قيم من النوع `!`، لذلك لا يمكن لـ `bar` أن تعود أبدًا.

ولكن ما فائدة نوع لا يمكنك إنشاء قيم له أبدًا؟ تذكر الكود من القائمة 2-5، وهو جزء من لعبة تخمين الأرقام؛ لقد أعدنا إنتاج جزء منه هنا في القائمة 20-27.

<Listing number="20-27" caption="`match` بذراع ينتهي بـ `continue`">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}
```

</Listing>

في ذلك الوقت، تخطينا بعض التفاصيل في هذا الكود. في قسم ["بناء التحكم في التدفق `match`"][the-match-control-flow-construct]<!-- ignore --> في الفصل 6، ناقشنا أن أذرع `match` يجب أن تعيد جميعها نفس النوع. لذلك، على سبيل المثال، الكود التالي لا يعمل:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}
```

يجب أن يكون نوع `guess` في هذا الكود عددًا صحيحًا _وسلسلة_، ويتطلب Rust أن يكون لدى `guess` نوع واحد فقط. إذن، ماذا يعيد `continue`؟ كيف سُمح لنا بإرجاع `u32` من ذراع واحد ويكون لدينا ذراع آخر ينتهي بـ `continue` في القائمة 20-27؟

كما قد خمنت، لدى `continue` قيمة `!`. أي، عندما يحسب Rust نوع `guess`، ينظر إلى كلا ذراعي match، الأول بقيمة `u32` والأخير بقيمة `!`. لأن `!` لا يمكن أن يكون له قيمة أبدًا، يقرر Rust أن نوع `guess` هو `u32`.

الطريقة الرسمية لوصف هذا السلوك هي أن التعبيرات من النوع `!` يمكن إجبارها على أي نوع آخر. يُسمح لنا بإنهاء ذراع `match` هذا بـ `continue` لأن `continue` لا يعيد قيمة؛ بدلاً من ذلك، ينقل التحكم مرة أخرى إلى أعلى الحلقة، لذلك في حالة `Err`، لا نخصص قيمة لـ `guess` أبدًا.

نوع never مفيد أيضًا مع ماكرو `panic!`. تذكر دالة `unwrap` التي نستدعيها على قيم `Option<T>` لإنتاج قيمة أو panic بهذا التعريف:

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}
```

في هذا الكود، يحدث نفس الشيء كما في `match` في القائمة 20-27: يرى Rust أن `val` لديه النوع `T` و `panic!` لديه النوع `!`، لذلك نتيجة تعبير `match` الكلي هي `T`. يعمل هذا الكود لأن `panic!` لا ينتج قيمة؛ إنه ينهي البرنامج. في حالة `None`، لن نعيد قيمة من `unwrap`، لذلك هذا الكود صحيح.

تعبير نهائي واحد لديه النوع `!` هو `loop`:

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}
```

هنا، الحلقة لا تنتهي أبدًا، لذلك `!` هي قيمة التعبير. ومع ذلك، لن يكون هذا صحيحًا إذا ضمّنا `break`، لأن الحلقة ستنتهي عندما تصل إلى `break`.

### الأنواع ذات الحجم الديناميكي وسِمَة `Sized`

يحتاج Rust إلى معرفة تفاصيل معينة حول أنواعه، مثل كم مساحة لتخصيصها لقيمة من نوع معين. هذا يترك ركنًا واحدًا من نظام الأنواع مربكًا قليلاً في البداية: مفهوم _الأنواع ذات الحجم الديناميكي_ (dynamically sized types). يُشار إليها أحيانًا بـ _DSTs_ أو _أنواع بدون حجم_ (unsized types)، هذه الأنواع تتيح لنا كتابة كود باستخدام قيم لا يمكننا معرفة حجمها إلا في وقت التشغيل.

دعنا نتعمق في تفاصيل نوع ديناميكي الحجم يُسمى `str`, والذي استخدمناه في جميع أنحاء الكتاب. هذا صحيح، وليس `&str`، ولكن `str` بمفرده، هو DST. في كثير من الحالات، مثل تخزين نص مُدخل من قبل المستخدم، لا يمكننا معرفة طول السلسلة حتى وقت التشغيل. هذا يعني أنه لا يمكننا إنشاء متغير من النوع `str`، ولا يمكننا أخذ وسيطة من النوع `str`. ضع في اعتبارك الكود التالي، الذي لا يعمل:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}
```

يحتاج Rust إلى معرفة كم ذاكرة لتخصيصها لأي قيمة من نوع معين، ويجب على جميع قيم النوع استخدام نفس كمية الذاكرة. إذا سمح Rust لنا بكتابة هذا الكود، ستحتاج قيمتا `str` هاتان إلى شغل نفس كمية المساحة. لكن لديهما أطوال مختلفة: `s1` يحتاج إلى 12 بايت من التخزين و `s2` يحتاج إلى 15. هذا هو السبب في أنه من غير الممكن إنشاء متغير يحمل نوعًا ديناميكي الحجم.

إذن، ماذا نفعل؟ في هذه الحالة، تعرف الإجابة بالفعل: نجعل نوع `s1` و `s2` شريحة سلسلة (`&str`) بدلاً من `str`. تذكر من قسم ["شرائح السلاسل"][string-slices]<!-- ignore --> في الفصل 4 أن بنية بيانات الشريحة تخزن فقط موضع البداية وطول الشريحة. لذلك، على الرغم من أن `&T` هي قيمة واحدة تخزن عنوان الذاكرة حيث يوجد `T`، فإن شريحة السلسلة هي _قيمتان_: عنوان `str` وطولها. على هذا النحو، يمكننا معرفة حجم قيمة شريحة السلسلة في وقت الترجمة: إنها ضعف طول `usize`. أي، نعرف دائمًا حجم شريحة السلسلة، بغض النظر عن طول السلسلة التي تشير إليها. بشكل عام، هذه هي الطريقة التي يتم بها استخدام الأنواع ذات الحجم الديناميكي في Rust: لديها قطعة إضافية من البيانات الوصفية التي تخزن حجم المعلومات الديناميكية. القاعدة الذهبية للأنواع ذات الحجم الديناميكي هي أنه يجب علينا دائمًا وضع قيم الأنواع ذات الحجم الديناميكي خلف مؤشر من نوع ما.

يمكننا دمج `str` مع جميع أنواع المؤشرات: على سبيل المثال، `Box<str>` أو `Rc<str>`. في الواقع، رأيت هذا من قبل ولكن مع نوع ديناميكي الحجم مختلف: السِمَات. كل سِمَة هي نوع ديناميكي الحجم يمكننا الإشارة إليه باستخدام اسم السِمَة. في قسم ["استخدام كائنات السِمَات للتجريد فوق السلوك المشترك"][using-trait-objects-to-abstract-over-shared-behavior]<!-- ignore --> في الفصل 18، ذكرنا أنه لاستخدام السِمَات ككائنات سِمَة، يجب أن نضعها خلف مؤشر، مثل `&dyn Trait` أو `Box<dyn Trait>` (`Rc<dyn Trait>` سيعمل أيضًا).

للعمل مع DSTs، يوفر Rust سِمَة `Sized` لتحديد ما إذا كان حجم النوع معروفًا في وقت الترجمة أم لا. يتم تطبيق هذه السِمَة تلقائيًا لكل شيء حجمه معروف في وقت الترجمة. بالإضافة إلى ذلك، يضيف Rust ضمنيًا قيدًا على `Sized` لكل دالة عامة. أي، تعريف دالة عامة مثل هذا:

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}
```

يُعامل في الواقع كما لو كنا كتبنا هذا:

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}
```

افتراضيًا، ستعمل الدوال العامة فقط على الأنواع التي لها حجم معروف في وقت الترجمة. ومع ذلك، يمكنك استخدام بناء الجملة الخاص التالي للتخفيف من هذا القيد:

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}
```

قيد السِمَة على `?Sized` يعني "`T` قد يكون أو لا يكون `Sized`"، وهذا التدوين يتجاوز الافتراضي بأن الأنواع العمومية يجب أن يكون لها حجم معروف في وقت الترجمة. بناء الجملة `?Trait` بهذا المعنى متاح فقط لـ `Sized`، وليس لأي سِمَات أخرى.

لاحظ أيضًا أننا غيرنا نوع معامل `t` من `T` إلى `&T`. لأن النوع قد لا يكون `Sized`، نحتاج إلى استخدامه خلف نوع من المؤشرات. في هذه الحالة، اخترنا مرجعًا.

بعد ذلك، سنتحدث عن الدوال والإغلاقات!

[encapsulation-that-hides-implementation-details]: ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details
[string-slices]: ch04-03-slices.html#string-slices
[the-match-control-flow-construct]: ch06-02-match.html#the-match-control-flow-construct
[using-trait-objects-to-abstract-over-shared-behavior]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior
[newtype]: ch20-02-advanced-traits.html#implementing-external-traits-with-the-newtype-pattern
