## تحسين مشروع الإدخال/الإخراج الخاص بنا

مع هذه المعرفة الجديدة حول المُكرِّرات، يمكننا تحسين مشروع الإدخال/الإخراج في الفصل 12 باستخدام المُكرِّرات لجعل الأماكن في الكود أوضح وأكثر إيجازًا. دعنا ننظر إلى كيف يمكن للمُكرِّرات تحسين تنفيذنا لدالة `Config::build` ودالة `search`.

### إزالة `clone` باستخدام مُكرِّر

في القائمة 12-6، أضفنا كودًا أخذ شريحة من قيم `String` وأنشأ نسخة من بنية `Config` عن طريق الفهرسة في الشريحة ونسخ القيم، مما يسمح لبنية `Config` بامتلاك تلك القيم. في القائمة 13-17، أعدنا إنتاج تنفيذ دالة `Config::build` كما كانت في القائمة 12-23.

<Listing number="13-17" file-name="src/main.rs" caption="إعادة إنتاج دالة `Config::build` من القائمة 12-23">

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/main.rs:ch13}}
```

</Listing>

في ذلك الوقت، قلنا أن لا داعي للقلق بشأن استدعاءات `clone` غير الفعالة لأننا سنزيلها في المستقبل. حسنًا، هذا الوقت هو الآن!

احتجنا إلى `clone` هنا لأن لدينا شريحة مع عناصر `String` في المعامل `args`، لكن دالة `build` لا تمتلك `args`. لإعادة ملكية نسخة `Config`، كان علينا نسخ القيم من حقلي `query` و `file_path` في `Config` بحيث يمكن لنسخة `Config` امتلاك قيمها.

مع معرفتنا الجديدة حول المُكرِّرات، يمكننا تغيير دالة `build` لأخذ ملكية مُكرِّر كوسيط بدلاً من استعارة شريحة. سنستخدم وظيفة المُكرِّر بدلاً من الكود الذي يتحقق من طول الشريحة ويفهرس في مواقع محددة. سيوضح هذا ما تفعله دالة `Config::build` لأن المُكرِّر سيصل إلى القيم.

بمجرد أن تأخذ `Config::build` ملكية المُكرِّر وتتوقف عن استخدام عمليات الفهرسة التي تستعير، يمكننا نقل قيم `String` من المُكرِّر إلى `Config` بدلاً من استدعاء `clone` وإجراء تخصيص جديد.

#### استخدام المُكرِّر المعاد مباشرة

افتح ملف _src/main.rs_ لمشروع الإدخال/الإخراج الخاص بك، والذي يجب أن يبدو كالتالي:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
```

سنغير أولاً بداية دالة `main` التي كانت لدينا في القائمة 12-24 إلى الكود في القائمة 13-18، والذي يستخدم هذه المرة مُكرِّرًا. لن يترجم هذا حتى نقوم بتحديث `Config::build` أيضًا.

<Listing number="13-18" file-name="src/main.rs" caption="تمرير قيمة الإرجاع من `env::args` إلى `Config::build`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}
```

</Listing>

تعيد دالة `env::args` مُكرِّرًا! بدلاً من جمع قيم المُكرِّر في متجه ثم تمرير شريحة إلى `Config::build`، نمرر الآن ملكية المُكرِّر المعاد من `env::args` إلى `Config::build` مباشرة.

بعد ذلك، نحتاج إلى تحديث تعريف `Config::build`. دعنا نغير توقيع `Config::build` ليبدو مثل القائمة 13-19. لن يترجم هذا بعد، لأننا بحاجة إلى تحديث جسم الدالة.

<Listing number="13-19" file-name="src/main.rs" caption="تحديث توقيع `Config::build` لتوقع مُكرِّرًا">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/main.rs:here}}
```

</Listing>

يُظهر توثيق المكتبة القياسية لدالة `env::args` أن نوع المُكرِّر الذي تعيده هو `std::env::Args`، وأن هذا النوع ينفذ سِمَة `Iterator` ويعيد قيم `String`.

قمنا بتحديث توقيع دالة `Config::build` بحيث يكون للمعامل `args` نوع عام مع قيود السِمَة `impl Iterator<Item = String>` بدلاً من `&[String]`. يعني استخدام صيغة `impl Trait` الذي ناقشناه في قسم ["استخدام السِمات كمعاملات"][impl-trait]<!-- ignore --> من الفصل 10 أن `args` يمكن أن يكون أي نوع ينفذ سِمَة `Iterator` ويعيد عناصر `String`.

نظرًا لأننا نأخذ ملكية `args` وسنقوم بتغيير `args` عن طريق التكرار عليه، يمكننا إضافة الكلمة المفتاحية `mut` إلى مواصفات معامل `args` لجعله قابلاً للتغيير.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-iterator-trait-methods-instead-of-indexing"></a>

#### استخدام دوال سِمَة `Iterator`

بعد ذلك، سنصلح جسم `Config::build`. نظرًا لأن `args` ينفذ سِمَة `Iterator`، نعلم أنه يمكننا استدعاء دالة `next` عليه! تحدث القائمة 13-20 الكود من القائمة 12-23 لاستخدام دالة `next`.

<Listing number="13-20" file-name="src/main.rs" caption="تغيير جسم `Config::build` لاستخدام دوال المُكرِّر">

```rust,ignore,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/main.rs:here}}
```

</Listing>

تذكر أن القيمة الأولى في قيمة الإرجاع من `env::args` هي اسم البرنامج. نريد تجاهل ذلك والانتقال إلى القيمة التالية، لذا نستدعي أولاً `next` ولا نفعل شيئًا بقيمة الإرجاع. ثم نستدعي `next` للحصول على القيمة التي نريد وضعها في حقل `query` من `Config`. إذا أعاد `next` قيمة `Some`، نستخدم `match` لاستخراج القيمة. إذا أعاد `None`، فهذا يعني أنه لم يتم إعطاء وسائط كافية، ونعود مبكرًا بقيمة `Err`. نفعل نفس الشيء لقيمة `file_path`.

<!-- Old headings. Do not remove or links may break. -->

<a id="making-code-clearer-with-iterator-adapters"></a>

### توضيح الكود باستخدام محولات المُكرِّرات

يمكننا أيضًا الاستفادة من المُكرِّرات في دالة `search` في مشروع الإدخال/الإخراج الخاص بنا، والتي أعيد إنتاجها هنا في القائمة 13-21 كما كانت في القائمة 12-19.

<Listing number="13-21" file-name="src/lib.rs" caption="تنفيذ دالة `search` من القائمة 12-19">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}
```

</Listing>

يمكننا كتابة هذا الكود بطريقة أكثر إيجازًا باستخدام دوال محول المُكرِّر. يتيح لنا القيام بذلك أيضًا تجنب وجود متجه `results` وسيط قابل للتغيير. يفضل نمط البرمجة الوظيفي تقليل كمية الحالة القابلة للتغيير لجعل الكود أوضح. إزالة الحالة القابلة للتغيير قد تمكّن من تحسين مستقبلي لجعل البحث يحدث بشكل متوازي لأننا لن نضطر إلى إدارة الوصول المتزامن إلى متجه `results`. توضح القائمة 13-22 هذا التغيير.

<Listing number="13-22" file-name="src/lib.rs" caption="استخدام دوال محول المُكرِّر في تنفيذ دالة `search`">

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}
```

</Listing>

تذكر أن غرض دالة `search` هو إعادة جميع الأسطر في `contents` التي تحتوي على `query`. على غرار مثال `filter` في القائمة 13-16، يستخدم هذا الكود محول `filter` للاحتفاظ فقط بالأسطر التي يعيد لها `line.contains(query)` قيمة `true`. ثم نجمع الأسطر المطابقة في متجه آخر باستخدام `collect`. أبسط بكثير! لا تتردد في إجراء نفس التغيير لاستخدام دوال المُكرِّر في دالة `search_case_insensitive` أيضًا.

لتحسين إضافي، أعد مُكرِّرًا من دالة `search` عن طريق إزالة الاستدعاء إلى `collect` وتغيير نوع الإرجاع إلى `impl Iterator<Item = &'a str>` بحيث تصبح الدالة محول مُكرِّر. لاحظ أنك ستحتاج أيضًا إلى تحديث الاختبارات! ابحث في ملف كبير باستخدام أداة `minigrep` الخاصة بك قبل وبعد إجراء هذا التغيير لمراقبة الفرق في السلوك. قبل هذا التغيير، لن يطبع البرنامج أي نتائج حتى يجمع كل النتائج، ولكن بعد التغيير، ستتم طباعة النتائج عندما يتم العثور على كل سطر مطابق لأن حلقة `for` في دالة `run` قادرة على الاستفادة من كسل المُكرِّر.

<!-- Old headings. Do not remove or links may break. -->

<a id="choosing-between-loops-or-iterators"></a>

### الاختيار بين الحلقات والمُكرِّرات

السؤال المنطقي التالي هو أي أسلوب يجب أن تختاره في كودك الخاص ولماذا: التنفيذ الأصلي في القائمة 13-21 أو الإصدار باستخدام المُكرِّرات في القائمة 13-22 (بافتراض أننا نجمع كل النتائج قبل إعادتها بدلاً من إعادة المُكرِّر). يفضل معظم مبرمجي Rust استخدام أسلوب المُكرِّر. إنه أصعب قليلاً في البداية، لكن بمجرد أن تتعود على محولات المُكرِّر المختلفة وما تفعله، يمكن أن تكون المُكرِّرات أسهل في الفهم. بدلاً من العبث بأجزاء مختلفة من الحلقات وبناء متجهات جديدة، يركز الكود على الهدف عالي المستوى للحلقة. يستخلص هذا بعض الكود الشائع بحيث يكون من الأسهل رؤية المفاهيم الفريدة لهذا الكود، مثل شرط التصفية الذي يجب أن يمر به كل عنصر في المُكرِّر.

ولكن هل التنفيذان متكافئان حقًا؟ قد يكون الافتراض الحدسي هو أن الحلقة ذات المستوى الأدنى ستكون أسرع. دعنا نتحدث عن الأداء.

[impl-trait]: ch10-02-traits.html#traits-as-parameters
