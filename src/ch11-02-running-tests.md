## التحكم في كيفية تشغيل الاختبارات (Controlling How Tests Are Run)

تمامًا كما يقوم `cargo run` بتجميع الكود ثم تشغيل الملف الثنائي الناتج،
يقوم `cargo test` بتجميع الكود في وضع الاختبار (test mode) وتشغيل الملف الثنائي
الاختباري (test binary) الناتج. السلوك الافتراضي للملف الثنائي الذي ينتجه `cargo test` هو تشغيل
جميع الاختبارات بشكل متوازٍ والتقاط المخرجات المُولَّدة أثناء تشغيل الاختبارات،
مما يمنع عرض المخرجات ويجعل قراءة
المخرجات المتعلقة بنتائج الاختبارات أسهل. يمكنك، مع ذلك، تحديد خيارات سطر الأوامر
لتغيير هذا السلوك الافتراضي.

بعض خيارات سطر الأوامر (command line options) تذهب إلى `cargo test`، والبعض الآخر يذهب إلى الملف الثنائي
الاختباري الناتج. لفصل هذين النوعين من الوسائط (arguments)، تُدرج الوسائط (arguments) التي
تذهب إلى `cargo test` متبوعة بالفاصل `--` ثم تلك التي تذهب إلى
الملف الثنائي الاختباري (test binary). يعرض تشغيل `cargo test --help` الخيارات التي يمكنك استخدامها
مع `cargo test`، ويعرض تشغيل `cargo test -- --help` الخيارات التي يمكنك
استخدامها بعد الفاصل. هذه الخيارات موثقة أيضًا في [قسم "الاختبارات"
من _كتاب `rustc`_][tests].

[tests]: https://doc.rust-lang.org/rustc/tests/index.html

### تشغيل الاختبارات بشكل متوازٍ أو متتالٍ

عندما تقوم بتشغيل اختبارات متعددة، فإنها تعمل بشكل متوازٍ افتراضيًا باستخدام خيوط،
مما يعني أنها تنتهي من التشغيل بسرعة أكبر وتحصل على ملاحظات أسرع. نظرًا لأن
الاختبارات تعمل في نفس الوقت، يجب عليك التأكد من أن اختباراتك لا
تعتمد على بعضها البعض أو على أي حالة مشتركة، بما في ذلك بيئة مشتركة،
مثل دليل العمل الحالي أو متغيرات البيئة.

على سبيل المثال، لنفترض أن كل من اختباراتك يقوم بتشغيل بعض الكود الذي ينشئ ملفًا على القرص
باسم _test-output.txt_ ويكتب بعض البيانات في هذا الملف. ثم، يقرأ كل اختبار
البيانات الموجودة في ذلك الملف ويؤكد أن الملف يحتوي على قيمة معينة، والتي تختلف في كل اختبار. نظرًا لأن الاختبارات تعمل في نفس الوقت،
قد يستبدل أحد الاختبارات الملف في الوقت الذي يكتب فيه اختبار آخر ويقرأ الملف. سيفشل الاختبار الثاني عندها، ليس لأن
الكود غير صحيح ولكن لأن الاختبارات تداخلت مع بعضها البعض أثناء
التشغيل بشكل متوازٍ. أحد الحلول هو التأكد من أن كل اختبار يكتب إلى
ملف مختلف؛ الحل الآخر هو تشغيل الاختبارات واحدًا تلو الآخر.

إذا كنت لا تريد تشغيل الاختبارات بشكل متوازٍ أو إذا كنت تريد مزيدًا من التحكم الدقيق
في عدد الخيوط المستخدمة، يمكنك إرسال علامة `--test-threads`
وعدد الخيوط التي تريد استخدامها إلى الملف الثنائي الاختباري. ألقِ نظرة على
المثال التالي:

```console
$ cargo test -- --test-threads=1
```

نقوم بتعيين عدد خيوط الاختبار إلى `1`، مما يخبر البرنامج بعدم استخدام أي
تشغيل متوازٍ. سيستغرق تشغيل الاختبارات باستخدام خيط واحد وقتًا أطول من تشغيلها
بشكل متوازٍ، لكن الاختبارات لن تتداخل مع بعضها البعض إذا كانت تشترك في
حالة.

### عرض مخرجات الدالة

افتراضيًا، إذا نجح اختبار، تلتقط مكتبة اختبار Rust أي شيء يُطبع إلى
المخرجات القياسية. على سبيل المثال، إذا استدعينا `println!` في اختبار ونجح الاختبار،
فلن نرى مخرجات `println!` في الطرفية؛ سنرى فقط
السطر الذي يشير إلى أن الاختبار نجح. إذا فشل اختبار، فسنرى أيًا كان ما تمت
طباعته إلى المخرجات القياسية مع باقي رسالة الفشل.

كمثال، يحتوي القائمة 11-10 على دالة بسيطة تطبع قيمة
معاملها وترجع 10، بالإضافة إلى اختبار ينجح واختبار يفشل.

<Listing number="11-10" file-name="src/lib.rs" caption="اختبارات لدالة تستدعي `println!`">

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-10/src/lib.rs}}
```

</Listing>

عندما نقوم بتشغيل هذه الاختبارات باستخدام `cargo test`، سنرى المخرجات التالية:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-10/output.txt}}
```

لاحظ أنه في أي مكان في هذه المخرجات لا نرى `I got the value 4`، والتي تُطبع
عندما يتم تشغيل الاختبار الذي ينجح. تم التقاط تلك المخرجات. تظهر
المخرجات من الاختبار الذي فشل، `I got the value 8`، في قسم
ملخص الاختبار، والذي يُظهر أيضًا سبب فشل الاختبار.

إذا أردنا رؤية القيم المطبوعة للاختبارات الناجحة أيضًا، يمكننا إخبار Rust بـ
إظهار مخرجات الاختبارات الناجحة أيضًا باستخدام `--show-output`:

```console
$ cargo test -- --show-output
```

عندما نقوم بتشغيل الاختبارات في القائمة 11-10 مرة أخرى مع علامة `--show-output`، سنرى
المخرجات التالية:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-01-show-output/output.txt}}
```

### تشغيل مجموعة فرعية من الاختبارات بالاسم

يمكن أن يستغرق تشغيل مجموعة اختبار كاملة وقتًا طويلاً أحيانًا. إذا كنت تعمل على
كود في منطقة معينة، فقد ترغب في تشغيل الاختبارات المتعلقة بذلك
الكود فقط. يمكنك اختيار الاختبارات التي تريد تشغيلها عن طريق تمرير `cargo test` اسم
أو أسماء الاختبار (الاختبارات) التي تريد تشغيلها كوسيطة.

لإظهار كيفية تشغيل مجموعة فرعية من الاختبارات، سننشئ أولاً ثلاثة اختبارات لـ
دالتنا `add_two`، كما هو موضح في القائمة 11-11، ونختار أي منها نريد تشغيله.

<Listing number="11-11" file-name="src/lib.rs" caption="ثلاثة اختبارات بثلاثة أسماء مختلفة">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-11/src/lib.rs}}
```

</Listing>

إذا قمنا بتشغيل الاختبارات دون تمرير أي وسائط، كما رأينا سابقًا، فستعمل جميع
الاختبارات بشكل متوازٍ:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-11/output.txt}}
```

#### تشغيل اختبارات فردية

يمكننا تمرير اسم أي دالة اختبار إلى `cargo test` لتشغيل ذلك الاختبار فقط:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-02-single-test/output.txt}}
```

تم تشغيل الاختبار ذي الاسم `one_hundred` فقط؛ الاختباران الآخران لم يطابقا
ذلك الاسم. تُخبرنا مخرجات الاختبار أن لدينا اختبارات إضافية لم يتم تشغيلها من خلال
عرض `2 filtered out` في النهاية.

لا يمكننا تحديد أسماء اختبارات متعددة بهذه الطريقة؛ سيتم استخدام القيمة الأولى فقط
المُعطاة إلى `cargo test`. ولكن هناك طريقة لتشغيل اختبارات متعددة.

#### التصفية لتشغيل اختبارات متعددة

يمكننا تحديد جزء من اسم اختبار، وسيتم تشغيل أي اختبار يطابق اسمه تلك القيمة. على سبيل المثال، نظرًا لأن اثنين من أسماء اختباراتنا يحتويان على `add`، يمكننا
تشغيل هذين الاختبارين عن طريق تشغيل `cargo test add`:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-03-multiple-tests/output.txt}}
```

قام هذا الأمر بتشغيل جميع الاختبارات التي تحتوي على `add` في الاسم وصفى الاختبار
المسمى `one_hundred`. لاحظ أيضًا أن الوحدة التي يظهر فيها الاختبار تصبح
جزءًا من اسم الاختبار، لذلك يمكننا تشغيل جميع الاختبارات في وحدة عن طريق التصفية
على اسم الوحدة.

<!-- Old headings. Do not remove or links may break. -->

<a id="ignoring-some-tests-unless-specifically-requested"></a>

### تجاهل الاختبارات إلا عند الطلب صراحة

في بعض الأحيان يمكن أن تستغرق بعض الاختبارات المحددة وقتًا طويلاً للتنفيذ، لذلك قد
ترغب في استبعادها أثناء معظم تشغيلات `cargo test`. بدلاً من
إدراج جميع الاختبارات التي تريد تشغيلها كوسائط، يمكنك بدلاً من ذلك وضع تعليق توضيحي على
الاختبارات التي تستغرق وقتًا طويلاً باستخدام خاصية `ignore` لاستبعادها، كما هو موضح
هنا:

<span class="filename">اسم الملف: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/src/lib.rs:here}}
```

بعد `#[test]`، نضيف السطر `#[ignore]` إلى الاختبار الذي نريد استبعاده.
الآن عندما نقوم بتشغيل اختباراتنا، يعمل `it_works`، لكن `expensive_test` لا يعمل:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/output.txt}}
```

تُدرج دالة `expensive_test` على أنها `ignored`. إذا أردنا تشغيل
الاختبارات المُتجاهَلة فقط، يمكننا استخدام `cargo test -- --ignored`:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-04-running-ignored/output.txt}}
```

من خلال التحكم في الاختبارات التي يتم تشغيلها، يمكنك التأكد من أن نتائج `cargo test` الخاصة بك
سيتم إرجاعها بسرعة. عندما تكون في نقطة من المنطقي فيها التحقق من
نتائج الاختبارات `ignored` ولديك وقت للانتظار للحصول على النتائج،
يمكنك تشغيل `cargo test -- --ignored` بدلاً من ذلك. إذا كنت تريد تشغيل جميع الاختبارات
سواء كانت متجاهَلة أم لا، يمكنك تشغيل `cargo test -- --include-ignored`.
