## السِمَات المتقدمة (Advanced Traits)

تناولنا السِمَات أولاً في قسم ["تعريف السلوك المشترك مع السِمَات"][traits]<!-- ignore --> في الفصل 10، لكننا لم نناقش التفاصيل الأكثر تقدمًا. الآن بعد أن عرفت المزيد عن Rust، يمكننا الدخول في التفاصيل الدقيقة.

<!-- Old headings. Do not remove or links may break. -->

<a id="specifying-placeholder-types-in-trait-definitions-with-associated-types"></a>
<a id="associated-types"></a>

### تعريف السِمَات مع الأنواع المرتبطة

_الأنواع المرتبطة_ (Associated types) تربط نائب نوع (type placeholder) مع سِمَة بحيث يمكن لتعريفات طرق السِمَة استخدام هذه الأنواع النائبة في توقيعاتها. سيحدد منفذ السِمَة النوع الملموس الذي سيُستخدم بدلاً من النوع النائب للتطبيق المعين. بهذه الطريقة، يمكننا تعريف سِمَة تستخدم بعض الأنواع دون الحاجة إلى معرفة ما هي تلك الأنواع بالضبط حتى يتم تطبيق السِمَة.

لقد وصفنا معظم الميزات المتقدمة في هذا الفصل على أنها نادرة الاستخدام. الأنواع المرتبطة في مكان ما في المنتصف: يتم استخدامها بشكل أقل من الميزات الموضحة في بقية الكتاب ولكن بشكل أكثر شيوعًا من العديد من الميزات الأخرى التي تمت مناقشتها في هذا الفصل.

مثال واحد على سِمَة مع نوع مرتبط هو سِمَة `Iterator` التي توفرها المكتبة القياسية. النوع المرتبط يُسمى `Item` ويحل محل نوع القيم التي يتكرر عليها النوع المطبق لسِمَة `Iterator`. تعريف سِمَة `Iterator` كما هو موضح في القائمة 20-13.

<Listing number="20-13" caption="تعريف سِمَة `Iterator` التي لها نوع مرتبط `Item`">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-13/src/lib.rs}}
```

</Listing>

النوع `Item` هو نائب، وتعريف طريقة `next` يُظهر أنها ستعيد قيمًا من النوع `Option<Self::Item>`. منفذو سِمَة `Iterator` سيحددون النوع الملموس لـ `Item`، وطريقة `next` ستعيد `Option` يحتوي على قيمة من ذلك النوع الملموس.

قد تبدو الأنواع المرتبطة مفهومًا مشابهًا للأنواع العامة (generics)، حيث أن الأخيرة تسمح لنا بتعريف دالة دون تحديد الأنواع التي يمكنها التعامل معها. لفحص الفرق بين المفهومين، سننظر إلى تطبيق لسِمَة `Iterator` على نوع يُسمى `Counter` يحدد أن نوع `Item` هو `u32`:

<Listing file-name="src/lib.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

</Listing>

يبدو هذا البناء قابلاً للمقارنة مع بناء الأنواع العمومية. فلماذا لا نعرف سِمَة `Iterator` فقط بالأنواع العامة، كما هو موضح في القائمة 20-14؟

<Listing number="20-14" caption="تعريف افتراضي لسِمَة `Iterator` باستخدام الأنواع العمومية">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-14/src/lib.rs}}
```

</Listing>

الفرق هو أنه عند استخدام الأنواع العمومية، كما في القائمة 20-14، يجب علينا التعليق على الأنواع في كل تطبيق؛ لأننا يمكننا أيضًا تطبيق `Iterator<String> for Counter` أو أي نوع آخر، يمكن أن يكون لدينا تطبيقات متعددة لـ `Iterator` لـ `Counter`. بمعنى آخر، عندما تحتوي سِمَة على معامل عام، يمكن تطبيقها لنوع عدة مرات، بتغيير الأنواع الملموسة لمعاملات النوع العام في كل مرة. عندما نستخدم طريقة `next` على `Counter`، سيتعين علينا توفير تعليقات النوع للإشارة إلى أي تطبيق لـ `Iterator` نريد استخدامه.

مع الأنواع المرتبطة، لا نحتاج إلى التعليق على الأنواع، لأننا لا نستطيع تطبيق سِمَة على نوع عدة مرات. في القائمة 20-13 مع التعريف الذي يستخدم الأنواع المرتبطة، يمكننا اختيار ما سيكون نوع `Item` مرة واحدة فقط لأنه لا يمكن أن يكون هناك سوى `impl Iterator for Counter` واحد. لا يتعين علينا تحديد أننا نريد مُكرِّرًا من قيم `u32` في كل مكان نستدعي فيه `next` على `Counter`.

تصبح الأنواع المرتبطة أيضًا جزءًا من عقد السِمَة: يجب على منفذي السِمَة توفير نوع ليحل محل النوع المرتبط النائب. غالبًا ما تحمل الأنواع المرتبطة اسمًا يصف كيفية استخدام النوع، وتوثيق النوع المرتبط في وثائق API هو ممارسة جيدة.

<!-- Old headings. Do not remove or links may break. -->

<a id="default-generic-type-parameters-and-operator-overloading"></a>

### استخدام معاملات النوع العام الافتراضية وتحميل المعاملات الزائد

عندما نستخدم معاملات النوع العام، يمكننا تحديد نوع ملموس افتراضي للنوع العام. هذا يلغي حاجة منفذي السِمَة لتحديد نوع ملموس إذا كان النوع الافتراضي يعمل. تحدد نوعًا افتراضيًا عند التصريح عن نوع عمومي باستخدام بناء الجملة `<PlaceholderType=ConcreteType>`.

مثال رائع على حالة تكون فيها هذه التقنية مفيدة هو مع _تحميل المعاملات الزائد_ (operator overloading)، حيث تخصص سلوك معامل (مثل `+`) في مواقف معينة.

لا يسمح لك Rust بإنشاء معاملات خاصة بك أو تحميل معاملات عشوائية بشكل زائد. ولكن يمكنك تحميل العمليات والسِمَات المقابلة المدرجة في `std::ops` بتطبيق السِمَات المرتبطة بالمعامل. على سبيل المثال، في القائمة 20-15، نحمّل المعامل `+` بشكل زائد لإضافة نسختين من `Point` معًا. نفعل ذلك بتطبيق سِمَة `Add` على بنية `Point`.

<Listing number="20-15" file-name="src/main.rs" caption="تطبيق سِمَة `Add` لتحميل المعامل `+` بشكل زائد لنسخ `Point`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-15/src/main.rs}}
```

</Listing>

تضيف طريقة `add` قيم `x` لنسختين من `Point` وقيم `y` لنسختين من `Point` لإنشاء `Point` جديد. لدى سِمَة `Add` نوع مرتبط يُسمى `Output` يحدد النوع المُعاد من طريقة `add`.

النوع العام الافتراضي في هذا الكود موجود داخل سِمَة `Add`. إليك تعريفها:

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

يجب أن يبدو هذا الكود مألوفًا بشكل عام: سِمَة مع طريقة واحدة ونوع مرتبط. الجزء الجديد هو `Rhs=Self`: يُسمى هذا البناء _معاملات النوع الافتراضية_ (default type parameters). معامل النوع العام `Rhs` (اختصار لـ "right-hand side") يحدد نوع معامل `rhs` في طريقة `add`. إذا لم نحدد نوعًا ملموسًا لـ `Rhs` عند تطبيق سِمَة `Add`، فسيكون نوع `Rhs` افتراضيًا `Self`، والذي سيكون النوع الذي نطبق عليه `Add`.

عندما طبقنا `Add` لـ `Point`، استخدمنا الافتراضي لـ `Rhs` لأننا أردنا إضافة نسختين من `Point`. دعنا ننظر إلى مثال لتطبيق سِمَة `Add` حيث نريد تخصيص نوع `Rhs` بدلاً من استخدام الافتراضي.

لدينا بنيتان، `Millimeters` و `Meters`، تحتويان على قيم بوحدات مختلفة. هذا الغلاف الرقيق لنوع موجود في بنية أخرى يُعرف بنمط _newtype_، والذي نصفه بمزيد من التفصيل في قسم ["تطبيق السِمَات الخارجية مع نمط Newtype"][newtype]<!-- ignore -->. نريد إضافة قيم بالمليمترات إلى قيم بالأمتار والحصول على تطبيق `Add` يقوم بالتحويل بشكل صحيح. يمكننا تطبيق `Add` لـ `Millimeters` مع `Meters` كـ `Rhs`، كما هو موضح في القائمة 20-16.

<Listing number="20-16" file-name="src/lib.rs" caption="تطبيق سِمَة `Add` على `Millimeters` لإضافة `Millimeters` و `Meters`">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-16/src/lib.rs}}
```

</Listing>

لإضافة `Millimeters` و `Meters`، نحدد `impl Add<Meters>` لتعيين قيمة معامل النوع `Rhs` بدلاً من استخدام الافتراضي `Self`.

ستستخدم معاملات النوع الافتراضية بطريقتين رئيسيتين:

1. لتوسيع نوع دون كسر الكود الموجود
2. للسماح بالتخصيص في حالات محددة لا يحتاجها معظم المستخدمين

سِمَة `Add` في المكتبة القياسية هي مثال على الغرض الثاني: عادةً، ستضيف نوعين متشابهين، لكن سِمَة `Add` توفر القدرة على التخصيص بما يتجاوز ذلك. استخدام معامل نوع افتراضي في تعريف سِمَة `Add` يعني أنك لا تضطر لتحديد المعامل الإضافي في معظم الوقت. بمعنى آخر، لا حاجة لقليل من الكود الشكلي للتطبيق، مما يجعل استخدام السِمَة أسهل.

الغرض الأول مشابه للثاني ولكن بالعكس: إذا كنت تريد إضافة معامل نوع إلى سِمَة موجودة، يمكنك إعطاؤه افتراضيًا للسماح بتوسيع وظيفة السِمَة دون كسر كود التطبيق الموجود.

<!-- Old headings. Do not remove or links may break. -->

<a id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"></a>
<a id="disambiguating-between-methods-with-the-same-name"></a>

### التمييز بين الطرق بنفس الاسم

لا شيء في Rust يمنع سِمَة من وجود طريقة بنفس اسم طريقة سِمَة أخرى، ولا يمنع Rust من تطبيق كلتا السِمَتين على نوع واحد. من الممكن أيضًا تطبيق طريقة مباشرة على النوع بنفس اسم الطرق من السِمَات.

عند استدعاء طرق بنفس الاسم، ستحتاج إلى إخبار Rust أيها تريد استخدامه. ضع في اعتبارك الكود في القائمة 20-17 حيث عرفنا سِمَتين، `Pilot` و `Wizard`، وكلاهما لهما طريقة تسمى `fly`. ثم نطبق كلتا السِمَتين على نوع `Human` الذي لديه بالفعل طريقة تسمى `fly` مطبقة عليه. كل طريقة `fly` تفعل شيئًا مختلفًا.

<Listing number="20-17" file-name="src/main.rs" caption="تم تعريف سِمَتين لهما طريقة `fly` وتم تطبيقهما على نوع `Human`، وتم تطبيق طريقة `fly` على `Human` مباشرة.">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-17/src/main.rs:here}}
```

</Listing>

عندما نستدعي `fly` على نسخة من `Human`، يستخدم المصرِّف افتراضيًا استدعاء الطريقة المطبقة مباشرة على النوع، كما هو موضح في القائمة 20-18.

<Listing number="20-18" file-name="src/main.rs" caption="استدعاء `fly` على نسخة من `Human`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-18/src/main.rs:here}}
```

</Listing>

سيطبع تشغيل هذا الكود `*waving arms furiously*`، مما يُظهر أن Rust استدعت طريقة `fly` المطبقة على `Human` مباشرة.

لاستدعاء طرق `fly` من سِمَة `Pilot` أو سِمَة `Wizard`، نحتاج إلى استخدام بناء جملة أكثر وضوحًا لتحديد أي طريقة `fly` نعنيها. توضح القائمة 20-19 هذا البناء.

<Listing number="20-19" file-name="src/main.rs" caption="تحديد أي طريقة `fly` للسِمَة نريد استدعاءها">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-19/src/main.rs:here}}
```

</Listing>

تحديد اسم السِمَة قبل اسم الطريقة يوضح لـ Rust أي تطبيق لـ `fly` نريد استدعاءه. يمكننا أيضًا كتابة `Human::fly(&person)`، وهو ما يعادل `person.fly()` الذي استخدمناه في القائمة 20-19، ولكن هذا أطول قليلاً للكتابة إذا لم نكن بحاجة إلى التمييز.

سيطبع تشغيل هذا الكود ما يلي:

```console
{{#include ../listings/ch20-advanced-features/listing-20-19/output.txt}}
```

لأن طريقة `fly` تأخذ معامل `self`، إذا كان لدينا نوعان يطبقان سِمَة واحدة، يمكن لـ Rust معرفة أي تطبيق للسِمَة لاستخدامه بناءً على نوع `self`.

ومع ذلك، الدوال المرتبطة التي ليست طرقًا لا تحتوي على معامل `self`. عندما تكون هناك أنواع أو سِمَات متعددة تحدد دوال غير طرقية بنفس اسم الدالة، لا يعرف Rust دائمًا أي نوع تعنيه ما لم تستخدم بناء الجملة المؤهل بالكامل. على سبيل المثال، في القائمة 20-20، ننشئ سِمَة لملجأ حيوانات يريد تسمية جميع الجراء الصغيرة Spot. ننشئ سِمَة `Animal` بدالة مرتبطة غير طريقية `baby_name`. يتم تطبيق سِمَة `Animal` لبنية `Dog`، والتي نوفر عليها أيضًا دالة مرتبطة غير طريقية `baby_name` مباشرة.

<Listing number="20-20" file-name="src/main.rs" caption="سِمَة بدالة مرتبطة ونوع بدالة مرتبطة بنفس الاسم الذي يطبق السِمَة أيضًا">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-20/src/main.rs}}
```

</Listing>

نطبق الكود لتسمية جميع الجراء Spot في الدالة المرتبطة `baby_name` المعرفة على `Dog`. يطبق نوع `Dog` أيضًا سِمَة `Animal`، التي تصف الخصائص التي تمتلكها جميع الحيوانات. تُسمى الجراء الصغيرة puppies، وهذا معبر عنه في تطبيق سِمَة `Animal` على `Dog` في دالة `baby_name` المرتبطة بسِمَة `Animal`.

في `main`، نستدعي دالة `Dog::baby_name`، التي تستدعي الدالة المرتبطة المعرفة على `Dog` مباشرة. يطبع هذا الكود ما يلي:

```console
{{#include ../listings/ch20-advanced-features/listing-20-20/output.txt}}
```

هذا الإخراج ليس ما أردناه. نريد استدعاء دالة `baby_name` التي هي جزء من سِمَة `Animal` التي طبقناها على `Dog` حتى يطبع الكود `A baby dog is called a puppy`. تقنية تحديد اسم السِمَة التي استخدمناها في القائمة 20-19 لا تساعد هنا؛ إذا غيرنا `main` إلى الكود في القائمة 20-21، سنحصل على خطأ ترجمة.

<Listing number="20-21" file-name="src/main.rs" caption="محاولة استدعاء دالة `baby_name` من سِمَة `Animal`، لكن Rust لا يعرف أي تطبيق لاستخدامه">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-21/src/main.rs:here}}
```

</Listing>

لأن `Animal::baby_name` لا تحتوي على معامل `self`، ويمكن أن تكون هناك أنواع أخرى تطبق سِمَة `Animal`، لا يستطيع Rust معرفة أي تطبيق لـ `Animal::baby_name` نريده. سنحصل على هذا الخطأ من المصرِّف:

```console
{{#include ../listings/ch20-advanced-features/listing-20-21/output.txt}}
```

للتمييز وإخبار Rust بأننا نريد استخدام تطبيق `Animal` لـ `Dog` بدلاً من تطبيق `Animal` لنوع آخر، نحتاج إلى استخدام بناء الجملة المؤهل بالكامل. توضح القائمة 20-22 كيفية استخدام بناء الجملة المؤهل بالكامل.

<Listing number="20-22" file-name="src/main.rs" caption="استخدام بناء الجملة المؤهل بالكامل لتحديد أننا نريد استدعاء دالة `baby_name` من سِمَة `Animal` كما تم تطبيقها على `Dog`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-22/src/main.rs:here}}
```

</Listing>

نوفر لـ Rust تعليق نوع داخل الأقواس الزاوية، والذي يشير إلى أننا نريد استدعاء طريقة `baby_name` من سِمَة `Animal` كما تم تطبيقها على `Dog` بالقول أننا نريد معاملة نوع `Dog` كـ `Animal` لاستدعاء هذه الدالة. سيطبع هذا الكود الآن ما نريده:

```console
{{#include ../listings/ch20-advanced-features/listing-20-22/output.txt}}
```

بشكل عام، يُعرف بناء الجملة المؤهل بالكامل على النحو التالي:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

للدوال المرتبطة التي ليست طرقًا، لن يكون هناك `receiver`: سيكون هناك قائمة الوسائط الأخرى فقط. يمكنك استخدام بناء الجملة المؤهل بالكامل في كل مكان تستدعي فيه الدوال أو الطرق. ومع ذلك، يُسمح لك بحذف أي جزء من هذا البناء يمكن لـ Rust معرفته من معلومات أخرى في البرنامج. تحتاج فقط إلى استخدام هذا البناء الأكثر تفصيلاً في الحالات التي توجد فيها تطبيقات متعددة تستخدم نفس الاسم ويحتاج Rust إلى مساعدة لتحديد أي تطبيق تريد استدعاءه.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-supertraits-to-require-one-traits-functionality-within-another-trait"></a>

### استخدام السِمَات الفائقة

في بعض الأحيان قد تكتب تعريف سِمَة يعتمد على سِمَة أخرى: لكي ينفذ نوع السِمَة الأولى، تريد طلب أن ينفذ هذا النوع السِمَة الثانية أيضًا. ستفعل ذلك حتى يتمكن تعريف سِمَتك من استخدام العناصر المرتبطة بالسِمَة الثانية. السِمَة التي يعتمد عليها تعريف سِمَتك تُسمى _سِمَة فائقة_ (supertrait) لسِمَتك.

على سبيل المثال، لنفترض أننا نريد إنشاء سِمَة `OutlinePrint` بطريقة `outline_print` التي ستطبع قيمة معينة منسقة بحيث تكون محاطة بإطار من العلامات النجمية. أي، بالنظر إلى بنية `Point` التي تطبق سِمَة المكتبة القياسية `Display` لتنتج `(x, y)`، عندما نستدعي `outline_print` على نسخة `Point` لها `1` لـ `x` و `3` لـ `y`، يجب أن تطبع ما يلي:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

في تطبيق طريقة `outline_print`، نريد استخدام وظيفة سِمَة `Display`. لذلك، نحتاج إلى تحديد أن سِمَة `OutlinePrint` ستعمل فقط للأنواع التي تطبق أيضًا `Display` وتوفر الوظيفة التي تحتاجها `OutlinePrint`. يمكننا فعل ذلك في تعريف السِمَة بتحديد `OutlinePrint: Display`. هذه التقنية مشابهة لإضافة قيد سِمَة إلى السِمَة. توضح القائمة 20-23 تطبيق سِمَة `OutlinePrint`.

<Listing number="20-23" file-name="src/main.rs" caption="تطبيق سِمَة `OutlinePrint` التي تتطلب الوظيفة من `Display`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-23/src/main.rs:here}}
```

</Listing>

لأننا حددنا أن `OutlinePrint` تتطلب سِمَة `Display`، يمكننا استخدام دالة `to_string` التي يتم تطبيقها تلقائيًا لأي نوع يطبق `Display`. إذا حاولنا استخدام `to_string` دون إضافة نقطتين وتحديد سِمَة `Display` بعد اسم السِمَة، سنحصل على خطأ يقول إنه لم يتم العثور على طريقة تسمى `to_string` للنوع `&Self` في النطاق الحالي.

دعنا نرى ما يحدث عندما نحاول تطبيق `OutlinePrint` على نوع لا يطبق `Display`، مثل بنية `Point`:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

</Listing>

نحصل على خطأ يقول إن `Display` مطلوب ولكن لم يتم تطبيقه:

```console
{{#include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

لإصلاح ذلك، نطبق `Display` على `Point` ونرضي القيد الذي تطلبه `OutlinePrint`، هكذا:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

</Listing>

بعد ذلك، سيتم ترجمة تطبيق سِمَة `OutlinePrint` على `Point` بنجاح، ويمكننا استدعاء `outline_print` على نسخة `Point` لعرضها داخل إطار من العلامات النجمية.

<!-- Old headings. Do not remove or links may break. -->

<a id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"></a>
<a id="using-the-newtype-pattern-to-implement-external-traits"></a>

### تطبيق السِمَات الخارجية مع نمط Newtype

في قسم ["تطبيق سِمَة على نوع"][implementing-a-trait-on-a-type]<!-- ignore --> في الفصل 10، ذكرنا قاعدة اليتيم (orphan rule) التي تنص على أننا مسموح لنا بتطبيق سِمَة على نوع فقط إذا كانت السِمَة أو النوع، أو كلاهما، محليين لصندوقنا. من الممكن التحايل على هذا القيد باستخدام نمط newtype، والذي يتضمن إنشاء نوع جديد في بنية tuple. (لقد غطينا بنيات tuple في قسم ["إنشاء أنواع مختلفة مع بنيات Tuple"][tuple-structs]<!-- ignore --> في الفصل 5.) ستحتوي بنية tuple على حقل واحد وتكون غلافًا رقيقًا حول النوع الذي نريد تطبيق سِمَة له. بعد ذلك، يكون نوع الغلاف محليًا لصندوقنا، ويمكننا تطبيق السِمَة على الغلاف. _Newtype_ هو مصطلح ينشأ من لغة البرمجة Haskell. لا توجد عقوبة أداء في وقت التشغيل لاستخدام هذا النمط، ويتم إزالة نوع الغلاف في وقت الترجمة.

كمثال، لنفترض أننا نريد تطبيق `Display` على `Vec<T>`، الذي تمنعنا قاعدة اليتيم من القيام به مباشرة لأن سِمَة `Display` ونوع `Vec<T>` معرفان خارج صندوقنا. يمكننا إنشاء بنية `Wrapper` تحتوي على نسخة من `Vec<T>`؛ بعد ذلك، يمكننا تطبيق `Display` على `Wrapper` واستخدام قيمة `Vec<T>`، كما هو موضح في القائمة 20-24.

<Listing number="20-24" file-name="src/main.rs" caption="إنشاء نوع `Wrapper` حول `Vec<String>` لتطبيق `Display`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-24/src/main.rs}}
```

</Listing>

يستخدم تطبيق `Display` `self.0` للوصول إلى `Vec<T>` الداخلي لأن `Wrapper` هو بنية tuple و `Vec<T>` هو العنصر في الفهرس 0 في tuple. بعد ذلك، يمكننا استخدام وظيفة سِمَة `Display` على `Wrapper`.

العيب في استخدام هذه التقنية هو أن `Wrapper` هو نوع جديد، لذلك لا يحتوي على طرق القيمة التي يحتفظ بها. سيتعين علينا تطبيق جميع طرق `Vec<T>` مباشرة على `Wrapper` بحيث تفوض الطرق إلى `self.0`، مما سيسمح لنا بمعاملة `Wrapper` تمامًا مثل `Vec<T>`. إذا أردنا أن يحتوي النوع الجديد على كل طريقة للنوع الداخلي، فإن تطبيق سِمَة `Deref` على `Wrapper` لإرجاع النوع الداخلي سيكون حلاً (ناقشنا تطبيق سِمَة `Deref` في قسم ["معاملة المؤشرات الذكية كمراجع عادية"][smart-pointer-deref]<!-- ignore --> في الفصل 15). إذا لم نرد أن يحتوي نوع `Wrapper` على جميع طرق النوع الداخلي - على سبيل المثال، لتقييد سلوك نوع `Wrapper` - سيتعين علينا تطبيق الطرق التي نريدها فقط يدويًا.

نمط newtype مفيد أيضًا حتى عندما لا تكون السِمَات معنية. دعنا نغير التركيز وننظر إلى بعض الطرق المتقدمة للتفاعل مع نظام الأنواع في Rust.

[newtype]: ch20-02-advanced-traits.html#implementing-external-traits-with-the-newtype-pattern
[implementing-a-trait-on-a-type]: ch10-02-traits.html#implementing-a-trait-on-a-type
[traits]: ch10-02-traits.html
[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references
[tuple-structs]: ch05-01-defining-structs.html#creating-different-types-with-tuple-structs
