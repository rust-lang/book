## قبول معاملات سطر الأوامر (Accepting Command Line Arguments)

لننشئ مشروعًا جديدًا باستخدام `cargo new` كما هو الحال دائمًا. سنسمي مشروعنا
`minigrep` لتمييزه عن أداة `grep` التي قد تكون موجودة بالفعل على نظامك:

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

المهمة الأولى هي جعل `minigrep` يقبل معاملَيْ سطر الأوامر (command line arguments): مسار الملف والنص
المراد البحث عنه. أي، نريد أن نكون قادرين على تشغيل برنامجنا باستخدام `cargo
run`، وشَرْطَتَيْن للإشارة إلى أن المعاملات (arguments) التالية مخصصة لبرنامجنا وليس لـ
`cargo`، ونص للبحث عنه، ومسار إلى ملف للبحث فيه، مثل:

```console
$ cargo run -- searchstring example-filename.txt
```

في الوقت الحالي، لا يمكن للبرنامج الذي يتم إنشاؤه بواسطة `cargo new` معالجة
المعاملات التي نقدمها له. بعض المكتبات الموجودة على
[crates.io](https://crates.io/) يمكن أن تساعد في كتابة برنامج يقبل معاملات سطر
الأوامر، ولكن نظرًا لأنك تتعلم هذا المفهوم للتو، فلننفذ هذه القدرة بأنفسنا.

### قراءة قيم المعاملات (Reading the Argument Values)

لتمكين `minigrep` من قراءة قيم معاملات سطر الأوامر (command line arguments) التي نمررها إليه، سنحتاج إلى
دالة `std::env::args` المتوفرة في المكتبة القياسية لـ Rust. تُرجع هذه الدالة
مُكرِّرًا (iterator) لمعاملات سطر الأوامر (command line arguments) الممررة إلى `minigrep`. سنغطي
المُكرِّرات بالكامل في [الفصل 13][ch13]<!-- ignore -->. في الوقت الحالي، ما
عليك سوى معرفة تفصيلتين عن المُكرِّرات: تُنتج المُكرِّرات سلسلة من القيم،
ويمكننا استدعاء التابع `collect` على مُكرِّر لتحويله إلى مجموعة، مثل متجه
(vector)، يحتوي على جميع العناصر التي ينتجها المُكرِّر.

يسمح الكود في القائمة 12-1 لبرنامج `minigrep` الخاص بك بقراءة أي معاملات سطر
أوامر ممررة إليه ثم جمع القيم في متجه.

<Listing number="12-1" file-name="src/main.rs" caption="جمع معاملات سطر الأوامر (command line arguments) في متجه وطباعتها">

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```

</Listing>

أولاً، نُدخل وحدة `std::env` إلى النطاق باستخدام عبارة `use` حتى نتمكن من
استخدام دالتها `args`. لاحظ أن دالة `std::env::args` متداخلة في مستويين من
الوحدات. كما ناقشنا في [الفصل 7][ch7-idiomatic-use]<!-- ignore -->، في الحالات
التي تكون فيها الدالة المطلوبة متداخلة في أكثر من وحدة واحدة، اخترنا إدخال
الوحدة الأب إلى النطاق بدلاً من الدالة. بذلك، يمكننا بسهولة استخدام دوال أخرى
من `std::env`. كما أنه أقل غموضًا من إضافة `use std::env::args` ثم استدعاء
الدالة باستخدام `args` فقط، لأن `args` قد يُخطأ فيها بسهولة كدالة معرّفة في
الوحدة الحالية.

> ### دالة `args` و Unicode غير الصالح
>
> لاحظ أن `std::env::args` ستُسبب ذعرًا (panic) إذا احتوى أي معامل على Unicode
> غير صالح. إذا كان برنامجك يحتاج إلى قبول معاملات تحتوي على Unicode غير صالح،
> فاستخدم `std::env::args_os` بدلاً من ذلك. تُرجع تلك الدالة مُكرِّرًا ينتج
> قيم `OsString` بدلاً من قيم `String`. اخترنا استخدام `std::env::args` هنا من
> أجل البساطة لأن قيم `OsString` تختلف لكل منصة وأكثر تعقيدًا للعمل معها من قيم
> `String`.

في السطر الأول من `main`، نستدعي `env::args`، ونستخدم `collect` فورًا لتحويل
المُكرِّر إلى متجه يحتوي على جميع القيم التي أنتجها المُكرِّر. يمكننا استخدام
دالة `collect` لإنشاء أنواع عديدة من المجموعات، لذا نُحدد صراحةً نوع `args`
لتحديد أننا نريد متجهًا من النصوص. على الرغم من أنك نادرًا ما تحتاج إلى تحديد
الأنواع في Rust، إلا أن `collect` هي دالة واحدة غالبًا ما تحتاج إلى تحديد نوعها
لأن Rust غير قادر على استنتاج نوع المجموعة التي تريدها.

أخيرًا، نطبع المتجه باستخدام ماكرو التنقيح (debug macro). لنحاول تشغيل الكود
أولاً بدون معاملات ثم مع معاملين:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

لاحظ أن القيمة الأولى في المتجه هي `"target/debug/minigrep"`، وهو اسم ملفنا
الثنائي. هذا يتطابق مع سلوك قائمة المعاملات في C، مما يتيح للبرامج استخدام
الاسم الذي تم استدعاؤها به في تنفيذها. غالبًا ما يكون من المناسب الوصول إلى اسم
البرنامج في حالة رغبتك في طباعته في الرسائل أو تغيير سلوك البرنامج بناءً على
الاسم المستعار لسطر الأوامر المستخدم لاستدعاء البرنامج. لكن لأغراض هذا الفصل،
سنتجاهله ونحفظ المعاملين اللذين نحتاجهما فقط.

### حفظ قيم المعاملات في متغيرات

البرنامج قادر حاليًا على الوصول إلى القيم المحددة كمعاملات سطر أوامر. الآن
نحتاج إلى حفظ قيم المعاملين في متغيرات حتى نتمكن من استخدام القيم في بقية
البرنامج. نفعل ذلك في القائمة 12-2.

<Listing number="12-2" file-name="src/main.rs" caption="إنشاء متغيرات للاحتفاظ بمعامل الاستعلام ومعامل مسار الملف">

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```

</Listing>

كما رأينا عندما طبعنا المتجه، يشغل اسم البرنامج القيمة الأولى في المتجه عند
`args[0]`، لذا نبدأ المعاملات عند الفهرس 1. المعامل الأول الذي يأخذه `minigrep`
هو النص الذي نبحث عنه، لذا نضع مَرجِعًا (reference) إلى المعامل الأول في
المتغير `query`. المعامل الثاني سيكون مسار الملف، لذا نضع مَرجِعًا إلى
المعامل الثاني في المتغير `file_path`.

نطبع مؤقتًا قيم هذه المتغيرات لإثبات أن الكود يعمل كما نعتزم. لنقم بتشغيل هذا
البرنامج مرة أخرى بالمعاملات `test` و `sample.txt`:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

رائع، البرنامج يعمل! قيم المعاملات التي نحتاجها يتم حفظها في المتغيرات
الصحيحة. لاحقًا سنضيف بعض معالجة الأخطاء للتعامل مع بعض المواقف الخاطئة
المحتملة، مثل عندما لا يوفر المستخدم أي معاملات؛ في الوقت الحالي، سنتجاهل ذلك
الموقف ونعمل على إضافة قدرات قراءة الملفات بدلاً من ذلك.

[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
