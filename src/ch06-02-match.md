<!-- Old headings. Do not remove or links may break. -->

<a id="the-match-control-flow-operator"></a>

## بنية التحكم في التدفق `match`

تمتلك Rust بنية تحكم في التدفق قوية للغاية تسمى `match` تتيح لك
مقارنة قيمة مع سلسلة من الأنماط ثم تنفيذ الكود بناءً على النمط الذي يطابق. يمكن
أن تتكون الأنماط من قيم حرفية، وأسماء متغيرات، ورموز بدل، والعديد من الأشياء
الأخرى؛ [الفصل 19][ch19-00-patterns]<!-- ignore --> يغطي جميع الأنواع المختلفة
من الأنماط وما تفعله. تأتي قوة `match` من تعبيرية الأنماط والحقيقة أن المترجم
يؤكد أن جميع الحالات الممكنة تم التعامل معها.

فكر في تعبير `match` كأنه آلة فرز العملات: تنزلق العملات المعدنية على مسار به
ثقوب بأحجام مختلفة على طوله، وتسقط كل عملة عبر أول ثقب تواجهه يناسبها. بنفس
الطريقة، تمر القيم عبر كل نمط في `match`، وعند أول نمط "تناسبه" القيمة، تسقط
القيمة في كتلة الكود المرتبطة لاستخدامها أثناء التنفيذ.

بالحديث عن العملات المعدنية، دعنا نستخدمها كمثال باستخدام `match`! يمكننا كتابة
دالة تأخذ عملة أمريكية غير معروفة وبطريقة مشابهة لآلة العد، تحدد أي عملة هي
وتعيد قيمتها بالسنتات، كما هو موضح في القائمة 6-3.

<Listing number="6-3" caption="تعداد (enum) وتعبير `match` يحتوي على متغيرات التعداد كأنماطه">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-03/src/main.rs:here}}
```

</Listing>

لنحلل `match` في دالة `value_in_cents`. أولاً، نكتب كلمة `match` المفتاحية
متبوعة بتعبير، والذي في هذه الحالة هو القيمة `coin`. يبدو هذا مشابهاً جداً
لتعبير شرطي يُستخدم مع `if`، ولكن هناك فرق كبير: مع `if`, يجب أن تُقيّم
الشرط إلى قيمة منطقية، ولكن هنا يمكن أن يكون من أي نوع. نوع `coin` في هذا
المثال هو تعداد `Coin` الذي عرفناه في السطر الأول.

التالي هو أذرع `match`. يحتوي الذراع على جزأين: نمط وبعض الكود. الذراع الأول
هنا لديه نمط وهو القيمة `Coin::Penny` ثم العامل `=>` الذي يفصل النمط والكود
المراد تشغيله. الكود في هذه الحالة هو فقط القيمة `1`. يتم فصل كل ذراع عن
التالي بفاصلة.

عندما يُنفذ تعبير `match`، فإنه يقارن القيمة الناتجة مع نمط كل ذراع، بالترتيب.
إذا طابق النمط القيمة، يتم تنفيذ الكود المرتبط بذلك النمط. إذا لم يطابق هذا
النمط القيمة، يستمر التنفيذ إلى الذراع التالي، تماماً كما في آلة فرز العملات.
يمكن أن يكون لدينا العدد الذي نحتاجه من الأذرع: في القائمة 6-3، `match` لدينا
أربعة أذرع.

الكود المرتبط بكل ذراع هو تعبير، والقيمة الناتجة عن التعبير في الذراع المطابق
هي القيمة التي يتم إرجاعها لتعبير `match` بأكمله.

عادة لا نستخدم الأقواس المعقوفة إذا كان كود ذراع المطابقة قصيراً، كما هو الحال
في القائمة 6-3 حيث يعيد كل ذراع قيمة فقط. إذا كنت تريد تشغيل عدة أسطر من
الكود في ذراع المطابقة، يجب عليك استخدام الأقواس المعقوفة، والفاصلة بعد الذراع
تكون اختيارية حينها. على سبيل المثال، الكود التالي يطبع "Lucky penny!" في كل
مرة يتم استدعاء الدالة مع `Coin::Penny`، ولكنه لا يزال يعيد القيمة الأخيرة من
الكتلة، `1`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-08-match-arm-multiple-lines/src/main.rs:here}}
```

### الأنماط التي ترتبط بالقيم

ميزة أخرى مفيدة لأذرع المطابقة هي أنها يمكن أن ترتبط بأجزاء من القيم التي
تطابق النمط. هذه هي الطريقة التي يمكننا بها استخراج القيم من متغيرات التعداد.

كمثال، لنغير أحد متغيرات التعداد لدينا ليحتوي على بيانات بداخله. من عام 1999
حتى عام 2008، سكت الولايات المتحدة عملات الربع (quarters) بتصاميم مختلفة لكل
ولاية من الولايات الخمسين على جانب واحد. لم تحصل العملات الأخرى على تصاميم
الولايات، لذلك فقط الربع يحتوي على هذه القيمة الإضافية. يمكننا إضافة هذه
المعلومات إلى `enum` الخاص بنا عن طريق تغيير متغير `Quarter` ليتضمن قيمة
`UsState` مخزنة بداخله، والتي فعلناها في القائمة 6-4.

<Listing number="6-4" caption="تعداد `Coin` حيث يحتوي متغير `Quarter` أيضاً على قيمة `UsState`">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-04/src/main.rs:here}}
```

</Listing>

لنتخيل أن صديقاً يحاول جمع جميع عملات الربع الخمسين للولايات. بينما نفرز
فكتنا حسب نوع العملة، سنعلن أيضاً اسم الولاية المرتبطة بكل ربع بحيث إذا كانت
واحدة ليست لدى صديقنا، يمكنه إضافتها إلى مجموعته.

في تعبير المطابقة لهذا الكود، نضيف متغيراً يسمى `state` إلى النمط الذي يطابق
قيم المتغير `Coin::Quarter`. عندما يطابق `Coin::Quarter`، سيرتبط متغير `state`
بقيمة ولاية ذلك الربع. ثم يمكننا استخدام `state` في الكود لذلك الذراع، كما
يلي:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-09-variable-in-pattern/src/main.rs:here}}
```

إذا كنا سنستدعي `value_in_cents(Coin::Quarter(UsState::Alaska))`، ستكون `coin`
هي `Coin::Quarter(UsState::Alaska)`. عندما نقارن تلك القيمة مع كل ذراع من
أذرع المطابقة، لا يطابق أي منها حتى نصل إلى `Coin::Quarter(state)`. عند تلك
النقطة، سيكون الارتباط لـ `state` هو القيمة `UsState::Alaska`. يمكننا حينها
استخدام ذلك الارتباط في تعبير `println!`، وبالتالي الحصول على قيمة الولاية
الداخلية من متغير تعداد `Coin` لـ `Quarter`.

<!-- Old headings. Do not remove or links may break. -->

<a id="matching-with-optiont"></a>

### نمط المطابقة `Option<T>`

في القسم السابق، أردنا الحصول على القيمة الداخلية `T` من حالة `Some` عند
استخدام `Option<T>`؛ يمكننا أيضاً التعامل مع `Option<T>` باستخدام `match`، كما
فعلنا مع تعداد `Coin`! بدلاً من مقارنة العملات المعدنية، سنقارن متغيرات
`Option<T>`، ولكن الطريقة التي يعمل بها تعبير `match` تبقى كما هي.

لنفترض أننا نريد كتابة دالة تأخذ `Option<i32>` وإذا كانت هناك قيمة بداخلها،
تضيف 1 إلى تلك القيمة. إذا لم تكن هناك قيمة بداخلها، يجب أن تعيد الدالة قيمة
`None` ولا تحاول إجراء أي عمليات.

هذه الدالة سهلة الكتابة للغاية، بفضل `match`، وستبدو مثل القائمة 6-5.

<Listing number="6-5" caption="دالة تستخدم تعبير `match` على `Option<i32>`">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:here}}
```

</Listing>

لنفحص التنفيذ الأول لـ `plus_one` بمزيد من التفصيل. عندما نستدعي
`plus_one(five)`، سيكون للمتغير `x` في جسم `plus_one` القيمة `Some(5)`. ثم
نقارن ذلك مع كل ذراع من أذرع المطابقة:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

القيمة `Some(5)` لا تطابق النمط `None`، لذلك نستمر إلى الذراع التالي:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:second_arm}}
```

هل تطابق `Some(5)` النمط `Some(i)`؟ نعم تطابق! لدينا نفس المتغير. يرتبط `i`
بالقيمة الموجودة في `Some`، لذلك يأخذ `i` القيمة `5`. ثم يتم تنفيذ الكود في
ذراع المطابقة، لذلك نضيف 1 إلى قيمة `i` ونُنشئ قيمة `Some` جديدة بإجماليها `6`
بداخلها.

الآن دعنا نفكر في الاستدعاء الثاني لـ `plus_one` في القائمة 6-5، حيث `x` هو
`None`. ندخل `match` ونقارن بالذراع الأول:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

إنه يطابق! لا توجد قيمة للإضافة إليها، لذلك يتوقف البرنامج ويعيد قيمة `None`
على الجانب الأيمن من `=>`. لأن الذراع الأول طابق، لا تتم مقارنة أي أذرع أخرى.

الجمع بين `match` والتعدادات مفيد في العديد من الحالات. سترى هذا النمط كثيراً
في كود Rust: `match` ضد تعداد، ربط متغير بالبيانات بداخله، ثم تنفيذ كود بناءً
عليه. إنه قليلاً صعب في البداية، لكن بمجرد أن تعتاد عليه، ستتمنى لو كان لديك
في جميع اللغات. إنه دائماً المفضل لدى المستخدمين.

### المطابقات شاملة

هناك جانب آخر من `match` نحتاج إلى مناقشته: يجب أن تغطي أنماط الأذرع جميع
الاحتمالات. فكر في هذا الإصدار من دالة `plus_one` الخاصة بنا، والتي تحتوي على
خطأ ولن يتم تجميعها:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/src/main.rs:here}}
```

لم نتعامل مع حالة `None`، لذلك سيتسبب هذا الكود في خطأ. لحسن الحظ، إنه خطأ
يعرف Rust كيفية اكتشافه. إذا حاولنا تجميع هذا الكود، سنحصل على هذا الخطأ:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt}}
```

يعلم Rust أننا لم نغطِ كل حالة ممكنة ويعلم حتى أي نمط نسيناه! المطابقات في
Rust _شاملة_: يجب أن نستنفد كل احتمال أخير لكي يكون الكود صالحاً. خاصة في حالة
`Option<T>`، عندما يمنعنا Rust من نسيان التعامل صراحة مع حالة `None`، فإنه
يحمينا من افتراض أن لدينا قيمة عندما قد نمتلك null، وبالتالي يجعل الخطأ الذي
يبلغ مليار دولار الذي نوقش سابقاً مستحيلاً.

### أنماط التقاط الكل والعنصر النائب `_`

باستخدام التعدادات، يمكننا أيضاً اتخاذ إجراءات خاصة لقيم معينة قليلة، ولكن
لجميع القيم الأخرى اتخاذ إجراء افتراضي واحد. تخيل أننا نطبق لعبة حيث، إذا
رميت 3 في رمية النرد، لا يتحرك لاعبك بل يحصل على قبعة فاخرة جديدة. إذا رميت
7، يفقد لاعبك قبعة فاخرة. لجميع القيم الأخرى، يتحرك لاعبك بذلك العدد من
المساحات على لوحة اللعبة. إليك `match` تطبق تلك المنطق، مع نتيجة رمي النرد
مشفرة بدلاً من قيمة عشوائية، وكل المنطق الآخر ممثل بدوال بدون أجسام لأن تطبيقها
الفعلي خارج نطاق هذا المثال:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-15-binding-catchall/src/main.rs:here}}
```

بالنسبة للذراعين الأولين، الأنماط هي القيم الحرفية `3` و `7`. بالنسبة للذراع
الأخير الذي يغطي كل قيمة ممكنة أخرى، النمط هو المتغير الذي اخترنا تسميته
`other`. الكود الذي يعمل لذراع `other` يستخدم المتغير عن طريق تمريره إلى دالة
`move_player`.

هذا الكود يُجمّع، على الرغم من أننا لم نسرد جميع القيم الممكنة التي يمكن أن
يمتلكها `u8`، لأن النمط الأخير سيطابق جميع القيم غير المدرجة صراحة. هذا النمط
الذي يلتقط الكل يلبي المتطلب أن `match` يجب أن يكون شاملاً. لاحظ أنه يجب علينا
وضع ذراع التقاط الكل أخيراً لأن الأنماط يتم تقييمها بالترتيب. إذا وضعنا ذراع
التقاط الكل في وقت سابق، فإن الأذرع الأخرى لن تعمل أبداً، لذلك سيحذرنا Rust
إذا أضفنا أذرعاً بعد التقاط الكل!

يمتلك Rust أيضاً نمطاً يمكننا استخدامه عندما نريد التقاط الكل ولكن لا نريد
_استخدام_ القيمة في نمط التقاط الكل: `_` هو نمط خاص يطابق أي قيمة ولا يرتبط
بتلك القيمة. هذا يخبر Rust أننا لن نستخدم القيمة، لذلك لن يحذرنا Rust بشأن
متغير غير مستخدم.

لنغير قواعد اللعبة: الآن، إذا رميت أي شيء آخر غير 3 أو 7، يجب أن ترمي مرة
أخرى. لم نعد بحاجة إلى استخدام قيمة التقاط الكل، لذلك يمكننا تغيير كودنا
لاستخدام `_` بدلاً من المتغير المسمى `other`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-16-underscore-catchall/src/main.rs:here}}
```

هذا المثال يلبي أيضاً متطلب الشمولية لأننا نتجاهل صراحة جميع القيم الأخرى في
الذراع الأخير؛ لم ننسَ أي شيء.

أخيراً، سنغير قواعد اللعبة مرة أخرى بحيث لا يحدث شيء آخر في دورك إذا رميت أي
شيء آخر غير 3 أو 7. يمكننا التعبير عن ذلك باستخدام قيمة الوحدة (نوع المجموعة
الفارغة الذي ذكرناه في قسم [نوع المجموعة][tuples]<!-- ignore -->) كالكود
الذي يذهب مع ذراع `_`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-17-underscore-unit/src/main.rs:here}}
```

هنا، نخبر Rust صراحة أننا لن نستخدم أي قيمة أخرى لا تطابق نمطاً في ذراع سابق،
ولا نريد تشغيل أي كود في هذه الحالة.

هناك المزيد حول الأنماط والمطابقة الذي سنغطيه في [الفصل
19][ch19-00-patterns]<!-- ignore -->. في الوقت الحالي، سننتقل إلى صياغة `if let`،
والتي يمكن أن تكون مفيدة في الحالات التي يكون فيها تعبير `match` مطولاً بعض
الشيء.

[tuples]: ch03-02-data-types.html#the-tuple-type
[ch19-00-patterns]: ch19-00-patterns.html
