## إعادة الهيكلة لتحسين النمطية ومعالجة الأخطاء

لتحسين برنامجنا، سنصلح أربع مشاكل تتعلق ببنية البرنامج وكيفية معالجته للأخطاء
المحتملة. أولاً، تقوم دالة `main` الآن بمهمتين: تحلل المعاملات وتقرأ الملفات.
مع نمو برنامجنا، سيزداد عدد المهام المنفصلة التي تتعامل معها دالة `main`. مع
اكتساب الدالة مسؤوليات، يصبح من الأصعب التفكير فيها، وأصعب في الاختبار، وأصعب في
التغيير دون كسر أحد أجزائها. من الأفضل فصل الوظائف بحيث تكون كل دالة مسؤولة عن
مهمة واحدة.

تتعلق هذه المسألة أيضًا بالمشكلة الثانية: على الرغم من أن `query` و
`file_path` هما متغيرات تكوين لبرنامجنا، فإن متغيرات مثل `contents` تُستخدم
لتنفيذ منطق البرنامج. كلما أصبحت `main` أطول، زاد عدد المتغيرات التي سنحتاج
إلى إدخالها في النطاق؛ كلما زاد عدد المتغيرات في النطاق، أصبح من الأصعب تتبع
غرض كل منها. من الأفضل تجميع متغيرات التكوين في بنية واحدة لتوضيح غرضها.

المشكلة الثالثة هي أننا استخدمنا `expect` لطباعة رسالة خطأ عند فشل قراءة الملف،
لكن رسالة الخطأ تطبع فقط `Should have been able to read the file`. يمكن أن
تفشل قراءة ملف بعدة طرق: على سبيل المثال، قد يكون الملف مفقودًا، أو قد لا يكون
لدينا إذن لفتحه. في الوقت الحالي، بغض النظر عن الموقف، سنطبع نفس رسالة الخطأ
لكل شيء، مما لن يعطي المستخدم أي معلومات!

رابعًا، نستخدم `expect` للتعامل مع خطأ، وإذا قام المستخدم بتشغيل برنامجنا دون
تحديد معاملات كافية، فسيحصلون على خطأ `index out of bounds` من Rust والذي لا
يشرح المشكلة بوضوح. سيكون من الأفضل لو كان كل كود معالجة الأخطاء في مكان واحد
بحيث يكون للمشرفين المستقبليين مكان واحد فقط لمراجعة الكود إذا احتاج منطق
معالجة الأخطاء للتغيير. وجود كل كود معالجة الأخطاء في مكان واحد سيضمن أيضًا
أننا نطبع رسائل ذات معنى للمستخدمين النهائيين.

لنعالج هذه المشاكل الأربع بإعادة هيكلة مشروعنا.

<!-- Old headings. Do not remove or links may break. -->

<a id="separation-of-concerns-for-binary-projects"></a>

### فصل الاهتمامات في المشاريع الثنائية

تُعد المشكلة التنظيمية المتعلقة بتخصيص المسؤولية عن مهام متعددة لدالة `main`
شائعة في العديد من المشاريع الثنائية. ونتيجة لذلك، يجد العديد من مبرمجي Rust
أنه من المفيد تقسيم الاهتمامات المنفصلة لبرنامج ثنائي عندما تبدأ دالة `main` في
النمو. تتضمن هذه العملية الخطوات التالية:

- قسّم برنامجك إلى ملف _main.rs_ وملف _lib.rs_ وانقل منطق برنامجك إلى
  _lib.rs_.
- طالما كان منطق تحليل سطر الأوامر صغيرًا، يمكن أن يبقى في دالة `main`.
- عندما يبدأ منطق تحليل سطر الأوامر في التعقيد، استخرجه من دالة `main` إلى دوال
  أو أنواع أخرى.

المسؤوليات التي تبقى في دالة `main` بعد هذه العملية يجب أن تقتصر على ما يلي:

- استدعاء منطق تحليل سطر الأوامر بقيم المعاملات
- إعداد أي تكوين آخر
- استدعاء دالة `run` في _lib.rs_
- معالجة الخطأ إذا أرجعت `run` خطأ

يتعلق هذا النمط بفصل الاهتمامات: يتعامل _main.rs_ مع تشغيل البرنامج ويتعامل
_lib.rs_ مع جميع منطق المهمة قيد التنفيذ. لأنك لا تستطيع اختبار دالة `main`
مباشرة، تتيح لك هذه البنية اختبار جميع منطق برنامجك عن طريق نقله خارج دالة
`main`. الكود الذي يبقى في دالة `main` سيكون صغيرًا بما يكفي للتحقق من صحته
بقراءته. لنعيد العمل على برنامجنا باتباع هذه العملية.

#### استخراج محلل المعاملات

سنستخرج الوظيفة الخاصة بتحليل المعاملات إلى دالة ستستدعيها `main`. توضح
القائمة 12-5 بداية جديدة لدالة `main` التي تستدعي دالة جديدة `parse_config`،
والتي سنعرّفها في _src/main.rs_.

<Listing number="12-5" file-name="src/main.rs" caption="استخراج دالة `parse_config` من `main`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}
```

</Listing>

ما زلنا نجمع معاملات سطر الأوامر في متجه، لكن بدلاً من تعيين قيمة المعامل عند
الفهرس 1 إلى المتغير `query` وقيمة المعامل عند الفهرس 2 إلى المتغير
`file_path` داخل دالة `main`، نمرر المتجه كاملاً إلى دالة `parse_config`.
تحتفظ دالة `parse_config` بعد ذلك بالمنطق الذي يحدد أي معامل يذهب في أي متغير
وتمرر القيم مرة أخرى إلى `main`. ما زلنا ننشئ متغيري `query` و `file_path` في
`main`، لكن `main` لم تعد لديها مسؤولية تحديد كيف تتوافق معاملات سطر الأوامر
والمتغيرات.

قد تبدو إعادة العمل هذه مبالغة فيها لبرنامجنا الصغير، لكننا نعيد الهيكلة بخطوات
صغيرة ومتدرجة. بعد إجراء هذا التغيير، قم بتشغيل البرنامج مرة أخرى للتحقق من أن
تحليل المعاملات لا يزال يعمل. من الجيد التحقق من تقدمك بشكل متكرر، للمساعدة في
تحديد سبب المشاكل عند حدوثها.

#### تجميع قيم التكوين

يمكننا اتخاذ خطوة صغيرة أخرى لتحسين دالة `parse_config` بشكل أكبر. في الوقت
الحالي، نُرجع زوجًا (tuple)، ولكن بعد ذلك نقوم فورًا بتقسيم ذلك الزوج إلى أجزاء
فردية مرة أخرى. هذه علامة على أننا ربما لم نصل بعد إلى التجريد الصحيح.

مؤشر آخر يُظهر أن هناك مجالاً للتحسين هو جزء `config` من `parse_config`، الذي
يشير إلى أن القيمتين اللتين نعيدهما مرتبطتان وكلاهما جزء من قيمة تكوين واحدة.
نحن لا نوصل هذا المعنى حاليًا في بنية البيانات بخلاف تجميع القيمتين في زوج؛
سنضع القيمتين بدلاً من ذلك في بنية واحدة ونعطي كل حقل من حقول البنية اسمًا ذا
معنى. القيام بذلك سيسهل على المشرفين المستقبليين لهذا الكود فهم كيفية ارتباط
القيم المختلفة ببعضها البعض وما هو غرضها.

توضح القائمة 12-6 التحسينات على دالة `parse_config`.

<Listing number="12-6" file-name="src/main.rs" caption="إعادة هيكلة `parse_config` لإرجاع مثيل من بنية `Config`">

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}
```

</Listing>

أضفنا بنية تُسمى `Config` معرّفة لتحتوي على حقول تُسمى `query` و `file_path`.
يشير توقيع `parse_config` الآن إلى أنها تُرجع قيمة `Config`. في جسم
`parse_config`، حيث كنا نعيد شرائح نصية تشير إلى قيم `String` في `args`، الآن
نعرّف `Config` لتحتوي على قيم `String` مملوكة. متغير `args` في `main` هو
مالك قيم المعاملات ويسمح فقط لدالة `parse_config` باستعارتها، مما يعني أننا
سننتهك قواعد الاستعارة في Rust إذا حاول `Config` أخذ ملكية القيم في `args`.

هناك عدد من الطرق التي يمكننا بها إدارة بيانات `String`؛ الطريق الأسهل، وإن كان
غير فعال إلى حد ما، هو استدعاء تابع `clone` على القيم. سيؤدي هذا إلى إنشاء
نسخة كاملة من البيانات لمثيل `Config` ليمتلكها، وهو ما يستغرق وقتًا وذاكرة أكثر
من تخزين مَرجِع إلى بيانات النص. ومع ذلك، فإن استنساخ البيانات يجعل كودنا أيضًا
واضحًا جدًا لأننا لا نحتاج إلى إدارة مُدد صلاحية المَراجِع؛ في هذه الظروف،
التخلي عن القليل من الأداء لكسب البساطة هو مقايضة مفيدة.

> ### المقايضات في استخدام `clone`
>
> هناك ميل بين العديد من مستخدمي Rust لتجنب استخدام `clone` لإصلاح مشاكل
> الملكية بسبب تكلفتها في وقت التشغيل. في [الفصل 13][ch13]<!-- ignore -->،
> ستتعلم كيفية استخدام طرق أكثر كفاءة في هذا النوع من المواقف. لكن في الوقت
> الحالي، لا بأس من نسخ بضعة نصوص للاستمرار في التقدم لأنك ستقوم بهذه النسخ
> مرة واحدة فقط ومسار ملفك ونص استعلامك صغيران جدًا. من الأفضل أن يكون لديك
> برنامج يعمل وإن كان غير فعال قليلاً بدلاً من محاولة التحسين المفرط للكود في
> تمريرتك الأولى. مع اكتسابك مزيدًا من الخبرة مع Rust، سيكون من الأسهل البدء
> بالحل الأكثر كفاءة، لكن في الوقت الحالي، من المقبول تمامًا استدعاء `clone`.

لقد قمنا بتحديث `main` بحيث تضع مثيل `Config` المُرجع بواسطة `parse_config` في
متغير يُسمى `config`، وقمنا بتحديث الكود الذي كان يستخدم متغيري `query` و
`file_path` المنفصلين بحيث يستخدم الآن الحقول على بنية `Config` بدلاً من ذلك.

الآن يوصل كودنا بشكل أكثر وضوحًا أن `query` و `file_path` مرتبطان وأن غرضهما
هو تكوين كيفية عمل البرنامج. أي كود يستخدم هذه القيم يعرف أن يجدها في مثيل
`config` في الحقول المسماة لغرضها.

#### إنشاء منشئ لـ `Config`

حتى الآن، استخرجنا المنطق المسؤول عن تحليل معاملات سطر الأوامر من `main`
ووضعناه في دالة `parse_config`. ساعدنا ذلك في رؤية أن قيم `query` و
`file_path` كانت مرتبطة، وأن تلك العلاقة يجب أن تُنقل في كودنا. ثم أضفنا بنية
`Config` لتسمية الغرض المرتبط بـ `query` و `file_path` ولنتمكن من إرجاع أسماء
القيم كأسماء حقول بنية من دالة `parse_config`.

لذا، الآن بعد أن أصبح غرض دالة `parse_config` هو إنشاء مثيل `Config`، يمكننا
تغيير `parse_config` من دالة عادية إلى دالة تُسمى `new` مرتبطة ببنية `Config`.
إجراء هذا التغيير سيجعل الكود أكثر اصطلاحية. يمكننا إنشاء مثيلات من الأنواع في
المكتبة القياسية، مثل `String`، عن طريق استدعاء `String::new`. بالمثل، عن طريق
تغيير `parse_config` إلى دالة `new` مرتبطة بـ `Config`، سنتمكن من إنشاء
مثيلات من `Config` عن طريق استدعاء `Config::new`. توضح القائمة 12-7 التغييرات
التي نحتاج إلى إجرائها.

<Listing number="12-7" file-name="src/main.rs" caption="تغيير `parse_config` إلى `Config::new`">

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-07/src/main.rs:here}}
```

</Listing>

قمنا بتحديث `main` حيث كنا نستدعي `parse_config` لنستدعي `Config::new` بدلاً
من ذلك. لقد غيرنا اسم `parse_config` إلى `new` ونقلناها داخل كتلة `impl`، والتي
تربط دالة `new` بـ `Config`. حاول تصريف هذا الكود مرة أخرى للتأكد من أنه يعمل.

### إصلاح معالجة الأخطاء

الآن سنعمل على إصلاح معالجة الأخطاء لدينا. تذكر أن محاولة الوصول إلى القيم في
متجه `args` عند الفهرس 1 أو الفهرس 2 ستتسبب في ذعر البرنامج إذا احتوى المتجه
على أقل من ثلاثة عناصر. حاول تشغيل البرنامج بدون أي معاملات؛ سيبدو كالتالي:

```console
{{#include ../listings/ch12-an-io-project/listing-12-07/output.txt}}
```

السطر `index out of bounds: the len is 1 but the index is 1` هو رسالة خطأ
مخصصة للمبرمجين. لن تساعد مستخدمينا النهائيين على فهم ما يجب عليهم فعله بدلاً
من ذلك. لنصلح ذلك الآن.

#### تحسين رسالة الخطأ

في القائمة 12-8، نضيف فحصًا في دالة `new` سيتحقق من أن الشريحة طويلة بما يكفي
قبل الوصول إلى الفهرس 1 والفهرس 2. إذا لم تكن الشريحة طويلة بما يكفي، يحدث ذعر
للبرنامج ويعرض رسالة خطأ أفضل.

<Listing number="12-8" file-name="src/main.rs" caption="إضافة فحص لعدد المعاملات">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-08/src/main.rs:here}}
```

</Listing>

هذا الكود مشابه [لدالة `Guess::new` التي كتبناها في القائمة
9-13][ch9-custom-types]<!-- ignore -->، حيث استدعينا `panic!` عندما كانت قيمة
معامل `value` خارج نطاق القيم الصالحة. بدلاً من التحقق من نطاق من القيم هنا،
نتحقق من أن طول `args` على الأقل `3` ويمكن لبقية الدالة العمل بافتراض أن هذا
الشرط قد تم استيفاؤه. إذا كان لدى `args` أقل من ثلاثة عناصر، سيكون هذا الشرط
`true`، ونستدعي ماكرو `panic!` لإنهاء البرنامج فورًا.

مع هذه الأسطر القليلة الإضافية من الكود في `new`، لنقم بتشغيل البرنامج بدون أي
معاملات مرة أخرى لنرى كيف يبدو الخطأ الآن:

```console
{{#include ../listings/ch12-an-io-project/listing-12-08/output.txt}}
```

هذا الإخراج أفضل: لدينا الآن رسالة خطأ معقولة. ومع ذلك، لدينا أيضًا معلومات
إضافية لا نريد إعطاءها لمستخدمينا. ربما لا تكون التقنية التي استخدمناها في
القائمة 9-13 هي الأفضل للاستخدام هنا: استدعاء `panic!` أكثر ملاءمة لمشكلة
برمجية من مشكلة استخدام، [كما نوقش في الفصل 9][ch9-error-guidelines]<!--
ignore -->. بدلاً من ذلك، سنستخدم التقنية الأخرى التي تعلمتها في الفصل
9—[إرجاع `Result`][ch9-result]<!-- ignore --> الذي يشير إما إلى النجاح أو خطأ.

<!-- Old headings. Do not remove or links may break. -->

<a id="returning-a-result-from-new-instead-of-calling-panic"></a>

#### إرجاع `Result` بدلاً من استدعاء `panic!`

يمكننا بدلاً من ذلك إرجاع قيمة `Result` ستحتوي على مثيل `Config` في حالة
النجاح وستصف المشكلة في حالة الخطأ. سنغير أيضًا اسم الدالة من `new` إلى `build`
لأن العديد من المبرمجين يتوقعون أن دوال `new` لا تفشل أبدًا. عندما يتواصل
`Config::build` مع `main`، يمكننا استخدام نوع `Result` للإشارة إلى وجود مشكلة.
بعد ذلك، يمكننا تغيير `main` لتحويل متغير `Err` إلى خطأ أكثر عملية لمستخدمينا
بدون النص المحيط حول `thread 'main'` و `RUST_BACKTRACE` الذي يتسبب فيه استدعاء
`panic!`.

توضح القائمة 12-9 التغييرات التي نحتاج إلى إجرائها على قيمة الإرجاع للدالة التي
نسميها الآن `Config::build` وجسم الدالة اللازم لإرجاع `Result`. لاحظ أن هذا لن
يُصرّف حتى نحدّث `main` أيضًا، والذي سنفعله في القائمة التالية.

<Listing number="12-9" file-name="src/main.rs" caption="إرجاع `Result` من `Config::build`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-09/src/main.rs:here}}
```

</Listing>

تُرجع دالة `build` الخاصة بنا `Result` مع مثيل `Config` في حالة النجاح ونص
حرفي في حالة الخطأ. ستكون قيم الخطأ لدينا دائمًا نصوصًا حرفية لها مدة صلاحية
`'static`.

لقد أجرينا تغييرين في جسم الدالة: بدلاً من استدعاء `panic!` عندما لا يمرر
المستخدم معاملات كافية، نُرجع الآن قيمة `Err`، ولقد غلفنا قيمة إرجاع `Config` في
`Ok`. هذه التغييرات تجعل الدالة تتوافق مع توقيع النوع الجديد.

إرجاع قيمة `Err` من `Config::build` يسمح لدالة `main` بمعالجة قيمة `Result`
المُرجعة من دالة `build` والخروج من العملية بشكل أنظف في حالة الخطأ.

<!-- Old headings. Do not remove or links may break. -->

<a id="calling-confignew-and-handling-errors"></a>

#### استدعاء `Config::build` ومعالجة الأخطاء

للتعامل مع حالة الخطأ وطباعة رسالة سهلة الاستخدام، نحتاج إلى تحديث `main`
للتعامل مع `Result` الذي يتم إرجاعه بواسطة `Config::build`، كما هو موضح في
القائمة 12-10. سنأخذ أيضًا المسؤولية عن الخروج من أداة سطر الأوامر برمز خطأ غير
صفري بعيدًا عن `panic!` ونطبقه بأيدينا. رمز الخروج غير الصفري هو اتفاقية للإشارة
إلى العملية التي استدعت برنامجنا أن البرنامج خرج بحالة خطأ.

<Listing number="12-10" file-name="src/main.rs" caption="الخروج برمز خطأ إذا فشل بناء `Config`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-10/src/main.rs:here}}
```

</Listing>

في هذه القائمة، استخدمنا تابعًا لم نغطه بالتفصيل بعد: `unwrap_or_else`، والذي
يتم تعريفه على `Result<T, E>` بواسطة المكتبة القياسية. يتيح لنا استخدام
`unwrap_or_else` تعريف بعض معالجة الأخطاء المخصصة غير `panic!`. إذا كانت
`Result` قيمة `Ok`، فإن سلوك هذا التابع مشابه لـ `unwrap`: يُرجع القيمة
الداخلية التي يغلفها `Ok`. ومع ذلك، إذا كانت القيمة قيمة `Err`، يستدعي هذا
التابع الكود في الإغلاق، وهو دالة مجهولة نعرّفها ونمررها كمعامل إلى
`unwrap_or_else`. سنغطي الإغلاقات بمزيد من التفصيل في [الفصل 13][ch13]<!--
ignore -->. في الوقت الحالي، تحتاج فقط إلى معرفة أن `unwrap_or_else` سيمرر
القيمة الداخلية لـ `Err`، والتي في هذه الحالة هي النص الثابت `"not enough
arguments"` الذي أضفناه في القائمة 12-9، إلى إغلاقنا في المعامل `err` الذي
يظهر بين الأنابيب العمودية. يمكن للكود في الإغلاق بعد ذلك استخدام قيمة `err`
عند تشغيله.

أضفنا سطر `use` جديدًا لإدخال `process` من المكتبة القياسية إلى النطاق. الكود
في الإغلاق الذي سيتم تشغيله في حالة الخطأ هو سطران فقط: نطبع قيمة `err` ثم
نستدعي `process::exit`. ستوقف دالة `process::exit` البرنامج فورًا وتُرجع الرقم
الذي تم تمريره كرمز حالة الخروج. هذا مشابه للمعالجة المستندة إلى `panic!` التي
استخدمناها في القائمة 12-8، لكننا لم نعد نحصل على كل الإخراج الإضافي. لنجربه:

```console
{{#include ../listings/ch12-an-io-project/listing-12-10/output.txt}}
```

عظيم! هذا الإخراج أكثر ودية لمستخدمينا.

<!-- Old headings. Do not remove or links may break. -->

<a id="extracting-logic-from-the-main-function"></a>

### استخراج المنطق من `main`

الآن بعد أن انتهينا من إعادة هيكلة تحليل التكوين، لننتقل إلى منطق البرنامج. كما
ذكرنا في ["فصل الاهتمامات في المشاريع
الثنائية"](#separation-of-concerns-for-binary-projects)<!-- ignore -->، سنستخرج
دالة تُسمى `run` ستحتفظ بكل المنطق الموجود حاليًا في دالة `main` الذي لا يتعلق
بإعداد التكوين أو معالجة الأخطاء. عندما ننتهي، ستكون دالة `main` موجزة وسهلة
التحقق منها بالفحص، وسنتمكن من كتابة اختبارات لجميع المنطق الآخر.

توضح القائمة 12-11 التحسين الصغير المتدرج لاستخراج دالة `run`.

<Listing number="12-11" file-name="src/main.rs" caption="استخراج دالة `run` تحتوي على بقية منطق البرنامج">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-11/src/main.rs:here}}
```

</Listing>

تحتوي دالة `run` الآن على كل المنطق المتبقي من `main`، بدءًا من قراءة الملف.
تأخذ دالة `run` مثيل `Config` كمعامل.

<!-- Old headings. Do not remove or links may break. -->

<a id="returning-errors-from-the-run-function"></a>

#### إرجاع أخطاء من `run`

مع فصل منطق البرنامج المتبقي إلى دالة `run`، يمكننا تحسين معالجة الأخطاء، كما
فعلنا مع `Config::build` في القائمة 12-9. بدلاً من السماح للبرنامج بالذعر عن
طريق استدعاء `expect`، ستُرجع دالة `run` `Result<T, E>` عندما يحدث خطأ ما.
سيتيح لنا هذا مزيدًا من دمج المنطق حول معالجة الأخطاء في `main` بطريقة سهلة
الاستخدام. توضح القائمة 12-12 التغييرات التي نحتاج إلى إجرائها على توقيع وجسم
`run`.

<Listing number="12-12" file-name="src/main.rs" caption="تغيير دالة `run` لإرجاع `Result`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}
```

</Listing>

لقد أجرينا ثلاثة تغييرات مهمة هنا. أولاً، غيرنا نوع الإرجاع لدالة `run` إلى
`Result<(), Box<dyn Error>>`. أرجعت هذه الدالة سابقًا نوع الوحدة، `()`،
ونحتفظ بذلك كقيمة تُرجع في حالة `Ok`.

بالنسبة لنوع الخطأ، استخدمنا كائن السمة `Box<dyn Error>` (وأدخلنا
`std::error::Error` إلى النطاق بعبارة `use` في الأعلى). سنغطي كائنات السمات في
[الفصل 18][ch18]<!-- ignore -->. في الوقت الحالي، اعلم فقط أن `Box<dyn Error>`
يعني أن الدالة ستُرجع نوعًا ينفذ سمة `Error`، ولكن ليس علينا تحديد ما هو النوع
المحدد الذي ستكون عليه قيمة الإرجاع. هذا يمنحنا المرونة لإرجاع قيم خطأ قد تكون
من أنواع مختلفة في حالات خطأ مختلفة. الكلمة الأساسية `dyn` هي اختصار لـ
_dynamic_ (ديناميكي).

ثانيًا، أزلنا استدعاء `expect` لصالح المشغل `?`، كما تحدثنا في [الفصل
9][ch9-question-mark]<!-- ignore -->. بدلاً من `panic!` عند حدوث خطأ، سيُرجع `?`
قيمة الخطأ من الدالة الحالية للمستدعي للتعامل معها.

ثالثًا، تُرجع دالة `run` الآن قيمة `Ok` في حالة النجاح. لقد أعلنا نوع نجاح دالة
`run` كـ `()` في التوقيع، مما يعني أننا بحاجة إلى تغليف قيمة نوع الوحدة في قيمة
`Ok`. قد يبدو بناء `Ok(())` هذا غريبًا بعض الشيء في البداية. لكن استخدام `()`
بهذه الطريقة هو الطريقة الاصطلاحية للإشارة إلى أننا نستدعي `run` لآثارها
الجانبية فقط؛ لا تُرجع قيمة نحتاجها.

عندما تشغل هذا الكود، سيُصرّف لكنه سيعرض تحذيرًا:

```console
{{#include ../listings/ch12-an-io-project/listing-12-12/output.txt}}
```

تخبرنا Rust أن كودنا تجاهل قيمة `Result` وقد تشير قيمة `Result` إلى حدوث خطأ.
لكننا لا نتحقق مما إذا كان هناك خطأ أم لا، ويذكرنا المصرِّف بأننا ربما قصدنا أن
يكون لدينا بعض كود معالجة الأخطاء هنا! لنعالج تلك المشكلة الآن.

#### معالجة الأخطاء المُرجعة من `run` في `main`

سنتحقق من الأخطاء ونتعامل معها باستخدام تقنية مشابهة لتلك التي استخدمناها مع
`Config::build` في القائمة 12-10، ولكن مع اختلاف طفيف:

<span class="filename">اسم الملف: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}
```

نستخدم `if let` بدلاً من `unwrap_or_else` للتحقق مما إذا كانت `run` تُرجع قيمة
`Err` ولاستدعاء `process::exit(1)` إذا كان الأمر كذلك. لا تُرجع دالة `run`
قيمة نريد `unwrap` بها بنفس الطريقة التي تُرجع بها `Config::build` مثيل
`Config`. لأن `run` تُرجع `()` في حالة النجاح، نهتم فقط باكتشاف خطأ، لذا لا
نحتاج إلى `unwrap_or_else` لإرجاع القيمة غير الملفوفة، والتي ستكون فقط `()`.

أجساد `if let` و `unwrap_or_else` متطابقة في كلتا الحالتين: نطبع الخطأ ونخرج.

### تقسيم الكود إلى صندوق مكتبة

يبدو مشروع `minigrep` الخاص بنا جيدًا حتى الآن! الآن سنقسم ملف _src/main.rs_
ونضع بعض الكود في ملف _src/lib.rs_. بهذه الطريقة، يمكننا اختبار الكود ويكون لدينا
ملف _src/main.rs_ بمسؤوليات أقل.

لنعرّف الكود المسؤول عن البحث عن النص في _src/lib.rs_ بدلاً من _src/main.rs_،
مما سيتيح لنا (أو لأي شخص آخر يستخدم مكتبة `minigrep` الخاصة بنا) استدعاء دالة
البحث من سياقات أكثر من برنامجنا الثنائي `minigrep`.

أولاً، لنعرّف توقيع دالة `search` في _src/lib.rs_ كما هو موضح في القائمة 12-13،
مع جسم يستدعي ماكرو `unimplemented!`. سنشرح التوقيع بمزيد من التفصيل عندما نملأ
التطبيق.

<Listing number="12-13" file-name="src/lib.rs" caption="تعريف دالة `search` في *src/lib.rs*">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs}}
```

</Listing>

لقد استخدمنا الكلمة الأساسية `pub` على تعريف الدالة لتعيين `search` كجزء من
واجهة برمجة التطبيقات العامة لصندوق مكتبتنا. لدينا الآن صندوق مكتبة يمكننا
استخدامه من صندوقنا الثنائي ويمكننا اختباره!

الآن نحتاج إلى إدخال الكود المعرّف في _src/lib.rs_ إلى نطاق الصندوق الثنائي في
_src/main.rs_ واستدعائه، كما هو موضح في القائمة 12-14.

<Listing number="12-14" file-name="src/main.rs" caption="استخدام دالة `search` من صندوق مكتبة `minigrep` في *src/main.rs*">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}
```

</Listing>

نضيف سطر `use minigrep::search` لإدخال دالة `search` من صندوق المكتبة إلى نطاق
الصندوق الثنائي. ثم، في دالة `run`، بدلاً من طباعة محتويات الملف، نستدعي دالة
`search` ونمرر قيمة `config.query` و `contents` كمعاملات. بعد ذلك، ستستخدم
`run` حلقة `for` لطباعة كل سطر مُرجع من `search` طابق الاستعلام. هذا أيضًا وقت
جيد لإزالة استدعاءات `println!` في دالة `main` التي عرضت الاستعلام ومسار الملف
بحيث لا يطبع برنامجنا سوى نتائج البحث (إذا لم تحدث أخطاء).

لاحظ أن دالة البحث ستجمع جميع النتائج في متجه تُرجعه قبل حدوث أي طباعة. قد يكون
هذا التطبيق بطيئًا في عرض النتائج عند البحث في ملفات كبيرة، لأن النتائج لا تُطبع
عند العثور عليها؛ سنناقش طريقة محتملة لإصلاح هذا باستخدام المُكرِّرات في الفصل
13.

فيو! كان ذلك الكثير من العمل، لكننا أعددنا أنفسنا للنجاح في المستقبل. الآن من
الأسهل بكثير معالجة الأخطاء، ولقد جعلنا الكود أكثر نمطية. سيتم إنجاز جميع
أعمالنا تقريبًا في _src/lib.rs_ من الآن فصاعدًا.

لنستفد من هذه النمطية الجديدة من خلال القيام بشيء كان سيكون صعبًا مع الكود
القديم لكنه سهل مع الكود الجديد: سنكتب بعض الاختبارات!

[ch13]: ch13-00-functional-features.html
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[ch9-result]: ch09-02-recoverable-errors-with-result.html
[ch18]: ch18-00-oop.html
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
