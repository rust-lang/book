## بازسازی برای بهبود ماژولار بودن و مدیریت خطاها

برای بهبود برنامه خود، چهار مشکلی که به ساختار برنامه و نحوه مدیریت خطاهای بالقوه مربوط می‌شوند را رفع خواهیم کرد. 

<ul dir="rtl">
  <li>
    <strong>تک‌مسئولیتی کردن تابع <code>main</code></strong>:  
    در حال حاضر، تابع <code>main</code> دو وظیفه را انجام می‌دهد: تجزیه آرگومان‌ها و خواندن فایل‌ها. با رشد برنامه، تعداد وظایف جداگانه‌ای که تابع <code>main</code> باید مدیریت کند افزایش خواهد یافت. هرچه یک تابع مسئولیت‌های بیشتری داشته باشد، درک آن سخت‌تر می‌شود، تست کردن آن پیچیده‌تر خواهد شد و تغییر آن بدون آسیب به بخش‌های دیگر دشوارتر می‌شود. بهتر است قابلیت‌ها را جدا کنیم تا هر تابع فقط مسئول یک وظیفه باشد.
  </li>
  <li>
    <strong>گروه‌بندی متغیرهای پیکربندی</strong>:  
    متغیرهایی مانند <code>query</code> و <code>file_path</code> متغیرهای پیکربندی برای برنامه ما هستند، در حالی که متغیرهایی مانند <code>contents</code> برای اجرای منطق برنامه استفاده می‌شوند. هرچه تابع <code>main</code> طولانی‌تر شود، به متغیرهای بیشتری نیاز خواهد داشت که وارد دامنه شوند؛ و هرچه تعداد متغیرها بیشتر شود، پیگیری هدف هر متغیر دشوارتر خواهد شد. بهتر است متغیرهای پیکربندی را در یک ساختار گروه‌بندی کنیم تا هدف آن‌ها واضح‌تر باشد.
  </li>
  <li>
    <strong>بهبود پیام‌های خطا</strong>:  
    هنگام شکست در خواندن فایل، از <code>expect</code> برای چاپ پیام خطا استفاده کرده‌ایم، اما پیام خطا فقط <code>Should have been able to read the file</code> را چاپ می‌کند. خواندن یک فایل می‌تواند به دلایل مختلفی شکست بخورد: مثلاً ممکن است فایل وجود نداشته باشد یا ممکن است اجازه دسترسی به آن را نداشته باشیم. در حال حاضر، بدون توجه به شرایط، همان پیام خطا برای همه چیز چاپ می‌شود که اطلاعاتی به کاربر نمی‌دهد.
  </li>
  <li>
    <strong>یکپارچه‌سازی مدیریت خطاها</strong>:  
    اگر کاربر برنامه ما را بدون مشخص کردن تعداد کافی آرگومان اجرا کند، یک خطای <code>index out of bounds</code> از Rust دریافت می‌کنند که به وضوح مشکل را توضیح نمی‌دهد. بهتر است تمام کد مدیریت خطاها در یک مکان قرار گیرد تا نگهداری‌کنندگان آینده تنها یک مکان را برای بررسی تغییرات در منطق مدیریت خطا داشته باشند. این کار همچنین اطمینان حاصل می‌کند که پیام‌هایی که چاپ می‌شوند برای کاربران نهایی معنادار هستند.
  </li>
</ul>

### جداسازی وظایف برای پروژه‌های دودویی

مشکل تخصیص مسئولیت‌های چندگانه به تابع `main` در بسیاری از پروژه‌های دودویی رایج است. به همین دلیل، جامعه Rust دستورالعمل‌هایی برای تقسیم دغدغه‌های جداگانه یک برنامه دودویی ارائه داده است. این فرایند شامل مراحل زیر است:


<ul dir="rtl">
<li> برنامه خود را به فایل‌های _main.rs_ و _lib.rs_ تقسیم کرده و منطق برنامه را به _lib.rs_ منتقل کنید. </li>
<li> تا زمانی که منطق تجزیه آرگومان‌های خط فرمان کوچک است، می‌تواند در _main.rs_ باقی بماند. </li>
<li> وقتی منطق تجزیه آرگومان‌ها پیچیده شد، آن را از _main.rs_ جدا کرده و به _lib.rs_ منتقل کنید. </li>
</ul>

وظایفی که پس از این فرایند در تابع `main` باقی می‌مانند باید محدود به موارد زیر باشند:

<ul dir="rtl">
<li> فراخوانی منطق تجزیه آرگومان‌های خط فرمان با مقادیر آرگومان‌ها </li>
<li> تنظیم هرگونه پیکربندی دیگر </li>
<li> فراخوانی یک تابع `run` در _lib.rs_ </li>
<li> مدیریت خطاها در صورت بازگرداندن خطا توسط `run` </li>

</ul>

این الگو درباره جداسازی وظایف است: _main.rs_ اجرای برنامه را مدیریت می‌کند و _lib.rs_ تمام منطق مربوط به کار مورد نظر را مدیریت می‌کند. از آنجا که نمی‌توان تابع `main` را مستقیماً تست کرد، این ساختار به شما اجازه می‌دهد تمام منطق برنامه خود را با انتقال آن به توابع در _lib.rs_ تست کنید. کدی که در _main.rs_ باقی می‌ماند به اندازه کافی کوچک خواهد بود که با خواندن آن از صحت آن اطمینان حاصل کنید. بیایید برنامه خود را با پیروی از این فرایند بازسازی کنیم.

#### استخراج تجزیه‌کننده آرگومان‌ها

ما قابلیت تجزیه آرگومان‌ها را به یک تابع جداگانه استخراج می‌کنیم که تابع `main` آن را فراخوانی خواهد کرد تا برای انتقال منطق تجزیه آرگومان خط فرمان به فایل _src/lib.rs_ آماده شویم. لیست ۱۲-۵ شروع جدید تابع `main` را نشان می‌دهد که یک تابع جدید به نام `parse_config` را فراخوانی می‌کند، که در حال حاضر در _src/main.rs_ تعریف خواهیم کرد.

<Listing number="12-5" file-name="src/main.rs" caption="استخراج تابع `parse_config` از `main`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}
```

</Listing>

ما همچنان آرگومان‌های خط فرمان را به یک بردار جمع‌آوری می‌کنیم، اما به جای اینکه مقدار آرگومان در اندیس (index)۱ را به متغیر `query` و مقدار آرگومان در اندیس (index)۲ را به متغیر `file_path` در تابع `main` اختصاص دهیم، کل بردار را به تابع `parse_config` ارسال می‌کنیم. تابع `parse_config` سپس منطق مشخص می‌کند که کدام آرگومان در کدام متغیر قرار می‌گیرد و مقادیر را به تابع `main` بازمی‌گرداند. ما همچنان متغیرهای `query` و `file_path` را در `main` ایجاد می‌کنیم، اما `main` دیگر مسئول تعیین ارتباط آرگومان‌های خط فرمان و متغیرها نیست.

این تغییر ممکن است برای برنامه کوچک ما زیاده‌روی به نظر برسد، اما ما در حال بازسازی کد به صورت گام‌های کوچک و تدریجی هستیم. پس از اعمال این تغییر، دوباره برنامه را اجرا کنید تا اطمینان حاصل کنید که تجزیه آرگومان همچنان کار می‌کند. بررسی مداوم پیشرفت کد کمک می‌کند تا در صورت بروز مشکلات، علت آن‌ها را سریع‌تر شناسایی کنید.

#### گروه‌بندی مقادیر پیکربندی

می‌توانیم یک گام کوچک دیگر برای بهبود بیشتر تابع `parse_config` برداریم. در حال حاضر، ما یک tuple بازمی‌گردانیم، اما بلافاصله آن tuple را به قسمت‌های جداگانه تقسیم می‌کنیم. این نشانه‌ای است که شاید هنوز انتزاع درستی نداریم.

نشانه دیگری که نشان می‌دهد جا برای بهبود وجود دارد، قسمت `config` در `parse_config` است، که نشان می‌دهد دو مقداری که بازمی‌گردانیم به هم مرتبط هستند و هر دو بخشی از یک مقدار پیکربندی هستند. ما در حال حاضر این معنا را در ساختار داده‌ها به جز با گروه‌بندی دو مقدار در یک tuple منتقل نمی‌کنیم؛ در عوض، این دو مقدار را در یک struct قرار می‌دهیم و به هر یک از فیلدهای struct نامی معنادار می‌دهیم. انجام این کار درک نحوه ارتباط مقادیر مختلف و هدف آن‌ها را برای نگهداری‌کنندگان آینده این کد آسان‌تر می‌کند.

لیست ۱۲-۶ بهبودهای تابع `parse_config` را نشان می‌دهد.

<Listing number="12-6" file-name="src/main.rs" caption="بازسازی `parse_config` برای بازگرداندن یک نمونه از struct `Config`">

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}
```

</Listing>

ما یک ساختار جدید به نام `Config` تعریف کرده‌ایم که دارای فیلدهایی با نام‌های `query` و `file_path` است. امضای تابع `parse_config` اکنون نشان می‌دهد که این تابع یک مقدار `Config` را بازمی‌گرداند. در بدنه تابع `parse_config`، جایی که قبلاً اسلایس‌های رشته‌ای را که به مقادیر `String` در `args` اشاره می‌کردند بازمی‌گرداندیم، اکنون `Config` را طوری تعریف می‌کنیم که دارای مقادیر `String` متعلق به خود باشد.

متغیر `args` در تابع `main` مالک مقادیر آرگومان است و فقط به تابع `parse_config` اجازه قرض گرفتن آن‌ها را می‌دهد، به این معنی که اگر `Config` بخواهد مالک مقادیر در `args` شود، قوانین قرض‌گیری Rust را نقض می‌کنیم.

چندین روش برای مدیریت داده‌های `String` وجود دارد؛ ساده‌ترین و شاید ناکارآمدترین روش، فراخوانی متد `clone` روی مقادیر است. این کار یک کپی کامل از داده‌ها برای نمونه `Config` ایجاد می‌کند که مالک آن است. این روش زمان و حافظه بیشتری نسبت به ذخیره یک مرجع به داده‌ها نیاز دارد. با این حال، کپی کردن داده‌ها باعث می‌شود که کد ما بسیار ساده شود زیرا نیازی به مدیریت طول عمر مراجع نداریم؛ در این شرایط، از دست دادن کمی کارایی برای دستیابی به سادگی ارزشمند است.

> ### هزینه‌ها و مزایای استفاده از `clone`
>
> در بین بسیاری از برنامه‌نویسان Rust، تمایلی به استفاده از `clone` برای رفع مشکلات مالکیت به دلیل هزینه اجرای آن وجود دارد. در [فصل ۱۳][ch13]<!-- ignore -->، یاد خواهید گرفت که چگونه در این نوع موقعیت‌ها از روش‌های کارآمدتر استفاده کنید. اما در حال حاضر، کپی کردن چند رشته برای ادامه پیشرفت اشکالی ندارد زیرا این کپی‌ها فقط یک‌بار انجام می‌شوند و مسیر فایل و رشته جستجوی شما بسیار کوچک هستند. بهتر است یک برنامه کارا که کمی ناکارآمد است داشته باشید تا اینکه در اولین تلاش خود برای نوشتن کد، بهینه‌سازی بیش از حد انجام دهید. با تجربه بیشتر در Rust، شروع با راه‌حل کارآمدتر آسان‌تر خواهد بود، اما در حال حاضر استفاده از `clone` کاملاً قابل قبول است.

ما تابع `main` را به‌روزرسانی کردیم تا نمونه‌ای از `Config` که توسط `parse_config` بازگردانده می‌شود را در یک متغیر به نام `config` قرار دهد، و کدی که قبلاً از متغیرهای جداگانه `query` و `file_path` استفاده می‌کرد، اکنون از فیلدهای موجود در struct `Config` استفاده می‌کند.

اکنون کد ما به‌وضوح نشان می‌دهد که `query` و `file_path` به هم مرتبط هستند و هدف آن‌ها تنظیم نحوه کار برنامه است. هر کدی که از این مقادیر استفاده می‌کند می‌داند که باید آن‌ها را در نمونه `config` در فیلدهایی که نام آن‌ها برای هدفشان انتخاب شده است، پیدا کند.

#### ایجاد سازنده برای `Config`

تا اینجا، منطق مسئول تجزیه آرگومان‌های خط فرمان را از `main` استخراج کرده و در تابع `parse_config` قرار داده‌ایم. این کار به ما کمک کرد ببینیم که مقادیر `query` و `file_path` به هم مرتبط هستند و این رابطه باید در کد ما منتقل شود. سپس یک struct به نام `Config` اضافه کردیم تا هدف مشترک `query` و `file_path` را نام‌گذاری کنیم و بتوانیم نام مقادیر را به‌عنوان فیلدهای struct از تابع `parse_config` بازگردانیم.

حالا که هدف تابع `parse_config` ایجاد یک نمونه از `Config` است، می‌توانیم `parse_config` را از یک تابع معمولی به یک تابع با نام `new` تغییر دهیم که به struct `Config` مرتبط است. این تغییر کد را به‌صورت idiomatic‌تر می‌کند. ما می‌توانیم نمونه‌هایی از انواع موجود در کتابخانه استاندارد، مانند `String`، را با فراخوانی `String::new` ایجاد کنیم. به همین ترتیب، با تغییر `parse_config` به تابع `new` مرتبط با `Config`، می‌توانیم نمونه‌هایی از `Config` را با فراخوانی `Config::new` ایجاد کنیم. لیست ۱۲-۷ تغییرات لازم را نشان می‌دهد.

<Listing number="12-7" file-name="src/main.rs" caption="تغییر `parse_config` به `Config::new`">

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-07/src/main.rs:here}}
```

</Listing>

ما تابع `main` را که در آن `parse_config` را فراخوانی می‌کردیم به‌روزرسانی کرده‌ایم تا به‌جای آن `Config::new` را فراخوانی کند. نام `parse_config` را به `new` تغییر داده و آن را در یک بلوک `impl` قرار داده‌ایم که تابع `new` را به `Config` مرتبط می‌کند. کد را دوباره کامپایل کنید تا مطمئن شوید که کار می‌کند.

### رفع مشکلات مدیریت خطا

حالا روی رفع مشکلات مدیریت خطا کار می‌کنیم. به خاطر بیاورید که تلاش برای دسترسی به مقادیر موجود در بردار `args` در اندیس (index)۱ یا ۲ باعث می‌شود برنامه در صورت داشتن کمتر از سه آیتم، دچار وحشت شود. برنامه را بدون هیچ آرگومانی اجرا کنید؛ این حالت به شکل زیر خواهد بود:

```console
{{#include ../listings/ch12-an-io-project/listing-12-07/output.txt}}
```

خط `index out of bounds: the len is 1 but the index is 1` یک پیام خطا است که برای برنامه‌نویسان در نظر گرفته شده است. این پیام به کاربران نهایی کمکی نمی‌کند تا بفهمند باید چه کار کنند. حالا این مشکل را رفع می‌کنیم.

#### بهبود پیام خطا

در لیست ۱۲-۸، یک بررسی در تابع `new` اضافه می‌کنیم که بررسی می‌کند آیا آرایه به‌اندازه کافی طولانی است تا بتوان به اندیس‌های ۱ و ۲ دسترسی داشت. اگر طول آرایه کافی نباشد، برنامه دچار وحشت می‌شود و یک پیام خطای بهتر نمایش می‌دهد.

<Listing number="12-8" file-name="src/main.rs" caption="افزودن بررسی برای تعداد آرگومان‌ها">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-08/src/main.rs:here}}
```

</Listing>

این کد شبیه به [تابع `Guess::new` که در لیست ۹-۱۳ نوشتیم][ch9-custom-types]<!-- ignore --> است، جایی که وقتی آرگومان `value` خارج از محدوده مقادیر معتبر بود، `panic!` فراخوانی کردیم. به جای بررسی محدوده مقادیر، در اینجا بررسی می‌کنیم که طول `args` حداقل برابر با `3` باشد و بقیه تابع می‌تواند با فرض اینکه این شرط برقرار شده است، عمل کند. اگر `args` کمتر از سه آیتم داشته باشد، این شرط `true` خواهد بود و ما ماکرو `panic!` را برای خاتمه برنامه بلافاصله فراخوانی می‌کنیم.

با این چند خط اضافی در `new`، بیایید دوباره برنامه را بدون هیچ آرگومانی اجرا کنیم تا ببینیم اکنون پیام خطا چگونه است:

```console
{{#include ../listings/ch12-an-io-project/listing-12-08/output.txt}}
```

این خروجی بهتر است: اکنون یک پیام خطای منطقی داریم. با این حال، هنوز اطلاعات اضافی داریم که نمی‌خواهیم به کاربران خود ارائه دهیم. شاید تکنیکی که در لیست ۹-۱۳ استفاده کردیم بهترین گزینه برای اینجا نباشد: یک فراخوانی به `panic!` برای مشکل برنامه‌نویسی مناسب‌تر است تا یک مشکل استفاده، [همان‌طور که در فصل ۹ بحث شد][ch9-error-guidelines]<!-- ignore -->. در عوض، از تکنیک دیگری که در فصل ۹ یاد گرفتید استفاده می‌کنیم—[بازگرداندن یک `Result`][ch9-result]<!-- ignore --> که نشان‌دهنده موفقیت یا خطا است.

<a id="returning-a-result-from-new-instead-of-calling-panic"></a>

#### بازگرداندن یک `Result` به جای فراخوانی `panic!`

ما می‌توانیم به جای آن، یک مقدار `Result` بازگردانیم که در صورت موفقیت شامل یک نمونه از `Config` باشد و در صورت خطا مشکل را توصیف کند. همچنین قصد داریم نام تابع را از `new` به `build` تغییر دهیم زیرا بسیاری از برنامه‌نویسان انتظار دارند که توابع `new` هرگز شکست نخورند. وقتی `Config::build` با `main` ارتباط برقرار می‌کند، می‌توانیم از نوع `Result` برای اعلام مشکل استفاده کنیم. سپس می‌توانیم `main` را تغییر دهیم تا یک واریانت `Err` را به یک پیام خطای عملی‌تر برای کاربران خود تبدیل کنیم، بدون متن‌های اضافی مربوط به `thread 'main'` و `RUST_BACKTRACE` که یک فراخوانی به `panic!` ایجاد می‌کند.

لیست ۱۲-۹ تغییراتی را که باید در مقدار بازگشتی تابع که اکنون آن را `Config::build` می‌نامیم و بدنه تابع برای بازگرداندن یک `Result` ایجاد کنیم، نشان می‌دهد. توجه داشته باشید که این کد تا زمانی که `main` را نیز به‌روزرسانی نکنیم کامپایل نمی‌شود، که این کار را در لیست بعدی انجام خواهیم داد.

<Listing number="12-9" file-name="src/main.rs" caption="بازگرداندن یک `Result` از `Config::build`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-09/src/main.rs:here}}
```

</Listing>

#### تابع `build` و بازگشت مقدار `Result`

تابع `build` ما اکنون یک مقدار `Result` را بازمی‌گرداند که در صورت موفقیت شامل یک نمونه از `Config` و در صورت خطا یک مقدار رشته‌ای ثابت (`string literal`) است. مقادیر خطای ما همیشه رشته‌های ثابت با طول عمر `'static` خواهند بود.

ما دو تغییر در بدنه تابع ایجاد کرده‌ایم: به جای فراخوانی `panic!` زمانی که کاربر آرگومان‌های کافی ارائه نمی‌دهد، اکنون یک مقدار `Err` بازمی‌گردانیم و مقدار بازگشتی `Config` را در یک `Ok` قرار داده‌ایم. این تغییرات باعث می‌شوند تابع با امضای نوع جدید خود سازگار باشد.

بازگرداندن مقدار `Err` از `Config::build` به تابع `main` اجازه می‌دهد که مقدار `Result` بازگشتی از تابع `build` را مدیریت کرده و در صورت بروز خطا، فرآیند را به شکلی تمیزتر خاتمه دهد.

<a id="calling-confignew-and-handling-errors"></a>

#### فراخوانی `Config::build` و مدیریت خطاها

برای مدیریت حالت خطا و چاپ یک پیام دوستانه برای کاربر، باید تابع `main` را به‌روزرسانی کنیم تا مقدار `Result` بازگردانده‌شده توسط `Config::build` را مدیریت کند. این کار در لیست ۱۲-۱۰ نشان داده شده است. همچنین مسئولیت خاتمه دادن ابزار خط فرمان با کد خطای غیر صفر را از `panic!` گرفته و به صورت دستی پیاده‌سازی خواهیم کرد. کد خروجی غیر صفر به عنوان یک قرارداد برای اعلام وضعیت خطا به فرآیندی که برنامه ما را فراخوانده است، استفاده می‌شود.

<Listing number="12-10" file-name="src/main.rs" caption="خروج با کد خطا در صورت شکست در ساخت یک `Config`">


```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-10/src/main.rs:here}}
```

</Listing>

در این لیستینگ، ما از متدی استفاده کرده‌ایم که هنوز جزئیات آن را به‌طور کامل پوشش نداده‌ایم: `unwrap_or_else`. این متد که در استاندارد کتابخانه Rust برای `Result<T, E>` تعریف شده است، به ما امکان می‌دهد مدیریت خطاهای سفارشی و بدون استفاده از `panic!` را تعریف کنیم. اگر مقدار `Result` از نوع `Ok` باشد، رفتار این متد مشابه `unwrap` است: مقدار داخلی که `Ok` در خود قرار داده را بازمی‌گرداند. با این حال، اگر مقدار از نوع `Err` باشد، این متد کدی را که در _closure_ تعریف کرده‌ایم اجرا می‌کند. _Closure_ یک تابع ناشناس است که آن را تعریف کرده و به‌عنوان آرگومان به `unwrap_or_else` ارسال می‌کنیم. 

ما closures را به تفصیل در [فصل ۱۳][ch13] توضیح خواهیم داد. فعلاً کافی است بدانید که `unwrap_or_else` مقدار داخلی `Err` را به _closure_ می‌دهد. در اینجا، مقدار استاتیک `"not enough arguments"` که در لیستینگ 12-9 اضافه کردیم، به _closure_ ارسال شده و به آرگومان `err` تخصیص داده می‌شود، که بین خط عمودی‌ها قرار دارد. کد درون _closure_ سپس می‌تواند از مقدار `err` استفاده کند.

ما همچنین یک خط جدید `use` اضافه کرده‌ایم تا `process` را از کتابخانه استاندارد به محدوده بیاوریم. کدی که در حالت خطا اجرا می‌شود تنها شامل دو خط است: ابتدا مقدار `err` را چاپ می‌کنیم و سپس `process::exit` را فراخوانی می‌کنیم. تابع `process::exit` بلافاصله برنامه را متوقف کرده و عددی که به‌عنوان کد وضعیت خروج ارسال شده است را بازمی‌گرداند. این روش شبیه مدیریت مبتنی بر `panic!` است که در لیستینگ 12-8 استفاده کردیم، اما دیگر خروجی اضافی تولید نمی‌شود. حالا آن را آزمایش کنیم:

```console
{{#include ../listings/ch12-an-io-project/listing-12-10/output.txt}}
```

عالی! این خروجی برای کاربران ما بسیار دوستانه‌تر است.

### جداسازی منطق از `main`

اکنون که بازآرایی برای تجزیه تنظیمات را به پایان رسانده‌ایم، بیایید به منطق برنامه بپردازیم. همان‌طور که در [«تفکیک نگرانی‌ها برای پروژه‌های باینری»](#separation-of-concerns-for-binary-projects)<!-- ignore --> بیان کردیم، تابعی به نام `run` استخراج خواهیم کرد که تمام منطقی که در حال حاضر در تابع `main` وجود دارد و مربوط به تنظیمات یا مدیریت خطا نیست را نگه می‌دارد. هنگامی که کار ما تمام شود، `main` مختصر و آسان برای بررسی خواهد بود و می‌توانیم تست‌هایی برای سایر منطق‌ها بنویسیم.

لیست ۱۲-۱۱ تابع استخراج‌شده `run` را نشان می‌دهد. فعلاً فقط بهبود کوچکی انجام می‌دهیم که تابع را استخراج کنیم. همچنان تابع را در فایل _src/main.rs_ تعریف می‌کنیم.

<Listing number="12-11" file-name="src/main.rs" caption="استخراج تابع `run` از `main`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-11/src/main.rs:here}}
```

</Listing>

با این تغییرات، `main` اکنون تابع `run` را فراخوانی می‌کند و مسئولیت اجرای منطق اصلی برنامه را به آن واگذار می‌کند. این جداسازی باعث می‌شود تابع `main` ساده‌تر شود و ما بتوانیم تست‌های دقیقی برای بخش‌های مختلف کد بنویسیم. این روش به بهبود قابلیت نگهداری و خوانایی کد کمک شایانی می‌کند.

### بازگرداندن خطاها از تابع `run`

اکنون که منطق باقی‌مانده برنامه را در تابع `run` جدا کرده‌ایم، می‌توانیم مانند `Config::build` در لیستینگ 12-9، مدیریت خطا را بهبود بخشیم. به جای اجازه دادن به برنامه برای اجرای `panic` با فراخوانی `expect`، تابع `run` در صورت بروز مشکل یک `Result<T, E>` بازمی‌گرداند. این رویکرد به ما امکان می‌دهد منطق مرتبط با مدیریت خطا را به صورت کاربرپسندانه‌ای در تابع `main` متمرکز کنیم. تغییرات لازم برای امضا و بدنه تابع `run` در لیستینگ 12-12 نشان داده شده است:

<Listing number="12-12" file-name="src/main.rs" caption="تغییر تابع `run` برای بازگرداندن `Result`">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}
```

</Listing>

### تغییرات مهم

<ul dir="rtl">
  <li>
    <strong>تغییر نوع بازگشتی:</strong>  
    نوع بازگشتی تابع <code>run</code> به <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> تغییر داده شده است. این تابع قبلاً نوع واحد (<code>()</code>) را بازمی‌گرداند، که همچنان برای حالت موفقیت حفظ شده است.  
    برای نوع خطا از یک <strong>شیء صفات</strong> به نام <code>Box&lt;dyn Error&gt;</code> استفاده کرده‌ایم (و با استفاده از <code>use</code>، <code>std::error::Error</code> را به محدوده آورده‌ایم). در فصل 18 بیشتر درباره شیء صفات صحبت خواهیم کرد. فعلاً کافی است بدانید که <code>Box&lt;dyn Error&gt;</code> به این معنا است که تابع می‌تواند نوعی از مقدار را که صفت <code>Error</code> را پیاده‌سازی کرده بازگرداند، بدون اینکه نوع خاصی را مشخص کند. کلمه کلیدی <code>dyn</code> به معنای <strong>دینامیک</strong> است.
  </li>
  <li>
    <strong>حذف <code>expect</code> و استفاده از عملگر <code>?</code>:</strong>  
    به جای استفاده از <code>panic!</code> در صورت بروز خطا، عملگر <code>?</code> مقدار خطا را از تابع جاری بازمی‌گرداند تا فراخوانی‌کننده بتواند آن را مدیریت کند.
  </li>
  <li>
    <strong>بازگرداندن مقدار <code>Ok</code> در حالت موفقیت:</strong>  
    تابع <code>run</code> اکنون در حالت موفقیت مقدار <code>Ok</code> را بازمی‌گرداند. ما نوع موفقیت تابع را به عنوان <code>()</code> در امضا تعریف کرده‌ایم، که به این معنا است که باید مقدار نوع واحد را در مقدار <code>Ok</code> قرار دهیم. نحو <code>Ok(())</code> ممکن است در ابتدا کمی عجیب به نظر برسد، اما استفاده از <code>()</code> به این صورت روش استاندارد برای نشان دادن این است که تابع <code>run</code> تنها برای تأثیرات جانبی فراخوانی شده و مقداری بازنمی‌گرداند که به آن نیاز داشته باشیم.
  </li>
</ul>
```

### بررسی کد

اجرای این کد باعث می‌شود که کد کامپایل شود اما یک هشدار نمایش دهد:

```console
{{#include ../listings/ch12-an-io-project/listing-12-12/output.txt}}
```

Rust به ما یادآوری می‌کند که کد ما مقدار `Result` را نادیده گرفته است و این مقدار ممکن است نشان‌دهنده بروز خطا باشد. اما ما بررسی نمی‌کنیم که آیا خطایی رخ داده است یا خیر، و کامپایلر به ما یادآوری می‌کند که احتمالاً نیاز به مدیریت خطا در این بخش داریم. اکنون این مشکل را اصلاح خواهیم کرد.

#### مدیریت خطاهای بازگردانده‌شده از `run` در `main`

ما خطاها را بررسی کرده و با استفاده از تکنیکی مشابه آنچه در `Config::build` در لیست ۱۲-۱۰ استفاده کردیم مدیریت می‌کنیم، اما با یک تفاوت کوچک:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}
```

ما به جای `unwrap_or_else` از `if let` استفاده می‌کنیم تا بررسی کنیم آیا `run` یک مقدار `Err` بازمی‌گرداند یا خیر و در صورت وقوع، `process::exit(1)` را فراخوانی کنیم. تابع `run` مقداری بازنمی‌گرداند که بخواهیم به همان شیوه‌ای که `Config::build` نمونه `Config` را بازمی‌گرداند آن را `unwrap` کنیم. از آنجایی که `run` در صورت موفقیت مقدار `()` بازمی‌گرداند، ما فقط به شناسایی یک خطا اهمیت می‌دهیم، بنابراین نیازی به `unwrap_or_else` برای بازگرداندن مقدار آن نداریم، که تنها `()` خواهد بود.

بدنه‌های `if let` و `unwrap_or_else` در هر دو حالت یکسان هستند: ما خطا را چاپ کرده و خارج می‌شویم.

### تقسیم کد به یک کتابخانه

پروژه `minigrep` ما تا اینجا خوب پیش می‌رود! اکنون کد فایل _src/main.rs_ را تقسیم کرده و برخی از کد را به فایل _src/lib.rs_ منتقل می‌کنیم. به این ترتیب، می‌توانیم کد را تست کنیم و فایل _src/main.rs_ مسئولیت‌های کمتری داشته باشد.

بیایید تمام کدی که در تابع `main` نیست از _src/main.rs_ به _src/lib.rs_ منتقل کنیم:

<ul dir="rtl">

<li> تعریف تابع `run` </li>
<li> دستورات `use` مرتبط </li>
<li> تعریف `Config` </li>
<li> تعریف تابع `Config::build` </li>

</ul>

محتویات فایل _src/lib.rs_ باید امضاهایی که در لیست ۱۲-۱۳ آمده است را داشته باشد (بدنه توابع برای اختصار حذف شده است). توجه داشته باشید که این کد تا زمانی که _src/main.rs_ را همانطور که در لیست ۱۲-۱۴ نشان داده شده است تغییر ندهیم کامپایل نمی‌شود.

<Listing number="12-13" file-name="src/lib.rs" caption="انتقال `Config` و `run` به *src/lib.rs*">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs:here}}
```

</Listing>

ما به طور گسترده از کلمه کلیدی `pub` استفاده کرده‌ایم: در `Config`، فیلدهای آن، متد `build` و همچنین تابع `run`. اکنون یک crate کتابخانه‌ای داریم که یک API عمومی دارد و می‌توانیم آن را تست کنیم!

حالا باید کدی که به _src/lib.rs_ منتقل کرده‌ایم را به محدوده crate باینری در _src/main.rs_ بیاوریم، همانطور که در لیست ۱۲-۱۴ نشان داده شده است.

<Listing number="12-14" file-name="src/main.rs" caption="استفاده از crate کتابخانه‌ای `minigrep` در *src/main.rs*">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}
```

</Listing>

ما خط `use minigrep::Config` را اضافه کرده‌ایم تا نوع `Config` را از crate کتابخانه‌ای به محدوده crate باینری بیاوریم، و تابع `run` را با پیشوند نام crate فراخوانی کرده‌ایم. اکنون همه قابلیت‌ها باید متصل شوند و کار کنند. برنامه را با `cargo run` اجرا کنید و مطمئن شوید که همه چیز به درستی کار می‌کند.

وای! این یک کار سخت بود، اما ما خودمان را برای موفقیت در آینده آماده کردیم. اکنون مدیریت خطاها بسیار آسان‌تر شده است و کد ما ماژولارتر شده است. از اینجا به بعد تقریباً تمام کارهای ما در فایل _src/lib.rs_ انجام خواهد شد.

بیایید از این ماژولاریت جدید برای انجام کاری استفاده کنیم که با کد قبلی دشوار بود اما با کد جدید آسان است: نوشتن چند تست!

[ch13]: ch13-00-functional-features.html  
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation  
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling  
[ch9-result]: ch09-02-recoverable-errors-with-result.html  
[ch18]: ch18-00-oop.html  
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator  
