## الجمع بين كل شيء: المستقبلات والمهام والخيوط

كما رأينا في [الفصل 16][ch16]<!-- ignore -->، توفر الخيوط نهجًا واحدًا للتزامن. لقد رأينا نهجًا آخر في هذا الفصل: استخدام async مع المستقبلات والتدفقات. إذا كنت تتساءل متى تختار إحدى الطريقتين على الأخرى، فالإجابة هي: يعتمد! وفي كثير من الحالات، لا يكون الخيار هو الخيوط _أو_ async بل الخيوط _و_ async.

توفر العديد من أنظمة التشغيل نماذج تزامن قائمة على الخيوط منذ عقود، ودعمت العديد من لغات البرمجة لها نتيجة لذلك. ومع ذلك، هذه النماذج ليست بدون مقايضاتها. في العديد من أنظمة التشغيل، تستخدم قدرًا لا بأس به من الذاكرة لكل خيط. الخيوط هي أيضًا خيار فقط عندما يدعمها نظام التشغيل والأجهزة. على عكس أجهزة الكمبيوتر المكتبية والمحمولة السائدة، بعض الأنظمة المضمنة ليس لديها نظام تشغيل على الإطلاق، لذلك ليس لديها خيوط أيضًا.

يوفر نموذج async مجموعة مختلفة - وفي النهاية تكميلية - من المقايضات. في نموذج async، لا تتطلب العمليات المتزامنة خيوطها الخاصة. بدلاً من ذلك، يمكنها العمل على المهام، كما هو الحال عندما استخدمنا `trpl::spawn_task` لبدء العمل من دالة متزامنة في قسم التدفقات. المهمة تشبه الخيط، ولكن بدلاً من إدارتها بواسطة نظام التشغيل، تتم إدارتها بواسطة كود مستوى المكتبة: بيئة التشغيل.

هناك سبب لكون واجهات برمجة التطبيقات لإنشاء الخيوط وإنشاء المهام متشابهة جدًا. الخيوط تعمل كحدود لمجموعات من العمليات المتزامنة؛ التزامن ممكن _بين_ الخيوط. المهام تعمل كحدود لمجموعات من العمليات _غير المتزامنة_؛ التزامن ممكن _بين_ و _داخل_ المهام، لأن المهمة يمكنها التبديل بين المستقبلات في نصها. أخيرًا، المستقبلات هي أصغر وحدة تزامن في Rust، وكل مستقبل قد يمثل شجرة من المستقبلات الأخرى. بيئة التشغيل - على وجه الخصوص، منفذها - تدير المهام، والمهام تدير المستقبلات. من هذا المنظور، المهام تشبه الخيوط الخفيفة المدارة من بيئة التشغيل مع قدرات إضافية تأتي من كونها مدارة من بيئة تشغيل بدلاً من نظام التشغيل.

هذا لا يعني أن المهام غير المتزامنة أفضل دائمًا من الخيوط (أو العكس). التزامن مع الخيوط هو في بعض النواحي نموذج برمجة أبسط من التزامن مع `async`. هذا يمكن أن يكون نقطة قوة أو ضعف. الخيوط إلى حد ما "إطلاق ونسيان"؛ ليس لديها ما يعادل الأصلي للمستقبل، لذلك تعمل فقط حتى الاكتمال دون انقطاع باستثناء من قبل نظام التشغيل نفسه.

واتضح أن الخيوط والمهام غالبًا ما تعمل بشكل جيد معًا، لأنه يمكن نقل المهام (على الأقل في بعض بيئات التشغيل) بين الخيوط. في الواقع، تحت الغطاء، بيئة التشغيل التي كنا نستخدمها - بما في ذلك دالتي `spawn_blocking` و `spawn_task` - متعددة الخيوط بشكل افتراضي! العديد من بيئات التشغيل تستخدم نهجًا يسمى _سرقة العمل_ (work stealing) لنقل المهام بشفافية بين الخيوط، بناءً على كيفية استخدام الخيوط حاليًا، لتحسين الأداء الكلي للنظام. يتطلب هذا النهج في الواقع الخيوط _والمهام_، وبالتالي المستقبلات.

عند التفكير في الطريقة التي يجب استخدامها، ضع في اعتبارك قواعد الإبهام التالية:

- إذا كان العمل _متوازيًا جدًا_ (أي، مرتبط بالمعالج)، مثل معالجة مجموعة من البيانات حيث يمكن معالجة كل جزء بشكل منفصل، فالخيوط هي خيار أفضل.
- إذا كان العمل _متزامنًا جدًا_ (أي، مرتبط بالإدخال/الإخراج)، مثل معالجة الرسائل من مجموعة من المصادر المختلفة التي قد تأتي في أوقات مختلفة أو بمعدلات مختلفة، فإن async هو خيار أفضل.

وإذا كنت بحاجة إلى التوازي والتزامن معًا، فليس عليك الاختيار بين الخيوط و async. يمكنك استخدامها معًا بحرية، مما يسمح لكل منهما بلعب الدور الذي يتقنه. على سبيل المثال، القائمة 17-25 تُظهر مثالاً شائعًا إلى حد ما لهذا النوع من المزيج في كود Rust في العالم الحقيقي.

<Listing number="17-25" caption="إرسال الرسائل بكود حجب في خيط وانتظار الرسائل في كتلة async" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-25/src/main.rs:all}}
```

</Listing>

نبدأ بإنشاء قناة async، ثم إنشاء خيط يأخذ ملكية جانب المرسل من القناة باستخدام الكلمة الأساسية `move`. داخل الخيط، نرسل الأرقام من 1 إلى 10، مع النوم لمدة ثانية واحدة بين كل رقم. أخيرًا، نشغل مستقبلًا تم إنشاؤه باستخدام كتلة async ممررة إلى `trpl::block_on` تمامًا كما فعلنا في جميع أنحاء الفصل. في ذلك المستقبل، ننتظر تلك الرسائل، تمامًا كما في أمثلة تمرير الرسائل الأخرى التي رأيناها.

للعودة إلى السيناريو الذي فتحنا به الفصل، تخيل تشغيل مجموعة من مهام ترميز الفيديو باستخدام خيط مخصص (لأن ترميز الفيديو مرتبط بالحساب) ولكن إخطار واجهة المستخدم بأن تلك العمليات قد انتهت باستخدام قناة async. هناك أمثلة لا حصر لها من هذه الأنواع من المجموعات في حالات الاستخدام في العالم الحقيقي.

## الخلاصة

هذا ليس آخر ما ستراه من التزامن في هذا الكتاب. سيطبق المشروع في [الفصل 21][ch21]<!-- ignore --> هذه المفاهيم في وضع أكثر واقعية من الأمثلة الأبسط التي نوقشت هنا ويقارن حل المشكلات بالخيوط مقابل المهام والمستقبلات بشكل أكثر مباشرة.

بغض النظر عن أي من هذه الأساليب التي تختارها، تمنحك Rust الأدوات التي تحتاجها لكتابة كود آمن وسريع ومتزامن - سواء لخادم ويب عالي الإنتاجية أو نظام تشغيل مضمن.

بعد ذلك، سنتحدث عن الطرق الاصطلاحية لنمذجة المشكلات وهيكلة الحلول مع نمو برامج Rust الخاصة بك. بالإضافة إلى ذلك، سنناقش كيفية ارتباط تعابير Rust بتلك التي قد تكون معتادًا عليها من البرمجة كائنية التوجه.

[ch16]: http://localhost:3000/ch16-00-concurrency.html
[combining-futures]: ch17-03-more-futures.html#building-our-own-async-abstractions
[streams]: ch17-04-streams.html#composing-streams
[ch21]: ch21-00-final-project-a-web-server.html
